<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全科-不安分的码农</title>
  
  <subtitle>android，ios，html5，微服务架构，XP，scrum，项目管理（PMP）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://quanke.name/"/>
  <updated>2018-02-02T16:03:45.000Z</updated>
  <id>http://quanke.name/</id>
  
  <author>
    <name>全科</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot 与 Kotlin 使用Freemarker模板引擎渲染web视图</title>
    <link href="http://quanke.name/posts/39947/"/>
    <id>http://quanke.name/posts/39947/</id>
    <published>2018-02-02T16:01:59.000Z</published>
    <updated>2018-02-02T16:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="https://www.jianshu.com/p/884632f71bc7" target="_blank" rel="external">《Spring Boot 与 Kotlin 使用Thymeleaf模板引擎渲染web视图》</a> 一文中，我们使用Thymeleaf模板引擎渲染web视图，体验了kotlin 与spring boot结合是相当好的，这篇文章中继续介绍web视图，但是是使用Freemarker模板引擎渲染web视图。</p></blockquote><p>Web相关的介绍这里就不多阐述，还没了解的请移步《Spring Boot 与 Kotlin 使用Thymeleaf模板引擎渲染web视图》</p><h2 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h2><p><code>FreeMarker</code>是一款模板引擎： 即一种基于模板和要改变的数据，    并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。    它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。</p><p><code>FreeMarker</code>是免费的，基于Apache许可证2.0版本发布。其模板编写为<code>FreeMarker Template Language（FTL）</code>，属于简单、专用的语言。需要准备数据在真实编程语言中来显示，比如数据库查询和业务运算，    之后模板显示已经准备好的数据。在模板中，主要用于如何展现数据，    而在模板之外注意于要展示什么数据 。</p><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><ul><li>${…}：FreeMarker将会输出真实的值来替换大括号内的表达式，这样的表达式被称为interpolation（插值）。</li><li>注释：注释和HTML的注释也很相似，但是它们使用&lt;#– and –&gt;来标识。不像HTML注释那样，FTL注释不会出现在输出中（不出现在访问者的页面中），因为FreeMarker会跳过它们。</li><li>FTL标签（FreeMarker模板的语言标签）：FTL标签和HTML标签有一些相似之处，但是它们是FreeMarker的指令，是不会在输出中打印的。这些标签的名字以#开头。（用户自定义的FTL标签则需要使用@来代替#）</li></ul><h3 id="模版实例"><a href="#模版实例" class="headerlink" title="模版实例"></a>模版实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;title&gt;Welcome!&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;h1&gt;Welcome $&#123;username&#125;!&lt;/h1&gt;</div><div class="line">        &lt;p&gt;Our latest product:</div><div class="line">        &lt;a href=&quot;$&#123;latestProduct.url&#125;&quot;&gt;$&#123;latestProduct.name&#125;&lt;/a&gt;!</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>在Spring Boot中使用<code>FreeMarker</code>相关的，只需要引入下面依赖，并在默认的模板路径<code>src/main/resources/templates</code>下编写模板文件即可完成。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">compile &quot;org.springframework.boot:spring-boot-starter-freemarker:$spring_boot_version&quot;</div></pre></td></tr></table></figure><p>完整的<code>build.gradle</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">group &apos;name.quanke.kotlin&apos;</div><div class="line">version &apos;1.0-SNAPSHOT&apos;</div><div class="line"></div><div class="line">buildscript &#123;</div><div class="line">    ext.kotlin_version = &apos;1.2.10&apos;</div><div class="line">    ext.spring_boot_version = &apos;1.5.4.RELEASE&apos;</div><div class="line">    repositories &#123;</div><div class="line">        mavenCentral()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</div><div class="line">        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)</div><div class="line"></div><div class="line">//        Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件</div><div class="line">        classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;)</div><div class="line">        classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">apply plugin: &apos;kotlin&apos;</div><div class="line">apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-plugin</div><div class="line">apply plugin: &apos;org.springframework.boot&apos;</div><div class="line"></div><div class="line">jar &#123;</div><div class="line">    baseName = &apos;chapter11-5-2-service&apos;</div><div class="line">    version = &apos;0.1.0&apos;</div><div class="line">&#125;</div><div class="line">repositories &#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot;</div><div class="line">    compile &quot;org.springframework.boot:spring-boot-starter-web:$spring_boot_version&quot;</div><div class="line">    compile &quot;org.springframework.boot:spring-boot-starter-freemarker:$spring_boot_version&quot;</div><div class="line">    testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot;</div><div class="line">    testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">compileKotlin &#123;</div><div class="line">    kotlinOptions.jvmTarget = &quot;1.8&quot;</div><div class="line">&#125;</div><div class="line">compileTestKotlin &#123;</div><div class="line">    kotlinOptions.jvmTarget = &quot;1.8&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="举个例子：通过FreeMarker渲染一个页面。"><a href="#举个例子：通过FreeMarker渲染一个页面。" class="headerlink" title="举个例子：通过FreeMarker渲染一个页面。"></a>举个例子：通过FreeMarker渲染一个页面。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">import org.springframework.stereotype.Controller</div><div class="line">import org.springframework.ui.Model</div><div class="line">import org.springframework.web.bind.annotation.RequestMapping</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by http://quanke.name on 2018/1/10.</div><div class="line"> */</div><div class="line">@Controller</div><div class="line">class HelloController &#123;</div><div class="line"></div><div class="line">    @RequestMapping(&quot;/&quot;)</div><div class="line">    fun index(model: Model): String &#123;</div><div class="line">//        / 加入一个属性，用来在模板中读取</div><div class="line">        model.addAttribute(&quot;host&quot;, &quot;http://quanke.name&quot;)</div><div class="line">        // return模板文件的名称，对应src/main/resources/templates/index.ftl</div><div class="line">        return &quot;index&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>默认在 <code>src/main/resources/templates</code>目录下增加<code>index.ftl</code>文件</p><blockquote><p>注意Freemarker模版的后缀默认是<code>ftl</code>,Thymeleaf模版后缀默认是<code>html</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h4&gt;我的博客：$&#123;host&#125;！&lt;/h4&gt;</div><div class="line">&lt;h1&gt;quanke.name&lt;/h1&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>增加使用 <code>kotlin</code>语言实现的 <code>Spring Boot</code>启动方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.springframework.boot.SpringApplication</div><div class="line">import org.springframework.boot.autoconfigure.SpringBootApplication</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by http://quanke.name on 2018/1/9.</div><div class="line"> */</div><div class="line"></div><div class="line">@SpringBootApplication</div><div class="line">class Application</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    SpringApplication.run(Application::class.java, *args)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<code>application.yml</code>文中增加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#设定ftl文件路径</div><div class="line">spring:</div><div class="line">  freemarker:</div><div class="line">    template-loader-path: classpath:/templates</div></pre></td></tr></table></figure><p>如上页面，直接打开html页面展现Hello World，但是启动程序后，访问<a href="http://localhost:8080/，则是展示Controller中host的值：http://quanke.name，做到了不破坏HTML自身内容的数据逻辑分离。" target="_blank" rel="external">http://localhost:8080/，则是展示Controller中host的值：http://quanke.name，做到了不破坏HTML自身内容的数据逻辑分离。</a></p><p>更多 <code>FreeMarker</code>相关的，还请访问 <a href="https://freemarker.apache.org/" target="_blank" rel="external">FreeMarker 官网</a> 查询使用。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul><li><a href="https://github.com/quanke/spring-boot-with-kotlin-in-action/chapter11-5-2" target="_blank" rel="external">https://github.com/quanke/spring-boot-with-kotlin-in-action/chapter11-5-2</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-web-freemarker" target="_blank" rel="external">https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-web-freemarker</a></li></ul><p>欢迎关注：</p><p><a href="http://quanke.name/spring-boot-with-kotlin-in-action">《Spring Boot in kotlin 实战》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.jianshu.com/p/884632f71bc7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Spring Boot 与 Kotlin 使用Thymeleaf模板引擎渲染web视
      
    
    </summary>
    
      <category term="Spring Boot与kotlin实战" scheme="http://quanke.name/categories/Spring-Boot%E4%B8%8Ekotlin%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="kotlin" scheme="http://quanke.name/tags/kotlin/"/>
    
      <category term="spring boot" scheme="http://quanke.name/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 与 kotlin 使用Thymeleaf模板引擎渲染web视图</title>
    <link href="http://quanke.name/posts/15187/"/>
    <id>http://quanke.name/posts/15187/</id>
    <published>2018-02-02T16:01:48.000Z</published>
    <updated>2018-02-02T16:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="https://www.jianshu.com/p/56f81ab8ee45" target="_blank" rel="external">《使用Spring Boot和Kotlin创建RESTfull API》</a>一文中，我们完成了一个简单的RESTful 服务，体验了Spring Boot 与 kotlin结合的神力，但是往往我们也需要web的支持，那么本篇就在上一个文章的基础上介绍Spring Boot 与 kotlin 使用Thymeleaf模板引擎渲染web视图。</p></blockquote><h2 id="静态资源访问"><a href="#静态资源访问" class="headerlink" title="静态资源访问"></a>静态资源访问</h2><p>在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源，使用Spring Boot 与 kotlin如何去支持这些静态资源？，很简单。</p><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><p>Spring Boot默认提供静态资源目录位置需置于<code>classpath</code>下，目录名需符合如下规则：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/static</div><div class="line">/public</div><div class="line">/resources</div><div class="line">/META-INF/resources</div></pre></td></tr></table></figure><blockquote><p>举例：我们可以在src/main/resources/目录下创建static，在该位置放置一个图片文件。启动程序后，尝试访问<a href="http://localhost:8080/ruby.jpg。如能显示图片，配置成功。" target="_blank" rel="external">http://localhost:8080/ruby.jpg。如能显示图片，配置成功。</a></p></blockquote><h2 id="渲染Web页面"><a href="#渲染Web页面" class="headerlink" title="渲染Web页面"></a>渲染Web页面</h2><p>之前通过<code>@RestController</code>处理请求，返回的内容为json对象。如果需要渲染<code>html</code>页面，要如何实现呢？</p><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>在<code>Spring Boot</code>推荐的模板引擎下，我们可以很快的上手开发动态网站。</p><p><code>Spring Boot</code>提供了默认配置的模板引擎主要有以下几种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Thymeleaf</div><div class="line">FreeMarker</div><div class="line">Groovy</div><div class="line">Mustache</div></pre></td></tr></table></figure><p>Spring Boot建议使用这些模板引擎，避免使用JSP，若一定要使用JSP将无法实现Spring Boot的多种特性，具体可见后文：支持JSP的配置</p><p>当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：<code>src/main/resources/templates</code>。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。</p><h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p><code>Thymeleaf</code>是一个<code>XML/XHTML/HTML5</code>模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。</p><p>Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。</p><h3 id="示例模板："><a href="#示例模板：" class="headerlink" title="示例模板："></a>示例模板：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</div><div class="line">&lt;head lang=&quot;en&quot;&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</div><div class="line">    &lt;title&gt;quanke.name&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h1 th:text=&quot;$&#123;host&#125;&quot;&gt;Hello World&lt;/h1&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>可以看到Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。</p><p>在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">compile &quot;org.springframework.boot:spring-boot-starter-thymeleaf:$spring_boot_version&quot;</div></pre></td></tr></table></figure><p>在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">import org.springframework.stereotype.Controller</div><div class="line">import org.springframework.ui.ModelMap</div><div class="line">import org.springframework.web.bind.annotation.RequestMapping</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by http://quanke.name on 2018/1/10.</div><div class="line"> */</div><div class="line">@Controller</div><div class="line">class HelloController &#123;</div><div class="line"></div><div class="line">    @RequestMapping(&quot;/&quot;)</div><div class="line">    fun index(map: ModelMap): String &#123;</div><div class="line">//        / 加入一个属性，用来在模板中读取</div><div class="line">        map.addAttribute(&quot;host&quot;, &quot;http://quanke.name&quot;)</div><div class="line">        // return模板文件的名称，对应src/main/resources/templates/index.html</div><div class="line">        return &quot;index&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>默认在 <code>src/main/resources/templates</code>目录下增加<code>index.html</code>文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</div><div class="line">&lt;head lang=&quot;en&quot;&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</div><div class="line">    &lt;title&gt;quanke.name&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h1 th:text=&quot;$&#123;host&#125;&quot;&gt;Hello World&lt;/h1&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>增加使用 <code>kotlin</code>语言实现的 <code>Spring Boot</code>启动方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.springframework.boot.SpringApplication</div><div class="line">import org.springframework.boot.autoconfigure.SpringBootApplication</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by http://quanke.name on 2018/1/9.</div><div class="line"> */</div><div class="line"></div><div class="line">@SpringBootApplication</div><div class="line">class Application</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    SpringApplication.run(Application::class.java, *args)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上页面，直接打开html页面展现Hello World，但是启动程序后，访问<a href="http://localhost:8080/，则是展示Controller中host的值：http://quanke.name，做到了不破坏HTML自身内容的数据逻辑分离。" target="_blank" rel="external">http://localhost:8080/，则是展示Controller中host的值：http://quanke.name，做到了不破坏HTML自身内容的数据逻辑分离。</a></p><p>更多<code>Thymeleaf</code>的页面语法，还请访问<a href="http://www.thymeleaf.org/documentation.html" target="_blank" rel="external">Thymeleaf的官方文档</a>查询使用。</p><p>Thymeleaf的默认参数配置</p><p>如有需要修改默认配置的时候，只需复制下面要修改的属性到<code>application.yml</code>中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Enable template caching.</div><div class="line">spring.thymeleaf.cache=true </div><div class="line"># Check that the templates location exists.</div><div class="line">spring.thymeleaf.check-template-location=true </div><div class="line"># Content-Type value.</div><div class="line">spring.thymeleaf.content-type=text/html </div><div class="line"># Enable MVC Thymeleaf view resolution.</div><div class="line">spring.thymeleaf.enabled=true </div><div class="line"># Template encoding.</div><div class="line">spring.thymeleaf.encoding=UTF-8 </div><div class="line"># Comma-separated list of view names that should be excluded from resolution.</div><div class="line">spring.thymeleaf.excluded-view-names= </div><div class="line"># Template mode to be applied to templates. See also StandardTemplateModeHandlers.</div><div class="line">spring.thymeleaf.mode=HTML5 </div><div class="line"># Prefix that gets prepended to view names when building a URL.</div><div class="line">spring.thymeleaf.prefix=classpath:/templates/ </div><div class="line"># Suffix that gets appended to view names when building a URL.</div><div class="line">spring.thymeleaf.suffix=.html  spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.</div></pre></td></tr></table></figure><blockquote><p>测试环境或者开发环境避免出现不可预期问题一般设置：<code>spring.thymeleaf.cache=true</code></p></blockquote><h2 id="支持JSP的配置"><a href="#支持JSP的配置" class="headerlink" title="支持JSP的配置"></a>支持JSP的配置</h2><p>Spring Boot并不建议使用，但如果一定要使用，可以参考此工程作为脚手架：<a href="https://github.com/spring-projects/spring-boot/tree/v1.3.2.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp" target="_blank" rel="external">JSP</a>支持</p><p>总的来说Kotlin 对于Spring Boot的支持非常好，只需要把Java语言的spring boot使用，翻译成kotlin就可以。</p><p>欢迎关注：</p><p><a href="http://quanke.name/spring-boot-with-kotlin-in-action">《Spring Boot in kotlin 实战》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.jianshu.com/p/56f81ab8ee45&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《使用Spring Boot和Kotlin创建RESTfull API》&lt;/a&gt;一文中
      
    
    </summary>
    
      <category term="Spring Boot与kotlin实战" scheme="http://quanke.name/categories/Spring-Boot%E4%B8%8Ekotlin%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="kotlin" scheme="http://quanke.name/tags/kotlin/"/>
    
      <category term="spring boot" scheme="http://quanke.name/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>使用Spring Boot和Kotlin创建RESTfull API</title>
    <link href="http://quanke.name/posts/55365/"/>
    <id>http://quanke.name/posts/55365/</id>
    <published>2018-02-02T16:00:25.000Z</published>
    <updated>2018-02-02T16:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>Kotlin</code> 结合<code>SpringBoot</code> 开发一个<code>RESTFul</code>版本的 <code>Hello World</code>。</p><p>如果单单Kotlin 我是不相信在短时间内有产生多大的风波，但是如果Kotlin​ 能和 Java 开发神器  SpringBoot 结合起来，我感觉能飞。。。</p><h4 id="1-首先新建Gradle的Kotlin工程"><a href="#1-首先新建Gradle的Kotlin工程" class="headerlink" title="1.首先新建Gradle的Kotlin工程"></a>1.首先新建<code>Gradle</code>的<code>Kotlin</code>工程</h4><p>打开IDEA ，File-&gt;New-&gt;Project</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-cc8db2c5f2828026?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="New-&gt;Project "></p><p>输入相关信息之后下一步：</p><p>一般<code>GroupId</code>为公司域名反着写，加上项目名字</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-b622a516a2536b20?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>建议选中 <code>Use auto-import</code>，自动导包 ,使用本地 <code>Gradle</code>，但是需要先安装Gradle（<a href="https://gradle.org/install/" target="_blank" rel="external">https://gradle.org/install/</a>）</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-0864d5a15edb38e4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Use auto-import"></p><p>如果没有选择 使用本地 Gradle 项目创建完成之后Gradle的包需要下载，这个时间有点长，以前做Android就深受其苦，所有要做好心理准备，除非你有一个好用的FQ工具。</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-091572e29e61e6e9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gradle 库下载中"></p><p>项目创建完成之后会生成一个<code>Gradle</code>文件<code>build.gradle</code>和<code>settings.gradle</code>,<code>settings.gradle</code>文件我们暂且不管，先看看<code>build.gradle</code>文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">group &apos;name.quanke.kotlin.restful&apos;</div><div class="line"></div><div class="line">version &apos;1.0-SNAPSHOT&apos;</div><div class="line"></div><div class="line">buildscript &#123;</div><div class="line"></div><div class="line">ext.kotlin_version = &apos;1.2.10&apos;</div><div class="line"></div><div class="line">repositories &#123;</div><div class="line"></div><div class="line">mavenCentral()</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line"></div><div class="line">classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">apply plugin: &apos;kotlin&apos;</div><div class="line"></div><div class="line">repositories &#123;</div><div class="line"></div><div class="line">mavenCentral()</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line"></div><div class="line">compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">compileKotlin &#123;</div><div class="line"></div><div class="line">kotlinOptions.jvmTarget = &quot;1.8&quot;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">compileTestKotlin &#123;</div><div class="line"></div><div class="line">kotlinOptions.jvmTarget = &quot;1.8&quot;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/432952-4d6051227095b1a9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载Gradle 依赖"></p><blockquote><p>下载依赖和插件也是一个漫长痛苦的过程。各位不要心急，慢慢来，一次不行多试几次。</p></blockquote><p>从生成的配置文件看，<code>IDEA</code>已经自动把<code>Gradle</code>构建<code>Kotlin</code>工程插件<code>kotlin-gradle-plugin</code>，以及<code>Kotlin</code></p><p>标准库<code>kotlin-stdlib</code>添加到<code>build.gradle</code>文件中了。</p><h4 id="2-配置build-gradle文件"><a href="#2-配置build-gradle文件" class="headerlink" title="2.配置build.gradle文件"></a>2.配置<code>build.gradle</code>文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">group &apos;name.quanke.kotlin.rest&apos;</div><div class="line"></div><div class="line">version &apos;1.0-SNAPSHOT&apos;</div><div class="line"></div><div class="line">buildscript &#123;</div><div class="line"></div><div class="line">ext.kotlin_version = &apos;1.2.10&apos;</div><div class="line"></div><div class="line">ext.spring_boot_version = &apos;1.5.4.RELEASE&apos;</div><div class="line"></div><div class="line">repositories &#123;</div><div class="line"></div><div class="line">mavenCentral()</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line"></div><div class="line">classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</div><div class="line"></div><div class="line">classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-plugin</div><div class="line"></div><div class="line">// org.jetbrains.kotlin:kotlin-allopen 是全开放编译器插件。我们使用Kotlin 调用Java的Spring AOP框架和库，需要类为 open（可被继承实现），而Kotlin 类和函数都是默认 final 的，这样我们需要为每个类和函数前面加上open修饰符。</div><div class="line"></div><div class="line">// 这样的代码写起来，可费事了。还好，我们有all-open 编译器插件。它会适配 Kotlin 以满足这些框架的需求，并使用指定的注解标注类而其成员无需显式使用 open 关键字打开。 例如，当我们使用 Spring 时，就不需要打开所有的类，跟我们在Java中写代码一样，只需要用相应的注解标注即可。</div><div class="line"></div><div class="line">classpath &quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">apply plugin: &apos;kotlin&apos;</div><div class="line"></div><div class="line">apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-plugin</div><div class="line"></div><div class="line">apply plugin: &apos;org.springframework.boot&apos;</div><div class="line"></div><div class="line">jar &#123;</div><div class="line"></div><div class="line">baseName = &apos;0_2RestfulApi-service&apos;</div><div class="line"></div><div class="line">version = &apos;0.1.0&apos;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">repositories &#123;</div><div class="line"></div><div class="line">mavenCentral()</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line"></div><div class="line">compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot;</div><div class="line"></div><div class="line">compile &apos;org.springframework.boot:spring-boot-starter-web&apos;</div><div class="line"></div><div class="line">testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;)</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">compileKotlin &#123;</div><div class="line"></div><div class="line">kotlinOptions.jvmTarget = &quot;1.8&quot;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">compileTestKotlin &#123;</div><div class="line"></div><div class="line">kotlinOptions.jvmTarget = &quot;1.8&quot;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-创建包"><a href="#3-创建包" class="headerlink" title="3.创建包"></a>3.创建包</h4><p>在kotlin目录下面创建：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">name.quanke.kotlin.rest</div></pre></td></tr></table></figure></p><p>注意：不能直接在kotlin目录下面写Application 类，不然会报错<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package</div></pre></td></tr></table></figure></p><p>3.创建数据模型Greeting类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.kotlin.rest</div><div class="line"></div><div class="line">/**</div><div class="line"></div><div class="line">* Created by http://quanke.name on 2018/1/9.</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line">data class Greeting(val id: Long, val content: String)</div></pre></td></tr></table></figure></p><blockquote><p>如果是Java写的话，想象一下这需要多少行代码，看看kotlin，不明则厉。。。</p></blockquote><h4 id="5-创建GreetingController"><a href="#5-创建GreetingController" class="headerlink" title="5.创建GreetingController"></a>5.创建GreetingController</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.kotlin.rest</div><div class="line"></div><div class="line">import org.springframework.web.bind.annotation.GetMapping</div><div class="line"></div><div class="line">import org.springframework.web.bind.annotation.RequestParam</div><div class="line"></div><div class="line">import org.springframework.web.bind.annotation.RestController</div><div class="line"></div><div class="line">import java.util.concurrent.atomic.AtomicLong</div><div class="line"></div><div class="line">/**</div><div class="line"></div><div class="line">* Created by http://quanke.name on 2018/1/9.</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line">@RestController</div><div class="line"></div><div class="line">class GreetingController &#123;</div><div class="line"></div><div class="line">val counter = AtomicLong()</div><div class="line"></div><div class="line">@GetMapping(&quot;/greeting&quot;)</div><div class="line"></div><div class="line">fun greeting(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;) name: String) =</div><div class="line"></div><div class="line">Greeting(counter.incrementAndGet(), &quot;Hello, $name&quot;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="6-创建Application"><a href="#6-创建Application" class="headerlink" title="6.创建Application"></a>6.创建<code>Application</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.kotlin.rest</div><div class="line"></div><div class="line">import org.springframework.boot.SpringApplication</div><div class="line"></div><div class="line">import org.springframework.boot.autoconfigure.SpringBootApplication</div><div class="line"></div><div class="line">/**</div><div class="line"></div><div class="line">* Created by http://quanke.name on 2018/1/9.</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line">@SpringBootApplication</div><div class="line"></div><div class="line">class Application</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line"></div><div class="line">SpringApplication.run(Application::class.java, *args)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>点击Gradle的bootRun：</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-056fdad69b06e79c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bootRun"></p><p>或者点击</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-a0534039b6e2e494?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Run"></p><p><img src="http://upload-images.jianshu.io/upload_images/432952-ba09f7c75789f836?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行成功的样子"></p><p>如果没有毛病，访问</p><p><a href="http://127.0.0.1:8080/greeting?name=quanke.name" target="_blank" rel="external">http://127.0.0.1:8080/greeting?name=quanke.name</a></p><p>输出：</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-cddd8ac0605ea11b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>那么恭喜你，一个kotlin 和spring boot的web服务就这么搞定了。。。</p><p>服务默认是8080端口，如果8080端口刚好被占用了，那在resources目录下新建一个application.yml文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">  port: 1234</div></pre></td></tr></table></figure><p>把端口改成你想要的。</p><p>当然这只是开始的演示，么有什么卵用。。。之后可以用于生产的demo，呼之欲出。</p><p>欢迎关注：</p><p><a href="http://quanke.name/spring-boot-with-kotlin-in-action">《Spring Boot in kotlin 实战》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;code&gt;Kotlin&lt;/code&gt; 结合&lt;code&gt;SpringBoot&lt;/code&gt; 开发一个&lt;code&gt;RESTFul&lt;/code&gt;版本的 &lt;code&gt;Hello World&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果单单Kotlin 我是不相信在短时间内有产生多大的风
      
    
    </summary>
    
      <category term="Spring Boot与kotlin实战" scheme="http://quanke.name/categories/Spring-Boot%E4%B8%8Ekotlin%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="kotlin" scheme="http://quanke.name/tags/kotlin/"/>
    
      <category term="spring boot" scheme="http://quanke.name/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>我的第一个Kotlin应用</title>
    <link href="http://quanke.name/posts/41862/"/>
    <id>http://quanke.name/posts/41862/</id>
    <published>2018-02-02T14:38:51.000Z</published>
    <updated>2018-02-02T16:03:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始正式学习Kotlin这门语言，学习之前看了很多关于Kotlin的推广文，本来一门新的语言很难普及，有Google站台，心里有底了很多，本人做过Android开发，所以对于Android相关的东西还是比较关注的。</p><p>废话说了这么多，现在正式开始我的第一个Kotlin应用，当然从打印<code>Hello World</code>开始。</p><p><code>Kotlin</code>有多种方式打印<code>Hello World</code>，比如通过命令行、通过应用等。按道理通过命令行打印“Hello World”比较简单，但是我今天不去讲命令行的实现方式，因为在之后的学习中用的很少、而且命令行的形式比较简单。所有我们主要是通过应用的方式去学习。有一些教程使用 <code>gradle</code>去创建项目，我觉得第一个<code>Kotlin</code>应用太麻烦了，怕不懂，所以我今天实现一个极其简单的Kotlin应用。</p><p>我这里用的IDE是<code>Intelli IDEA</code>，亲儿子当然要用，不解释，如果亲一定要用其他的，不好意思，我这里不提供方法，因为我也不会。</p><p>首先安装最新版本的Intelli IDEA，<code>File-&gt;New-&gt;Project</code></p><p><img src="http://upload-images.jianshu.io/upload_images/432952-00d05466821aa9c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建Kotlin项目"></p><p>选择 Kotlin -&gt; Kotlin/JVM</p><p>新建完项目之后，新建<code>HelloWorld.kt</code>类：</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-30f6e3f0910213b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建HelloWorld.kt类"></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.kotlin.helloworld</div><div class="line"></div><div class="line">class HelloWorld &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"></div><div class="line">* Created by quanke.name on 2018/1/8.</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line"></div><div class="line">println(&quot;Hello World!&quot;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行后输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure></p><p>到此为止我的第一个Kotlin应用结束了！</p><p>这是<a href="http://quanke.name/spring-boot-with-kotlin-in-action">《Spring Boot in kotlin 实战》</a>的开始篇，欢迎关注！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始正式学习Kotlin这门语言，学习之前看了很多关于Kotlin的推广文，本来一门新的语言很难普及，有Google站台，心里有底了很多，本人做过Android开发，所以对于Android相关的东西还是比较关注的。&lt;/p&gt;
&lt;p&gt;废话说了这么多，现在正式开始我的第一个K
      
    
    </summary>
    
      <category term="Spring Boot与kotlin实战" scheme="http://quanke.name/categories/Spring-Boot%E4%B8%8Ekotlin%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="kotlin" scheme="http://quanke.name/tags/kotlin/"/>
    
      <category term="spring boot" scheme="http://quanke.name/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Java API 搜索之Scrolls(四)</title>
    <link href="http://quanke.name/posts/3267/"/>
    <id>http://quanke.name/posts/3267/</id>
    <published>2017-12-06T14:47:00.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Using-scrolls-in-Java"><a href="#Using-scrolls-in-Java" class="headerlink" title="Using scrolls in Java"></a>Using scrolls in Java</h3><p>首先需要阅读 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-request-scroll.html" target="_blank" rel="external">scroll documentation</a></p><blockquote><p>一般搜索请求都是返回一”页”数据，无论数据量多大都一起返回给用户，Scroll API可以允许我们检索大量数据（甚至全部数据）。Scroll API允许我们做一个初始阶段搜索并且持续批量从Elasticsearch里拉取结果直到没有结果剩下。这有点像传统数据库里的cursors（游标）。<br>Scroll API的创建并不是为了实时的用户响应，而是为了处理大量的数据（Scrolling is not intended for real time user requests, but rather for processing large amounts of data）。从 scroll 请求返回的结果只是反映了 search 发生那一时刻的索引状态，就像一个快照(The results that are returned from a scroll request reflect the state of the index at the time that the initial search request was made, like a snapshot in time)。后续的对文档的改动（索引、更新或者删除）都只会影响后面的搜索请求。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import static org.elasticsearch.index.query.QueryBuilders.*;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">QueryBuilder qb = termQuery(&quot;multi&quot;, &quot;test&quot;);</div><div class="line"></div><div class="line">SearchResponse scrollResp = client.prepareSearch(test)</div><div class="line">        .addSort(FieldSortBuilder.DOC_FIELD_NAME, SortOrder.ASC)</div><div class="line">        .setScroll(new TimeValue(60000)) //为了使用 scroll，初始搜索请求应该在查询中指定 scroll 参数，告诉 Elasticsearch 需要保持搜索的上下文环境多长时间（滚动时间）</div><div class="line">        .setQuery(qb)</div><div class="line">        .setSize(100).get(); //max of 100 hits will be returned for each scroll</div><div class="line">//Scroll until no hits are returned</div><div class="line">do &#123;</div><div class="line">    for (SearchHit hit : scrollResp.getHits().getHits()) &#123;</div><div class="line">        //Handle the hit...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    scrollResp = client.prepareSearchScroll(scrollResp.getScrollId()).setScroll(new TimeValue(60000)).execute().actionGet();</div><div class="line">&#125; while(scrollResp.getHits().getHits().length != 0); // Zero hits mark the end of the scroll and the while loop.</div></pre></td></tr></table></figure><blockquote><p>如果超过滚动时间，继续使用该滚动ID搜索数据，则会报错：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Caused by: SearchContextMissingException[No search context found for id [2861]]</div><div class="line">at org.elasticsearch.search.SearchService.findContext(SearchService.java:613)</div><div class="line">at org.elasticsearch.search.SearchService.executeQueryPhase(SearchService.java:403)</div><div class="line">at org.elasticsearch.search.action.SearchServiceTransportAction$SearchQueryScrollTransportHandler.messageReceived(SearchServiceTransportAction.java:384)</div><div class="line">at org.elasticsearch.search.action.SearchServiceTransportAction$SearchQueryScrollTransportHandler.messageReceived(SearchServiceTransportAction.java:381)</div><div class="line">at org.elasticsearch.transport.TransportRequestHandler.messageReceived(TransportRequestHandler.java:33)</div><div class="line">at org.elasticsearch.transport.RequestHandlerRegistry.processMessageReceived(RequestHandlerRegistry.java:75)</div><div class="line">at org.elasticsearch.transport.TransportService$4.doRun(TransportService.java:376)</div><div class="line">at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37)</div><div class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</div><div class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</div><div class="line">at java.lang.Thread.run(Thread.java:745)</div></pre></td></tr></table></figure><blockquote><p>虽然当滚动有效时间已过，搜索上下文(Search Context)会自动被清除，但是一值保持滚动代价也是很大的，所以当我们不在使用滚动时要尽快使用Clear-Scroll API进行清除。</p></blockquote><h2 id="清除Scroll"><a href="#清除Scroll" class="headerlink" title="清除Scroll"></a>清除Scroll</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">   * 清除滚动ID</div><div class="line">   * @param client</div><div class="line">   * @param scrollIdList</div><div class="line">   * @return</div><div class="line">   */</div><div class="line">  public static boolean clearScroll(Client client, List&lt;String&gt; scrollIdList)&#123;</div><div class="line">      ClearScrollRequestBuilder clearScrollRequestBuilder = client.prepareClearScroll();</div><div class="line">      clearScrollRequestBuilder.setScrollIds(scrollIdList);</div><div class="line">      ClearScrollResponse response = clearScrollRequestBuilder.get();</div><div class="line">      return response.isSucceeded();</div><div class="line">  &#125;</div><div class="line">  /**</div><div class="line">   * 清除滚动ID</div><div class="line">   * @param client</div><div class="line">   * @param scrollId</div><div class="line">   * @return</div><div class="line">   */</div><div class="line">  public static boolean clearScroll(Client client, String scrollId)&#123;</div><div class="line">      ClearScrollRequestBuilder clearScrollRequestBuilder = client.prepareClearScroll();</div><div class="line">      clearScrollRequestBuilder.addScrollId(scrollId);</div><div class="line">      ClearScrollResponse response = clearScrollRequestBuilder.get();</div><div class="line">      return response.isSucceeded();</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">public class ScrollsAPI extends ElasticsearchClientBase &#123;</div><div class="line"></div><div class="line">    private String scrollId;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testScrolls() throws Exception &#123;</div><div class="line"></div><div class="line">        SearchResponse scrollResp = client.prepareSearch(&quot;twitter&quot;)</div><div class="line">                .addSort(FieldSortBuilder.DOC_FIELD_NAME, SortOrder.ASC)</div><div class="line">                .setScroll(new TimeValue(60000)) //为了使用 scroll，初始搜索请求应该在查询中指定 scroll 参数，告诉 Elasticsearch 需要保持搜索的上下文环境多长时间（滚动时间）</div><div class="line">                .setQuery(QueryBuilders.termQuery(&quot;user&quot;, &quot;kimchy&quot;))                 // Query 查询条件</div><div class="line">                .setSize(5).get(); //max of 100 hits will be returned for each scroll</div><div class="line">        //Scroll until no hits are returned</div><div class="line"></div><div class="line">        scrollId = scrollResp.getScrollId();</div><div class="line">        do &#123;</div><div class="line">            for (SearchHit hit : scrollResp.getHits().getHits()) &#123;</div><div class="line">                //Handle the hit...</div><div class="line"></div><div class="line">                System.out.println(&quot;&quot; + hit.getSource().toString());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            scrollResp = client.prepareSearchScroll(scrollId).setScroll(new TimeValue(60000)).execute().actionGet();</div><div class="line">        &#125;</div><div class="line">        while (scrollResp.getHits().getHits().length != 0); // Zero hits mark the end of the scroll and the while loop.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        ClearScrollRequestBuilder clearScrollRequestBuilder = client.prepareClearScroll();</div><div class="line">        clearScrollRequestBuilder.addScrollId(scrollId);</div><div class="line">        ClearScrollResponse response = clearScrollRequestBuilder.get();</div><div class="line"></div><div class="line">        if (response.isSucceeded()) &#123;</div><div class="line">            System.out.println(&quot;成功清除&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        super.tearDown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><a href="https://gitee.com/quanke/elasticsearch-java-study/blob/master/src/test/java/name/quanke/es/study/search/ScrollsAPI.java" target="_blank" rel="external">ScrollsAPI.java</a></p></li><li><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">本手册完整实例</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Using-scrolls-in-Java&quot;&gt;&lt;a href=&quot;#Using-scrolls-in-Java&quot; class=&quot;headerlink&quot; title=&quot;Using scrolls in Java&quot;&gt;&lt;/a&gt;Using scrolls in Java&lt;/
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Java API 搜索之简介（三）</title>
    <link href="http://quanke.name/posts/44811/"/>
    <id>http://quanke.name/posts/44811/</id>
    <published>2017-12-06T14:25:00.000Z</published>
    <updated>2018-02-02T15:26:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch-Java-API-搜索之简介"><a href="#Elasticsearch-Java-API-搜索之简介" class="headerlink" title="Elasticsearch Java API 搜索之简介"></a>Elasticsearch Java API 搜索之简介</h1><p>搜索查询，返回查询匹配的结果，搜索一个index / type 或者多个index / type，可以使用 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/java-query-dsl.html" target="_blank" rel="external">query Java API</a> 作为查询条件，下面是例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.elasticsearch.action.search.SearchResponse;</div><div class="line">import org.elasticsearch.action.search.SearchType;</div><div class="line">import org.elasticsearch.index.query.QueryBuilders.*;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SearchResponse response = client.prepareSearch(&quot;index1&quot;, &quot;index2&quot;)</div><div class="line">        .setTypes(&quot;type1&quot;, &quot;type2&quot;)</div><div class="line">        .setSearchType(SearchType.DFS_QUERY_THEN_FETCH)</div><div class="line">        .setQuery(QueryBuilders.termQuery(&quot;multi&quot;, &quot;test&quot;))                 // Query 查询条件</div><div class="line">        .setPostFilter(QueryBuilders.rangeQuery(&quot;age&quot;).from(12).to(18))     // Filter 过滤</div><div class="line">        .setFrom(0).setSize(60).setExplain(true)</div><div class="line">        .get();</div></pre></td></tr></table></figure><p>所有的参数都是可选的，下面是最简单的调用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// MatchAll on the whole cluster with all default options</div><div class="line">SearchResponse response = client.prepareSearch().get();</div></pre></td></tr></table></figure><blockquote><p>尽管Java API默认提供<code>QUERY_AND_FETCH</code> 和 <code>DFS_QUERY_AND_FETCH</code> 两种 search types ，但是这种模式应该由系统选择，用户不要手动指定</p></blockquote><p>更多请移步 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search.html" target="_blank" rel="external">REST search</a> 文档</p><blockquote><p>如何有任何问题请关注微信公众号给我留言</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Elasticsearch-Java-API-搜索之简介&quot;&gt;&lt;a href=&quot;#Elasticsearch-Java-API-搜索之简介&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch Java API 搜索之简介&quot;&gt;&lt;/a&gt;El
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>多种方式解决spring boot swagger ui使用 nginx 部署后无法使用问题</title>
    <link href="http://quanke.name/posts/21506/"/>
    <id>http://quanke.name/posts/21506/</id>
    <published>2017-12-05T14:19:00.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p><code>spring boot</code> 使用 <code>swagger ui</code> 做接口文档，很是方便</p><p>本地测试都没有问题</p><p>将一个<code>Spring boot</code>工程部署到生产环境， 配置<code>nginx</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  quanke.name;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://127.0.0.1:3101;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>浏览器中访问： quanke.name, 选中某一接口点击try it out,显示:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">No Content。</div></pre></td></tr></table></figure><p>Request  URL:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://127.0.0.1:3101/test</div></pre></td></tr></table></figure></p><p>而不是</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://quanke.name/test</div></pre></td></tr></table></figure><p>通过朋友+搜索知道有两种方法解决此问题：</p><h3 id="第一种：修改nginx配置文件"><a href="#第一种：修改nginx配置文件" class="headerlink" title="第一种：修改nginx配置文件"></a>第一种：修改nginx配置文件</h3><p>把<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  quanke.name;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://127.0.0.1:3101;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>修改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  quanke.name;</div><div class="line">    </div><div class="line">    location / &#123;</div><div class="line">        proxy_pass http://127.0.0.1:3101;</div><div class="line">        proxy_set_header Host $host; # 指定host</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="第二种：启动工程时显式添加属性"><a href="#第二种：启动工程时显式添加属性" class="headerlink" title="第二种：启动工程时显式添加属性"></a>第二种：启动工程时显式添加属性</h3><p>Java 启动的时候指定<code>swagger.v2.host</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-Dspringfox.documentation.swagger.v2.host=quanke.name</div></pre></td></tr></table></figure><p>启动命令实例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java -jar -Dspringfox.documentation.swagger.v2.host=quanke.name /data/app/quanke/api.jar</div></pre></td></tr></table></figure><p>或者在配置文件（application.properties）中进行配置</p><blockquote><p>如何有任何问题请关注微信公众号给我留言</p></blockquote><p><img src="https://static.oschina.net/uploads/img/201711/08183543_ysUa.jpg" alt="全科的公众号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;spring boot&lt;/code&gt; 使用 &lt;code&gt;swagg
      
    
    </summary>
    
      <category term="服务端开发" scheme="http://quanke.name/categories/service/"/>
    
    
      <category term="java" scheme="http://quanke.name/tags/java/"/>
    
      <category term="spirng boot" scheme="http://quanke.name/tags/spirng-boot/"/>
    
      <category term="nginx" scheme="http://quanke.name/tags/nginx/"/>
    
      <category term="swagger ui" scheme="http://quanke.name/tags/swagger-ui/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Java API 索引的增删改查（二）</title>
    <link href="http://quanke.name/posts/51297/"/>
    <id>http://quanke.name/posts/51297/</id>
    <published>2017-11-15T12:10:00.000Z</published>
    <updated>2018-02-02T15:26:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节介绍以下 CRUD API：</p><p> 单文档  APIs</p><ul><li><a href="document-apis/index-api.md">Index API</a></li><li><a href="document-apis/get-api.md">Get API</a></li><li><a href="document-apis/delete-api.md">Delete API</a></li><li><a href="document-apis/delete-by-query-api.md">Delete By Query API</a></li><li><a href="document-apis/update-api.md">Update API</a></li></ul><p>多文档 APIs</p><ul><li><a href="document-apis/multi-get-api.md">Multi Get API</a></li><li><a href="document-apis/bulk-api.md">Bulk API</a></li><li><a href="document-apis/using-bulk-processor.md">Using Bulk Processor</a></li></ul><p>Multi Get API<br>Bulk API</p><blockquote><p>注意:所有的单文档的CRUD API，index参数只能接受单一的索引库名称，或者是一个指向单一索引库的alias。</p></blockquote><h3 id="Index-API"><a href="#Index-API" class="headerlink" title="Index API"></a>Index API</h3><p>Index API 允许我们存储一个JSON格式的文档，使数据可以被搜索。文档通过index、type、id唯一确定。我们可以自己提供一个id，或者也使用Index API 为我们自动生成一个。</p><p>这里有几种不同的方式来产生JSON格式的文档(document)：</p><ul><li>手动方式，使用原生的byte[]或者String</li><li>使用Map方式，会自动转换成与之等价的JSON</li><li>使用第三方库来序列化beans，如Jackson</li><li>使用内置的帮助类 XContentFactory.jsonBuilder()</li></ul><h4 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/mapping-date-format.html" target="_blank" rel="external">数据格式</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">String json = &quot;&#123;&quot; +</div><div class="line">        &quot;\&quot;user\&quot;:\&quot;kimchy\&quot;,&quot; +</div><div class="line">        &quot;\&quot;postDate\&quot;:\&quot;2013-01-30\&quot;,&quot; +</div><div class="line">        &quot;\&quot;message\&quot;:\&quot;trying out Elasticsearch\&quot;&quot; +</div><div class="line">    &quot;&#125;&quot;;</div></pre></td></tr></table></figure></p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**  </div><div class="line"> * 手动生成JSON  </div><div class="line"> */  </div><div class="line">@Test  </div><div class="line">public void CreateJSON()&#123;  </div><div class="line">      </div><div class="line">    String json = &quot;&#123;&quot; +  </div><div class="line">            &quot;\&quot;user\&quot;:\&quot;fendo\&quot;,&quot; +  </div><div class="line">            &quot;\&quot;postDate\&quot;:\&quot;2013-01-30\&quot;,&quot; +  </div><div class="line">            &quot;\&quot;message\&quot;:\&quot;Hell word\&quot;&quot; +  </div><div class="line">        &quot;&#125;&quot;;  </div><div class="line">      </div><div class="line">    IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">            .setSource(json)  </div><div class="line">            .get();  </div><div class="line">    System.out.println(response.getResult());  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Map方式"><a href="#Map方式" class="headerlink" title="Map方式"></a>Map方式</h4><p>Map是key:value数据类型，可以代表json结构.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;();</div><div class="line">json.put(&quot;user&quot;,&quot;kimchy&quot;);</div><div class="line">json.put(&quot;postDate&quot;,new Date());</div><div class="line">json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;);</div></pre></td></tr></table></figure><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> /**  </div><div class="line"> * 使用集合  </div><div class="line"> */  </div><div class="line">@Test  </div><div class="line">public void CreateList()&#123;  </div><div class="line">      </div><div class="line">    Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;();  </div><div class="line">    json.put(&quot;user&quot;,&quot;kimchy&quot;);  </div><div class="line">    json.put(&quot;postDate&quot;,&quot;2013-01-30&quot;);  </div><div class="line">    json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;);  </div><div class="line">      </div><div class="line">    IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">            .setSource(json)  </div><div class="line">            .get();  </div><div class="line">    System.out.println(response.getResult());  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h4><p>ElasticSearch已经使用了jackson，可以直接使用它把javabean转为json.</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.fasterxml.jackson.databind.*;</div><div class="line"></div><div class="line">// instance a json mapper</div><div class="line">ObjectMapper mapper = new ObjectMapper(); // create once, reuse</div><div class="line"></div><div class="line">// generate json</div><div class="line">byte[] json = mapper.writeValueAsBytes(yourbeaninstance);</div></pre></td></tr></table></figure><h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**  </div><div class="line"> * 使用JACKSON序列化  </div><div class="line"> * @throws Exception  </div><div class="line"> */  </div><div class="line">@Test  </div><div class="line">public void CreateJACKSON() throws Exception&#123;  </div><div class="line">      </div><div class="line">    CsdnBlog csdn=new CsdnBlog();  </div><div class="line">    csdn.setAuthor(&quot;fendo&quot;);  </div><div class="line">    csdn.setContent(&quot;这是JAVA书籍&quot;);  </div><div class="line">    csdn.setTag(&quot;C&quot;);  </div><div class="line">    csdn.setView(&quot;100&quot;);  </div><div class="line">    csdn.setTitile(&quot;编程&quot;);  </div><div class="line">    csdn.setDate(new Date().toString());  </div><div class="line">      </div><div class="line">    // instance a json mapper  </div><div class="line">    ObjectMapper mapper = new ObjectMapper(); // create once, reuse  </div><div class="line"></div><div class="line">    // generate json  </div><div class="line">    byte[] json = mapper.writeValueAsBytes(csdn);  </div><div class="line">      </div><div class="line">    IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">            .setSource(json)  </div><div class="line">            .get();  </div><div class="line">    System.out.println(response.getResult());  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="XContentBuilder帮助类方式"><a href="#XContentBuilder帮助类方式" class="headerlink" title="XContentBuilder帮助类方式"></a>XContentBuilder帮助类方式</h4><p>ElasticSearch提供了一个内置的帮助类XContentBuilder来产生JSON文档</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Index name</div><div class="line">String _index = response.getIndex();</div><div class="line">// Type name</div><div class="line">String _type = response.getType();</div><div class="line">// Document ID (generated or not)</div><div class="line">String _id = response.getId();</div><div class="line">// Version (if it&apos;s the first time you index this document, you will get: 1)</div><div class="line">long _version = response.getVersion();</div><div class="line">// status has stored current instance statement.</div><div class="line">RestStatus status = response.status();</div></pre></td></tr></table></figure><h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**  </div><div class="line"> * 使用ElasticSearch 帮助类  </div><div class="line"> * @throws IOException   </div><div class="line"> */  </div><div class="line">@Test  </div><div class="line">public void CreateXContentBuilder() throws IOException&#123;  </div><div class="line">      </div><div class="line">    XContentBuilder builder = XContentFactory.jsonBuilder()  </div><div class="line">            .startObject()  </div><div class="line">                .field(&quot;user&quot;, &quot;ccse&quot;)  </div><div class="line">                .field(&quot;postDate&quot;, new Date())  </div><div class="line">                .field(&quot;message&quot;, &quot;this is Elasticsearch&quot;)  </div><div class="line">            .endObject();  </div><div class="line">      </div><div class="line">    IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodata&quot;).setSource(builder).get();  </div><div class="line">    System.out.println(&quot;创建成功!&quot;);  </div><div class="line">      </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> </div><div class="line">import java.io.IOException;  </div><div class="line">import java.net.InetAddress;  </div><div class="line">import java.net.UnknownHostException;  </div><div class="line">import java.util.Date;  </div><div class="line">import java.util.HashMap;  </div><div class="line">import java.util.Map;  </div><div class="line">  </div><div class="line">import org.elasticsearch.action.index.IndexResponse;  </div><div class="line">import org.elasticsearch.client.transport.TransportClient;  </div><div class="line">import org.elasticsearch.common.settings.Settings;  </div><div class="line">import org.elasticsearch.common.transport.InetSocketTransportAddress;  </div><div class="line">import org.elasticsearch.common.xcontent.XContentBuilder;  </div><div class="line">import org.elasticsearch.common.xcontent.XContentFactory;  </div><div class="line">import org.elasticsearch.transport.client.PreBuiltTransportClient;  </div><div class="line">import org.junit.Before;  </div><div class="line">import org.junit.Test;  </div><div class="line">  </div><div class="line">import com.fasterxml.jackson.core.JsonProcessingException;  </div><div class="line">import com.fasterxml.jackson.databind.ObjectMapper;  </div><div class="line">  </div><div class="line">public class CreateIndex &#123;  </div><div class="line">  </div><div class="line">    private TransportClient client;  </div><div class="line">      </div><div class="line">    @Before  </div><div class="line">    public void getClient() throws Exception&#123;  </div><div class="line">        //设置集群名称  </div><div class="line">        Settings settings = Settings.builder().put(&quot;cluster.name&quot;, &quot;my-application&quot;).build();// 集群名  </div><div class="line">        //创建client  </div><div class="line">        client  = new PreBuiltTransportClient(settings)  </div><div class="line">                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;127.0.0.1&quot;), 9300));  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    /**  </div><div class="line">     * 手动生成JSON  </div><div class="line">     */  </div><div class="line">    @Test  </div><div class="line">    public void CreateJSON()&#123;  </div><div class="line">          </div><div class="line">        String json = &quot;&#123;&quot; +  </div><div class="line">                &quot;\&quot;user\&quot;:\&quot;fendo\&quot;,&quot; +  </div><div class="line">                &quot;\&quot;postDate\&quot;:\&quot;2013-01-30\&quot;,&quot; +  </div><div class="line">                &quot;\&quot;message\&quot;:\&quot;Hell word\&quot;&quot; +  </div><div class="line">            &quot;&#125;&quot;;  </div><div class="line">          </div><div class="line">        IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">                .setSource(json)  </div><div class="line">                .get();  </div><div class="line">        System.out.println(response.getResult());  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">      </div><div class="line">    /**  </div><div class="line">     * 使用集合  </div><div class="line">     */  </div><div class="line">    @Test  </div><div class="line">    public void CreateList()&#123;  </div><div class="line">          </div><div class="line">        Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;();  </div><div class="line">        json.put(&quot;user&quot;,&quot;kimchy&quot;);  </div><div class="line">        json.put(&quot;postDate&quot;,&quot;2013-01-30&quot;);  </div><div class="line">        json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;);  </div><div class="line">          </div><div class="line">        IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">                .setSource(json)  </div><div class="line">                .get();  </div><div class="line">        System.out.println(response.getResult());  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    /**  </div><div class="line">     * 使用JACKSON序列化  </div><div class="line">     * @throws Exception  </div><div class="line">     */  </div><div class="line">    @Test  </div><div class="line">    public void CreateJACKSON() throws Exception&#123;  </div><div class="line">          </div><div class="line">        CsdnBlog csdn=new CsdnBlog();  </div><div class="line">        csdn.setAuthor(&quot;fendo&quot;);  </div><div class="line">        csdn.setContent(&quot;这是JAVA书籍&quot;);  </div><div class="line">        csdn.setTag(&quot;C&quot;);  </div><div class="line">        csdn.setView(&quot;100&quot;);  </div><div class="line">        csdn.setTitile(&quot;编程&quot;);  </div><div class="line">        csdn.setDate(new Date().toString());  </div><div class="line">          </div><div class="line">        // instance a json mapper  </div><div class="line">        ObjectMapper mapper = new ObjectMapper(); // create once, reuse  </div><div class="line">  </div><div class="line">        // generate json  </div><div class="line">        byte[] json = mapper.writeValueAsBytes(csdn);  </div><div class="line">          </div><div class="line">        IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;)  </div><div class="line">                .setSource(json)  </div><div class="line">                .get();  </div><div class="line">        System.out.println(response.getResult());  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    /**  </div><div class="line">     * 使用ElasticSearch 帮助类  </div><div class="line">     * @throws IOException   </div><div class="line">     */  </div><div class="line">    @Test  </div><div class="line">    public void CreateXContentBuilder() throws IOException&#123;  </div><div class="line">          </div><div class="line">        XContentBuilder builder = XContentFactory.jsonBuilder()  </div><div class="line">                .startObject()  </div><div class="line">                    .field(&quot;user&quot;, &quot;ccse&quot;)  </div><div class="line">                    .field(&quot;postDate&quot;, new Date())  </div><div class="line">                    .field(&quot;message&quot;, &quot;this is Elasticsearch&quot;)  </div><div class="line">                .endObject();  </div><div class="line">          </div><div class="line">        IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodata&quot;).setSource(builder).get();  </div><div class="line">        System.out.println(&quot;创建成功!&quot;);  </div><div class="line">          </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>你还可以通过startArray(string)和endArray()方法添加数组。.field()方法可以接受多种对象类型。你可以给它传递数字、日期、甚至其他XContentBuilder对象。</p></blockquote><h3 id="Get-API"><a href="#Get-API" class="headerlink" title="Get API"></a>Get API</h3><p>根据id查看文档：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GetResponse response = client.prepareGet(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;).get();</div></pre></td></tr></table></figure><p>更多请查看 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/docs-get.html" target="_blank" rel="external">rest get API</a> 文档</p><h4 id="配置线程"><a href="#配置线程" class="headerlink" title="配置线程"></a>配置线程</h4><p><code>operationThreaded</code> 设置为 <code>true</code> 是在不同的线程里执行此次操作</p><p>下面的例子是<code>operationThreaded</code> 设置为 <code>false</code> ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GetResponse response = client.prepareGet(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;)</div><div class="line">        .setOperationThreaded(false)</div><div class="line">        .get();</div></pre></td></tr></table></figure></p><h3 id="Delete-API"><a href="#Delete-API" class="headerlink" title="Delete API"></a>Delete API</h3><p>根据ID删除：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DeleteResponse response = client.prepareDelete(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;).get();</div></pre></td></tr></table></figure><p>更多请查看 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/docs-delete.html" target="_blank" rel="external">delete API</a> 文档</p><h4 id="配置线程-1"><a href="#配置线程-1" class="headerlink" title="配置线程"></a>配置线程</h4><p><code>operationThreaded</code> 设置为 <code>true</code> 是在不同的线程里执行此次操作</p><p>下面的例子是<code>operationThreaded</code> 设置为 <code>false</code> ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GetResponse response = client.prepareGet(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;)</div><div class="line">        .setOperationThreaded(false)</div><div class="line">        .get();</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DeleteResponse response = client.prepareDelete(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;)</div><div class="line">        .setOperationThreaded(false)</div><div class="line">        .get();</div></pre></td></tr></table></figure><h3 id="Delete-By-Query-API"><a href="#Delete-By-Query-API" class="headerlink" title="Delete By Query API"></a>Delete By Query API</h3><p>通过查询条件删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BulkByScrollResponse response =</div><div class="line">    DeleteByQueryAction.INSTANCE.newRequestBuilder(client)</div><div class="line">        .filter(QueryBuilders.matchQuery(&quot;gender&quot;, &quot;male&quot;)) //查询条件</div><div class="line">        .source(&quot;persons&quot;) //index(索引名)</div><div class="line">        .get();  //执行</div><div class="line"></div><div class="line">long deleted = response.getDeleted(); //删除文档的数量</div></pre></td></tr></table></figure><p>如果需要执行的时间比较长，可以使用异步的方式处理,结果在回调里面获取</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DeleteByQueryAction.INSTANCE.newRequestBuilder(client)</div><div class="line">    .filter(QueryBuilders.matchQuery(&quot;gender&quot;, &quot;male&quot;))      //查询            </div><div class="line">    .source(&quot;persons&quot;)                //index(索引名)                                    </div><div class="line">    .execute(new ActionListener&lt;BulkByScrollResponse&gt;() &#123;     //回调监听     </div><div class="line">        @Override</div><div class="line">        public void onResponse(BulkByScrollResponse response) &#123;</div><div class="line">            long deleted = response.getDeleted();   //删除文档的数量                 </div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onFailure(Exception e) &#123;</div><div class="line">            // Handle the exception</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><h3 id="Update-API"><a href="#Update-API" class="headerlink" title="Update API"></a>Update API</h3><p>有两种方式更新索引：</p><ul><li>创建 <code>UpdateRequest</code>,通过client发送；</li><li>使用 <code>prepareUpdate()</code> 方法；</li></ul><h4 id="使用UpdateRequest"><a href="#使用UpdateRequest" class="headerlink" title="使用UpdateRequest"></a>使用UpdateRequest</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UpdateRequest updateRequest = new UpdateRequest();</div><div class="line">updateRequest.index(&quot;index&quot;);</div><div class="line">updateRequest.type(&quot;type&quot;);</div><div class="line">updateRequest.id(&quot;1&quot;);</div><div class="line">updateRequest.doc(jsonBuilder()</div><div class="line">        .startObject()</div><div class="line">            .field(&quot;gender&quot;, &quot;male&quot;)</div><div class="line">        .endObject());</div><div class="line">client.update(updateRequest).get();</div></pre></td></tr></table></figure><h4 id="使用-prepareUpdate-方法"><a href="#使用-prepareUpdate-方法" class="headerlink" title="使用 prepareUpdate() 方法"></a>使用 <code>prepareUpdate()</code> 方法</h4><blockquote><p>这里官方的示例有问题，new Script（）参数错误，所以一下代码是我自己写的（2017/11/10）</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">client.prepareUpdate(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;)</div><div class="line">        .setScript(new Script(&quot;ctx._source.gender = \&quot;male\&quot;&quot;  ,ScriptService.ScriptType.INLINE, null, null))//脚本可以是本地文件存储的，如果使用文件存储的脚本，需要设置 ScriptService.ScriptType.FILE </div><div class="line">        .get();</div><div class="line"></div><div class="line">client.prepareUpdate(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;)</div><div class="line">        .setDoc(jsonBuilder()   //合并到现有文档</div><div class="line">            .startObject()</div><div class="line">                .field(&quot;gender&quot;, &quot;male&quot;)</div><div class="line">            .endObject())</div><div class="line">        .get();</div></pre></td></tr></table></figure><h4 id="Update-by-script"><a href="#Update-by-script" class="headerlink" title="Update by script"></a>Update by script</h4><p>使用脚本更新文档 </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UpdateRequest updateRequest = new UpdateRequest(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;)</div><div class="line">        .script(new Script(&quot;ctx._source.gender = \&quot;male\&quot;&quot;));</div><div class="line">client.update(updateRequest).get();</div></pre></td></tr></table></figure><h4 id="Update-by-merging-documents"><a href="#Update-by-merging-documents" class="headerlink" title="Update by merging documents"></a>Update by merging documents</h4><p>合并文档</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UpdateRequest updateRequest = new UpdateRequest(&quot;index&quot;, &quot;type&quot;, &quot;1&quot;)</div><div class="line">        .doc(jsonBuilder()</div><div class="line">            .startObject()</div><div class="line">                .field(&quot;gender&quot;, &quot;male&quot;)</div><div class="line">            .endObject());</div><div class="line">client.update(updateRequest).get();</div></pre></td></tr></table></figure><h4 id="Upsert"><a href="#Upsert" class="headerlink" title="Upsert"></a>Upsert</h4><p>更新插入,如果存在文档就更新，如果不存在就插入</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">IndexRequest indexRequest = new IndexRequest(&quot;index&quot;, &quot;type&quot;, &quot;1&quot;)</div><div class="line">        .source(jsonBuilder()</div><div class="line">            .startObject()</div><div class="line">                .field(&quot;name&quot;, &quot;Joe Smith&quot;)</div><div class="line">                .field(&quot;gender&quot;, &quot;male&quot;)</div><div class="line">            .endObject());</div><div class="line">UpdateRequest updateRequest = new UpdateRequest(&quot;index&quot;, &quot;type&quot;, &quot;1&quot;)</div><div class="line">        .doc(jsonBuilder()</div><div class="line">            .startObject()</div><div class="line">                .field(&quot;gender&quot;, &quot;male&quot;)</div><div class="line">            .endObject())</div><div class="line">        .upsert(indexRequest); //如果不存在此文档 ，就增加 `indexRequest`</div><div class="line">client.update(updateRequest).get();</div></pre></td></tr></table></figure><p>如果 <code>index/type/1</code> 存在，类似下面的文档：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;  : &quot;Joe Dalton&quot;,</div><div class="line">    &quot;gender&quot;: &quot;male&quot;        </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果不存在，会插入新的文档：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot; : &quot;Joe Smith&quot;,</div><div class="line">    &quot;gender&quot;: &quot;male&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Multi-Get-API"><a href="#Multi-Get-API" class="headerlink" title="Multi Get API"></a>Multi Get API</h3><p>一次获取多个文档</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MultiGetResponse multiGetItemResponses = client.prepareMultiGet()</div><div class="line">    .add(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;) //一个id的方式</div><div class="line">    .add(&quot;twitter&quot;, &quot;tweet&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;) //多个id的方式</div><div class="line">    .add(&quot;another&quot;, &quot;type&quot;, &quot;foo&quot;)  //可以从另外一个索引获取</div><div class="line">    .get();</div><div class="line"></div><div class="line">for (MultiGetItemResponse itemResponse : multiGetItemResponses) &#123; //迭代返回值</div><div class="line">    GetResponse response = itemResponse.getResponse();</div><div class="line">    if (response.isExists()) &#123;      //判断是否存在                </div><div class="line">        String json = response.getSourceAsString(); //_source 字段</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>更多请浏览REST <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/docs-multi-get.html" target="_blank" rel="external">multi get</a> 文档</p><h3 id="Bulk-API"><a href="#Bulk-API" class="headerlink" title="Bulk API"></a>Bulk API</h3><p>Bulk API，批量插入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import static org.elasticsearch.common.xcontent.XContentFactory.*;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BulkRequestBuilder bulkRequest = client.prepareBulk();</div><div class="line"></div><div class="line">// either use client#prepare, or use Requests# to directly build index/delete requests</div><div class="line">bulkRequest.add(client.prepareIndex(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;)</div><div class="line">        .setSource(jsonBuilder()</div><div class="line">                    .startObject()</div><div class="line">                        .field(&quot;user&quot;, &quot;kimchy&quot;)</div><div class="line">                        .field(&quot;postDate&quot;, new Date())</div><div class="line">                        .field(&quot;message&quot;, &quot;trying out Elasticsearch&quot;)</div><div class="line">                    .endObject()</div><div class="line">                  )</div><div class="line">        );</div><div class="line"></div><div class="line">bulkRequest.add(client.prepareIndex(&quot;twitter&quot;, &quot;tweet&quot;, &quot;2&quot;)</div><div class="line">        .setSource(jsonBuilder()</div><div class="line">                    .startObject()</div><div class="line">                        .field(&quot;user&quot;, &quot;kimchy&quot;)</div><div class="line">                        .field(&quot;postDate&quot;, new Date())</div><div class="line">                        .field(&quot;message&quot;, &quot;another post&quot;)</div><div class="line">                    .endObject()</div><div class="line">                  )</div><div class="line">        );</div><div class="line"></div><div class="line">BulkResponse bulkResponse = bulkRequest.get();</div><div class="line">if (bulkResponse.hasFailures()) &#123;</div><div class="line">    // process failures by iterating through each bulk response item</div><div class="line">    //处理失败</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="使用-Bulk-Processor"><a href="#使用-Bulk-Processor" class="headerlink" title="使用 Bulk Processor"></a>使用 Bulk Processor</h3><p>BulkProcessor 提供了一个简单的接口，在给定的大小数量上定时批量自动请求</p><h4 id="创建BulkProcessor实例"><a href="#创建BulkProcessor实例" class="headerlink" title="创建BulkProcessor实例"></a>创建<code>BulkProcessor</code>实例</h4><p>首先创建<code>BulkProcessor</code>实例</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.elasticsearch.action.bulk.BackoffPolicy;</div><div class="line">import org.elasticsearch.action.bulk.BulkProcessor;</div><div class="line">import org.elasticsearch.common.unit.ByteSizeUnit;</div><div class="line">import org.elasticsearch.common.unit.ByteSizeValue;</div><div class="line">import org.elasticsearch.common.unit.TimeValue;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BulkProcessor bulkProcessor = BulkProcessor.builder(</div><div class="line">        client,  //增加elasticsearch客户端</div><div class="line">        new BulkProcessor.Listener() &#123;</div><div class="line">            @Override</div><div class="line">            public void beforeBulk(long executionId,</div><div class="line">                                   BulkRequest request) &#123; ... &#125; //调用bulk之前执行 ，例如你可以通过request.numberOfActions()方法知道numberOfActions</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void afterBulk(long executionId,</div><div class="line">                                  BulkRequest request,</div><div class="line">                                  BulkResponse response) &#123; ... &#125; //调用bulk之后执行 ，例如你可以通过request.hasFailures()方法知道是否执行失败</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void afterBulk(long executionId,</div><div class="line">                                  BulkRequest request,</div><div class="line">                                  Throwable failure) &#123; ... &#125; //调用失败抛 Throwable</div><div class="line">        &#125;)</div><div class="line">        .setBulkActions(10000) //每次10000请求</div><div class="line">        .setBulkSize(new ByteSizeValue(5, ByteSizeUnit.MB)) //拆成5mb一块</div><div class="line">        .setFlushInterval(TimeValue.timeValueSeconds(5)) //无论请求数量多少，每5秒钟请求一次。</div><div class="line">        .setConcurrentRequests(1) //设置并发请求的数量。值为0意味着只允许执行一个请求。值为1意味着允许1并发请求。</div><div class="line">        .setBackoffPolicy(</div><div class="line">            BackoffPolicy.exponentialBackoff(TimeValue.timeValueMillis(100), 3))//设置自定义重复请求机制，最开始等待100毫秒，之后成倍更加，重试3次，当一次或多次重复请求失败后因为计算资源不够抛出 EsRejectedExecutionException 异常，可以通过BackoffPolicy.noBackoff()方法关闭重试机制</div><div class="line">        .build();</div></pre></td></tr></table></figure><h4 id="BulkProcessor-默认设置"><a href="#BulkProcessor-默认设置" class="headerlink" title="BulkProcessor 默认设置"></a>BulkProcessor 默认设置</h4><ul><li>bulkActions  1000 </li><li>bulkSize 5mb</li><li>不设置flushInterval</li><li>concurrentRequests 为 1 ，异步执行</li><li>backoffPolicy 重试 8次，等待50毫秒</li></ul><h4 id="增加requests"><a href="#增加requests" class="headerlink" title="增加requests"></a>增加requests</h4><p>然后增加<code>requests</code>到<code>BulkProcessor</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bulkProcessor.add(new IndexRequest(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;).source(/* your doc here */));</div><div class="line">bulkProcessor.add(new DeleteRequest(&quot;twitter&quot;, &quot;tweet&quot;, &quot;2&quot;));</div></pre></td></tr></table></figure></p><h4 id="关闭-Bulk-Processor"><a href="#关闭-Bulk-Processor" class="headerlink" title="关闭 Bulk Processor"></a>关闭 Bulk Processor</h4><p>当所有文档都处理完成，使用<code>awaitClose</code> 或 <code>close</code> 方法关闭<code>BulkProcessor</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bulkProcessor.awaitClose(10, TimeUnit.MINUTES);</div></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bulkProcessor.close();</div></pre></td></tr></table></figure><h4 id="在测试中使用Bulk-Processor"><a href="#在测试中使用Bulk-Processor" class="headerlink" title="在测试中使用Bulk Processor"></a>在测试中使用Bulk Processor</h4><p>如果你在测试种使用<code>Bulk Processor</code>可以执行同步方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">BulkProcessor bulkProcessor = BulkProcessor.builder(client, new BulkProcessor.Listener() &#123; /* Listener methods */ &#125;)</div><div class="line">        .setBulkActions(10000)</div><div class="line">        .setConcurrentRequests(0)</div><div class="line">        .build();</div><div class="line"></div><div class="line">// Add your requests</div><div class="line">bulkProcessor.add(/* Your requests */);</div><div class="line"></div><div class="line">// Flush any remaining requests</div><div class="line">bulkProcessor.flush();</div><div class="line"></div><div class="line">// Or close the bulkProcessor if you don&apos;t need it anymore</div><div class="line">bulkProcessor.close();</div><div class="line"></div><div class="line">// Refresh your indices</div><div class="line">client.admin().indices().prepareRefresh().get();</div><div class="line"></div><div class="line">// Now you can start searching!</div><div class="line">client.prepareSearch().get();</div></pre></td></tr></table></figure></p><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">所有实例</a> 已经上传到Git</p><p>更多请浏览 <a href="https://github.com/quanke/spring-boot-starter-es" target="_blank" rel="external">spring-boot-starter-es</a> 开源项目</p><blockquote><p>如何有任何问题请关注微信公众号给我留言</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本节介绍以下 CRUD API：&lt;/p&gt;
&lt;p&gt; 单文档  APIs&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;document-apis/index-api.md&quot;&gt;Index API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;document-apis/get-ap
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Java API - 客户端连接(TransportClient，PreBuiltXPackTransportClient)（一）</title>
    <link href="http://quanke.name/posts/39952/"/>
    <id>http://quanke.name/posts/39952/</id>
    <published>2017-11-13T11:01:00.000Z</published>
    <updated>2018-02-02T15:25:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch-Java-API-客户端连接"><a href="#Elasticsearch-Java-API-客户端连接" class="headerlink" title="Elasticsearch Java API 客户端连接"></a>Elasticsearch Java API 客户端连接</h2><p>一个是<code>TransportClient</code>，一个是<code>NodeClient</code>，还有一个<code>XPackTransportClient</code></p><ul><li>TransportClient：</li></ul><p>作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。</p><ul><li>NodeClient</li></ul><p>作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的。</p><ul><li>XPackTransportClient：</li></ul><p>服务安装了 <code>x-pack</code> 插件</p><blockquote><p>重要：客户端版本应该和服务端版本保持一致</p><p>TransportClient旨在被Java高级REST客户端取代，该客户端执行HTTP请求而不是序列化的Java请求。 在即将到来的Elasticsearch版本中将不赞成使用TransportClient，建议使用Java高级REST客户端。</p><p>上面的警告比较尴尬，但是在 5xx版本中使用还是没有问题的，可能使用rest 客户端兼容性更好做一些。</p></blockquote><p><a href="https://www.gitbook.com/book/quanke/elasticsearch-java-rest" target="_blank" rel="external">Elasticsearch Java Rest API 手册</a></p><h3 id="Maven-Repository"><a href="#Maven-Repository" class="headerlink" title="Maven Repository"></a>Maven Repository</h3><p>Elasticsearch Java API包已经上传到 <a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elasticsearch%22" target="_blank" rel="external">Maven Central</a></p><p>在<code>pom.xml</code>文件中增加：</p><blockquote><p>transport 版本号最好就是与Elasticsearch版本号一致。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;transport&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.6.3&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><h3 id="Transport-Client"><a href="#Transport-Client" class="headerlink" title="Transport Client"></a>Transport Client</h3><h4 id="不设置集群名称"><a href="#不设置集群名称" class="headerlink" title="不设置集群名称"></a>不设置集群名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// on startup</div><div class="line"></div><div class="line">//此步骤添加IP，至少一个，如果设置了&quot;client.transport.sniff&quot;= true 一个就够了，因为添加了自动嗅探配置</div><div class="line">TransportClient client = new PreBuiltTransportClient(Settings.EMPTY)</div><div class="line">        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host1&quot;), 9300))</div><div class="line">        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host2&quot;), 9300));</div><div class="line"></div><div class="line">// on shutdown  关闭client</div><div class="line"></div><div class="line">client.close();</div></pre></td></tr></table></figure><h4 id="设置集群名称"><a href="#设置集群名称" class="headerlink" title="设置集群名称"></a>设置集群名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Settings settings = Settings.builder()</div><div class="line">        .put(&quot;cluster.name&quot;, &quot;myClusterName&quot;).build();  //设置ES实例的名称</div><div class="line">TransportClient client = new PreBuiltTransportClient(settings);  //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中</div><div class="line">//Add transport addresses and do something with the client...</div></pre></td></tr></table></figure><h4 id="增加自动嗅探配置"><a href="#增加自动嗅探配置" class="headerlink" title="增加自动嗅探配置"></a>增加自动嗅探配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Settings settings = Settings.builder()</div><div class="line">        .put(&quot;client.transport.sniff&quot;, true).build();</div><div class="line">TransportClient client = new PreBuiltTransportClient(settings);</div></pre></td></tr></table></figure><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">client.transport.ignore_cluster_name  //设置 true ，忽略连接节点集群名验证</div><div class="line">client.transport.ping_timeout       //ping一个节点的响应时间 默认5秒</div><div class="line">client.transport.nodes_sampler_interval //sample/ping 节点的时间间隔，默认是5s</div></pre></td></tr></table></figure><blockquote><p>对于ES Client，有两种形式，一个是TransportClient，一个是NodeClient。两个的区别为：<br>TransportClient作为一个外部访问者，通过HTTP去请求ES的集群，对于集群而言，它是一个外部因素。<br>NodeClient顾名思义，是作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的，不像TransportClient那样，ES集群对它一无所知。NodeClient通信的性能会更好，但是因为是ES的一环，所以它出问题，也会给ES集群带来问题。NodeClient可以设置不作为数据节点，在elasticsearch.yml中设置，这样就不会在此节点上分配数据。</p></blockquote><p>如果用ES的节点，仁者见仁智者见智。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.es.study;</div><div class="line"></div><div class="line">import name.quanke.es.study.util.Utils;</div><div class="line">import org.elasticsearch.action.search.SearchResponse;</div><div class="line">import org.elasticsearch.client.transport.TransportClient;</div><div class="line">import org.elasticsearch.common.settings.Settings;</div><div class="line">import org.elasticsearch.common.transport.InetSocketTransportAddress;</div><div class="line">import org.elasticsearch.transport.client.PreBuiltTransportClient;</div><div class="line">import org.junit.After;</div><div class="line">import org.junit.Before;</div><div class="line"></div><div class="line">import java.net.InetAddress;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Elasticsearch 5.5.1 的client 和 ElasticsearchTemplate的初始化</div><div class="line"> * 作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。</div><div class="line"> * Created by http://quanke.name on 2017/11/10.</div><div class="line"> */</div><div class="line">public class ElasticsearchClient &#123;</div><div class="line"></div><div class="line">    protected TransportClient client;</div><div class="line"></div><div class="line">    @Before</div><div class="line">    public void setUp() throws Exception &#123;</div><div class="line"></div><div class="line">        Settings esSettings = Settings.builder()</div><div class="line">                .put(&quot;cluster.name&quot;, &quot;utan-es&quot;) //设置ES实例的名称</div><div class="line">                .put(&quot;client.transport.sniff&quot;, true) //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中</div><div class="line">                .build();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 这里的连接方式指的是没有安装x-pack插件,如果安装了x-pack则参考&#123;@link ElasticsearchXPackClient&#125;</div><div class="line">         * 1. java客户端的方式是以tcp协议在9300端口上进行通信</div><div class="line">         * 2. http客户端的方式是以http协议在9200端口上进行通信</div><div class="line">         */</div><div class="line">        client = new PreBuiltTransportClient(esSettings)</div><div class="line">                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300));</div><div class="line"></div><div class="line">        System.out.println(&quot;ElasticsearchClient 连接成功&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @After</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        if (client != null) &#123;</div><div class="line">            client.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void println(SearchResponse searchResponse) &#123;</div><div class="line">        Utils.println(searchResponse);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>本实例代码已经上传到 Git <a href="https://gitee.com/quanke/elasticsearch-java-study/blob/master/src/test/java/name/quanke/es/study/ElasticsearchClient.java）" target="_blank" rel="external">ElasticsearchClient.java</a></p></blockquote><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">所有实例</a> 已经上传到Git</p><h3 id="XPackTransportClient"><a href="#XPackTransportClient" class="headerlink" title="XPackTransportClient"></a>XPackTransportClient</h3><p>如果 <code>ElasticSearch</code> 服务安装了 <code>x-pack</code> 插件，需要<code>PreBuiltXPackTransportClient</code>实例才能访问</p><p>使用Maven管理项目，把下面代码增加到<code>pom.xml</code>;</p><blockquote><p>一定要修改默认仓库地址为<a href="https://artifacts.elastic.co/maven" target="_blank" rel="external">https://artifacts.elastic.co/maven</a> ，因为这个库没有上传到Maven中央仓库,如果有自己的 maven ，请配置代理</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;project ...&gt;</div><div class="line"></div><div class="line">   &lt;repositories&gt;</div><div class="line">      &lt;!-- add the elasticsearch repo --&gt;</div><div class="line">      &lt;repository&gt;</div><div class="line">         &lt;id&gt;elasticsearch-releases&lt;/id&gt;</div><div class="line">         &lt;url&gt;https://artifacts.elastic.co/maven&lt;/url&gt;</div><div class="line">         &lt;releases&gt;</div><div class="line">            &lt;enabled&gt;true&lt;/enabled&gt;</div><div class="line">         &lt;/releases&gt;</div><div class="line">         &lt;snapshots&gt;</div><div class="line">            &lt;enabled&gt;false&lt;/enabled&gt;</div><div class="line">         &lt;/snapshots&gt;</div><div class="line">      &lt;/repository&gt;</div><div class="line">      ...</div><div class="line">   &lt;/repositories&gt;</div><div class="line">   ...</div><div class="line"></div><div class="line">   &lt;dependencies&gt;</div><div class="line">      &lt;!-- add the x-pack jar as a dependency --&gt;</div><div class="line">      &lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;x-pack-transport&lt;/artifactId&gt;</div><div class="line">         &lt;version&gt;5.6.3&lt;/version&gt;</div><div class="line">      &lt;/dependency&gt;</div><div class="line">      ...</div><div class="line">   &lt;/dependencies&gt;</div><div class="line">   ...</div><div class="line"></div><div class="line"> &lt;/project&gt;</div></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * Elasticsearch XPack Client</div><div class="line"> * Created by http://quanke.name on 2017/11/10.</div><div class="line"> */</div><div class="line">public class ElasticsearchXPackClient &#123;</div><div class="line"></div><div class="line">    protected TransportClient client;</div><div class="line">    </div><div class="line">    @Before</div><div class="line">    public void setUp() throws Exception &#123;</div><div class="line">        /**</div><div class="line">         * 如果es集群安装了x-pack插件则以此种方式连接集群</div><div class="line">         * 1. java客户端的方式是以tcp协议在9300端口上进行通信</div><div class="line">         * 2. http客户端的方式是以http协议在9200端口上进行通信</div><div class="line">         */</div><div class="line">        Settings settings = Settings.builder()</div><div class="line">                .put(&quot;xpack.security.user&quot;, &quot;elastic:utan100&quot;)</div><div class="line">                .put(&quot;cluster.name&quot;, &quot;utan-es&quot;)</div><div class="line">                .build();</div><div class="line">        client = new PreBuiltXPackTransportClient(settings)</div><div class="line">                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300));</div><div class="line">//        final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();</div><div class="line">//        credentialsProvider.setCredentials(AuthScope.ANY,</div><div class="line">//                new UsernamePasswordCredentials(&quot;elastic&quot;, &quot;utan100&quot;));</div><div class="line"></div><div class="line">        System.out.println(&quot;ElasticsearchXPackClient 启动成功&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testClientConnection() throws Exception &#123;</div><div class="line"></div><div class="line">        System.out.println(&quot;--------------------------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @After</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        if (client != null) &#123;</div><div class="line">            client.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void println(SearchResponse searchResponse) &#123;</div><div class="line">        Utils.println(searchResponse);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>本实例代码已经上传到 Git <a href="https://gitee.com/quanke/elasticsearch-java-study/blob/master/src/test/java/name/quanke/es/study/ElasticsearchXPackClient.java）" target="_blank" rel="external"> ElasticsearchXPackClient.java</a></p></blockquote><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">所有实例</a> 已经上传到Git</p><p>更多请浏览 <a href="https://github.com/quanke/spring-boot-starter-es" target="_blank" rel="external">spring-boot-starter-es</a> 开源项目</p><blockquote><p>如何有任何问题请关注微信公众号给我留言</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch-Java-API-客户端连接&quot;&gt;&lt;a href=&quot;#Elasticsearch-Java-API-客户端连接&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch Java API 客户端连接&quot;&gt;&lt;/a&gt;El
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="Java" scheme="http://quanke.name/tags/Java/"/>
    
      <category term="API" scheme="http://quanke.name/tags/API/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Java API - 客户端连接(TransportClient，PreBuiltXPackTransportClient)（一）</title>
    <link href="http://quanke.name/posts/39952/"/>
    <id>http://quanke.name/posts/39952/</id>
    <published>2017-11-13T11:01:00.000Z</published>
    <updated>2018-02-02T15:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch-Java-API-客户端连接"><a href="#Elasticsearch-Java-API-客户端连接" class="headerlink" title="Elasticsearch Java API 客户端连接"></a>Elasticsearch Java API 客户端连接</h2><p>一个是<code>TransportClient</code>，一个是<code>NodeClient</code>，还有一个<code>XPackTransportClient</code></p><ul><li>TransportClient：</li></ul><p>作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。</p><ul><li>NodeClient</li></ul><p>作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的。</p><ul><li>XPackTransportClient：</li></ul><p>服务安装了 <code>x-pack</code> 插件</p><blockquote><p>重要：客户端版本应该和服务端版本保持一致</p><p>TransportClient旨在被Java高级REST客户端取代，该客户端执行HTTP请求而不是序列化的Java请求。 在即将到来的Elasticsearch版本中将不赞成使用TransportClient，建议使用Java高级REST客户端。</p><p>上面的警告比较尴尬，但是在 5xx版本中使用还是没有问题的，可能使用rest 客户端兼容性更好做一些。</p></blockquote><p><a href="https://www.gitbook.com/book/quanke/elasticsearch-java-rest" target="_blank" rel="external">Elasticsearch Java Rest API 手册</a></p><h3 id="Maven-Repository"><a href="#Maven-Repository" class="headerlink" title="Maven Repository"></a>Maven Repository</h3><p>Elasticsearch Java API包已经上传到 <a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22elasticsearch%22" target="_blank" rel="external">Maven Central</a></p><p>在<code>pom.xml</code>文件中增加：</p><blockquote><p>transport 版本号最好就是与Elasticsearch版本号一致。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;transport&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.6.3&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><h3 id="Transport-Client"><a href="#Transport-Client" class="headerlink" title="Transport Client"></a>Transport Client</h3><h4 id="不设置集群名称"><a href="#不设置集群名称" class="headerlink" title="不设置集群名称"></a>不设置集群名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// on startup</div><div class="line"></div><div class="line">//此步骤添加IP，至少一个，如果设置了&quot;client.transport.sniff&quot;= true 一个就够了，因为添加了自动嗅探配置</div><div class="line">TransportClient client = new PreBuiltTransportClient(Settings.EMPTY)</div><div class="line">        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host1&quot;), 9300))</div><div class="line">        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host2&quot;), 9300));</div><div class="line"></div><div class="line">// on shutdown  关闭client</div><div class="line"></div><div class="line">client.close();</div></pre></td></tr></table></figure><h4 id="设置集群名称"><a href="#设置集群名称" class="headerlink" title="设置集群名称"></a>设置集群名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Settings settings = Settings.builder()</div><div class="line">        .put(&quot;cluster.name&quot;, &quot;myClusterName&quot;).build();  //设置ES实例的名称</div><div class="line">TransportClient client = new PreBuiltTransportClient(settings);  //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中</div><div class="line">//Add transport addresses and do something with the client...</div></pre></td></tr></table></figure><h4 id="增加自动嗅探配置"><a href="#增加自动嗅探配置" class="headerlink" title="增加自动嗅探配置"></a>增加自动嗅探配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Settings settings = Settings.builder()</div><div class="line">        .put(&quot;client.transport.sniff&quot;, true).build();</div><div class="line">TransportClient client = new PreBuiltTransportClient(settings);</div></pre></td></tr></table></figure><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">client.transport.ignore_cluster_name  //设置 true ，忽略连接节点集群名验证</div><div class="line">client.transport.ping_timeout       //ping一个节点的响应时间 默认5秒</div><div class="line">client.transport.nodes_sampler_interval //sample/ping 节点的时间间隔，默认是5s</div></pre></td></tr></table></figure><blockquote><p>对于ES Client，有两种形式，一个是TransportClient，一个是NodeClient。两个的区别为：<br>TransportClient作为一个外部访问者，通过HTTP去请求ES的集群，对于集群而言，它是一个外部因素。<br>NodeClient顾名思义，是作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的，不像TransportClient那样，ES集群对它一无所知。NodeClient通信的性能会更好，但是因为是ES的一环，所以它出问题，也会给ES集群带来问题。NodeClient可以设置不作为数据节点，在elasticsearch.yml中设置，这样就不会在此节点上分配数据。</p></blockquote><p>如果用ES的节点，仁者见仁智者见智。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package name.quanke.es.study;</div><div class="line"></div><div class="line">import name.quanke.es.study.util.Utils;</div><div class="line">import org.elasticsearch.action.search.SearchResponse;</div><div class="line">import org.elasticsearch.client.transport.TransportClient;</div><div class="line">import org.elasticsearch.common.settings.Settings;</div><div class="line">import org.elasticsearch.common.transport.InetSocketTransportAddress;</div><div class="line">import org.elasticsearch.transport.client.PreBuiltTransportClient;</div><div class="line">import org.junit.After;</div><div class="line">import org.junit.Before;</div><div class="line"></div><div class="line">import java.net.InetAddress;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Elasticsearch 5.5.1 的client 和 ElasticsearchTemplate的初始化</div><div class="line"> * 作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。</div><div class="line"> * Created by http://quanke.name on 2017/11/10.</div><div class="line"> */</div><div class="line">public class ElasticsearchClient &#123;</div><div class="line"></div><div class="line">    protected TransportClient client;</div><div class="line"></div><div class="line">    @Before</div><div class="line">    public void setUp() throws Exception &#123;</div><div class="line"></div><div class="line">        Settings esSettings = Settings.builder()</div><div class="line">                .put(&quot;cluster.name&quot;, &quot;utan-es&quot;) //设置ES实例的名称</div><div class="line">                .put(&quot;client.transport.sniff&quot;, true) //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中</div><div class="line">                .build();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 这里的连接方式指的是没有安装x-pack插件,如果安装了x-pack则参考&#123;@link ElasticsearchXPackClient&#125;</div><div class="line">         * 1. java客户端的方式是以tcp协议在9300端口上进行通信</div><div class="line">         * 2. http客户端的方式是以http协议在9200端口上进行通信</div><div class="line">         */</div><div class="line">        client = new PreBuiltTransportClient(esSettings)</div><div class="line">                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300));</div><div class="line"></div><div class="line">        System.out.println(&quot;ElasticsearchClient 连接成功&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @After</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        if (client != null) &#123;</div><div class="line">            client.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void println(SearchResponse searchResponse) &#123;</div><div class="line">        Utils.println(searchResponse);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>本实例代码已经上传到 Git <a href="https://gitee.com/quanke/elasticsearch-java-study/blob/master/src/test/java/name/quanke/es/study/ElasticsearchClient.java）" target="_blank" rel="external">ElasticsearchClient.java</a></p></blockquote><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">所有实例</a> 已经上传到Git</p><h3 id="XPackTransportClient"><a href="#XPackTransportClient" class="headerlink" title="XPackTransportClient"></a>XPackTransportClient</h3><p>如果 <code>ElasticSearch</code> 服务安装了 <code>x-pack</code> 插件，需要<code>PreBuiltXPackTransportClient</code>实例才能访问</p><p>使用Maven管理项目，把下面代码增加到<code>pom.xml</code>;</p><blockquote><p>一定要修改默认仓库地址为<a href="https://artifacts.elastic.co/maven" target="_blank" rel="external">https://artifacts.elastic.co/maven</a> ，因为这个库没有上传到Maven中央仓库,如果有自己的 maven ，请配置代理</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;project ...&gt;</div><div class="line"></div><div class="line">   &lt;repositories&gt;</div><div class="line">      &lt;!-- add the elasticsearch repo --&gt;</div><div class="line">      &lt;repository&gt;</div><div class="line">         &lt;id&gt;elasticsearch-releases&lt;/id&gt;</div><div class="line">         &lt;url&gt;https://artifacts.elastic.co/maven&lt;/url&gt;</div><div class="line">         &lt;releases&gt;</div><div class="line">            &lt;enabled&gt;true&lt;/enabled&gt;</div><div class="line">         &lt;/releases&gt;</div><div class="line">         &lt;snapshots&gt;</div><div class="line">            &lt;enabled&gt;false&lt;/enabled&gt;</div><div class="line">         &lt;/snapshots&gt;</div><div class="line">      &lt;/repository&gt;</div><div class="line">      ...</div><div class="line">   &lt;/repositories&gt;</div><div class="line">   ...</div><div class="line"></div><div class="line">   &lt;dependencies&gt;</div><div class="line">      &lt;!-- add the x-pack jar as a dependency --&gt;</div><div class="line">      &lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;x-pack-transport&lt;/artifactId&gt;</div><div class="line">         &lt;version&gt;5.6.3&lt;/version&gt;</div><div class="line">      &lt;/dependency&gt;</div><div class="line">      ...</div><div class="line">   &lt;/dependencies&gt;</div><div class="line">   ...</div><div class="line"></div><div class="line"> &lt;/project&gt;</div></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * Elasticsearch XPack Client</div><div class="line"> * Created by http://quanke.name on 2017/11/10.</div><div class="line"> */</div><div class="line">public class ElasticsearchXPackClient &#123;</div><div class="line"></div><div class="line">    protected TransportClient client;</div><div class="line">    </div><div class="line">    @Before</div><div class="line">    public void setUp() throws Exception &#123;</div><div class="line">        /**</div><div class="line">         * 如果es集群安装了x-pack插件则以此种方式连接集群</div><div class="line">         * 1. java客户端的方式是以tcp协议在9300端口上进行通信</div><div class="line">         * 2. http客户端的方式是以http协议在9200端口上进行通信</div><div class="line">         */</div><div class="line">        Settings settings = Settings.builder()</div><div class="line">                .put(&quot;xpack.security.user&quot;, &quot;elastic:utan100&quot;)</div><div class="line">                .put(&quot;cluster.name&quot;, &quot;utan-es&quot;)</div><div class="line">                .build();</div><div class="line">        client = new PreBuiltXPackTransportClient(settings)</div><div class="line">                .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300));</div><div class="line">//        final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();</div><div class="line">//        credentialsProvider.setCredentials(AuthScope.ANY,</div><div class="line">//                new UsernamePasswordCredentials(&quot;elastic&quot;, &quot;utan100&quot;));</div><div class="line"></div><div class="line">        System.out.println(&quot;ElasticsearchXPackClient 启动成功&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testClientConnection() throws Exception &#123;</div><div class="line"></div><div class="line">        System.out.println(&quot;--------------------------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @After</div><div class="line">    public void tearDown() throws Exception &#123;</div><div class="line">        if (client != null) &#123;</div><div class="line">            client.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void println(SearchResponse searchResponse) &#123;</div><div class="line">        Utils.println(searchResponse);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>本实例代码已经上传到 Git <a href="https://gitee.com/quanke/elasticsearch-java-study/blob/master/src/test/java/name/quanke/es/study/ElasticsearchXPackClient.java）" target="_blank" rel="external"> ElasticsearchXPackClient.java</a></p></blockquote><p><a href="https://gitee.com/quanke/elasticsearch-java-study" target="_blank" rel="external">所有实例</a> 已经上传到Git</p><p>更多请浏览 <a href="https://github.com/quanke/spring-boot-starter-es" target="_blank" rel="external">spring-boot-starter-es</a> 开源项目</p><blockquote><p>如何有任何问题请关注微信公众号给我留言</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch-Java-API-客户端连接&quot;&gt;&lt;a href=&quot;#Elasticsearch-Java-API-客户端连接&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch Java API 客户端连接&quot;&gt;&lt;/a&gt;El
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="Java" scheme="http://quanke.name/tags/Java/"/>
    
      <category term="API" scheme="http://quanke.name/tags/API/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 5.6 Java API 中文手册 </title>
    <link href="http://quanke.name/posts/21227/"/>
    <id>http://quanke.name/posts/21227/</id>
    <published>2017-11-08T09:21:00.000Z</published>
    <updated>2018-02-02T15:25:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/432952-5448f57c503678f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Elasticsearch 5.6 Java API 中文手册 "></p><p>本手册由 <a href="http://quanke.name">全科</a> 翻译，并且整理成电子书，支持PDF,ePub,Mobi格式，方便大家下载阅读。</p><blockquote><p>不只是官方文档的翻译，还包含使用实例，包含我们使用踩过的坑</p></blockquote><p>阅读地址：<a href="https://es.quanke.name" target="_blank" rel="external">https://es.quanke.name</a></p><p>下载地址：<a href="https://www.gitbook.com/book/quanke/elasticsearch-java" target="_blank" rel="external">https://www.gitbook.com/book/quanke/elasticsearch-java</a></p><p>github地址：<a href="https://github.com/quanke/elasticsearch-java" target="_blank" rel="external">https://github.com/quanke/elasticsearch-java</a></p><p>编辑：<a href="http://quanke.name">http://quanke.name</a></p><p>编辑整理辛苦，还望大神们点一下star ，抚平我虚荣的心</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/432952-5448f57c503678f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; a
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="http://quanke.name/categories/es/"/>
    
    
      <category term="Elasticsearch" scheme="http://quanke.name/tags/es/"/>
    
      <category term="Java" scheme="http://quanke.name/tags/Java/"/>
    
      <category term="API" scheme="http://quanke.name/tags/API/"/>
    
      <category term="大数据" scheme="http://quanke.name/tags/bdaga/"/>
    
  </entry>
  
  <entry>
    <title>使用PM2运行node.js服务</title>
    <link href="http://quanke.name/posts/19415/"/>
    <id>http://quanke.name/posts/19415/</id>
    <published>2017-11-06T08:20:00.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><hr><ul><li>GitHub 地址：  <a href="https://github.com/Unitech/pm2" target="_blank" rel="external">https://github.com/Unitech/pm2</a></li><li>官网： <a href="http://pm2.keymetrics.io/" target="_blank" rel="external">http://pm2.keymetrics.io/</a></li></ul><h2 id="为什么需要使用PM2"><a href="#为什么需要使用PM2" class="headerlink" title="为什么需要使用PM2"></a>为什么需要使用PM2</h2><p>因为node.js 是单进程，进程被杀死后整个服务就跪了，所以需要进程管理工具，但是pm2 远远不止这些。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PM2 是一个带有负载均衡功能的 Node 应用的进程管理器。</p><p>当你要把你的独立代码利用全部的服务器上的所有 CPU，并保证进程永远都活着，0 秒的重载， PM2 是完美的。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>内建负载均衡（使用Node cluster 集群模块）</li><li>后台运行</li><li>0秒停机重载(维护升级的时候不需要停机).</li><li>具有Ubuntu和CentOS 的启动脚本</li><li>停止不稳定的进程（避免无限循环）</li><li>控制台检测</li><li>提供 HTTP API</li><li>远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>首先确保有node.js 的环境</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install -g pm2</div></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pm2 start app.js --name my-api # 命名进程</div></pre></td></tr></table></figure><h3 id="其他运行方式："><a href="#其他运行方式：" class="headerlink" title="其他运行方式："></a>其他运行方式：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pm2 start app.js -i max  # 根据有效CPU数目启动最大进程数目</div><div class="line">pm2 start app.js -i 3      # 启动3个进程</div><div class="line">pm2 start app.js -x        #用fork模式启动 app.js 而不是使用 cluster</div><div class="line">pm2 start app.js -x -- -a 23   # 用fork模式启动 app.js 并且传递参数 (-a 23)</div><div class="line">pm2 start app.js --name serverone  # 启动一个进程并把它命名为 serverone</div><div class="line">pm2 stop serverone       # 停止 serverone 进程</div><div class="line">pm2 start app.json        # 启动进程, 在 app.json里设置选项</div><div class="line">pm2 start app.js -i max -- -a 23                   #在--之后给 app.js 传递参数</div><div class="line">pm2 start app.js -i max -e err.log -o out.log  # 启动 并 生成一个配置文件，你也可以执行用其他语言编写的app  ( fork 模式):</div><div class="line">pm2 start my-bash-script.sh    -x --interpreter bash</div><div class="line">pm2 start my-python-script.py -x --interpreter python</div></pre></td></tr></table></figure><h3 id="npm-运行"><a href="#npm-运行" class="headerlink" title="npm 运行"></a>npm 运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pm2 start npm -- start</div></pre></td></tr></table></figure><p>动一个进程并把它命名为 test<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pm2 start npm --name test -- start</div></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install pm2 -g     # 命令行安装 pm2 </div><div class="line">pm2 start app.js -i 4 #后台运行pm2，启动4个app.js </div><div class="line">                              # 也可以把&apos;max&apos; 参数传递给 start</div><div class="line">                              # 正确的进程数目依赖于Cpu的核心数目</div><div class="line">pm2 start app.js --name my-api # 命名进程</div><div class="line">pm2 list               # 显示所有进程状态</div><div class="line">pm2 monit              # 监视所有进程</div><div class="line">pm2 logs               #  显示所有进程日志</div><div class="line">pm2 stop all           # 停止所有进程</div><div class="line">pm2 restart all        # 重启所有进程</div><div class="line">pm2 reload all         # 0秒停机重载进程 (用于 NETWORKED 进程)</div><div class="line">pm2 stop 0             # 停止指定的进程</div><div class="line">pm2 restart 0          # 重启指定的进程</div><div class="line">pm2 startup            # 产生 init 脚本 保持进程活着</div><div class="line">pm2 web                # 运行健壮的 computer API endpoint (http://localhost:9615)</div><div class="line">pm2 delete 0           # 杀死指定的进程</div><div class="line">pm2 delete all         # 杀死全部进程</div></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.douban.com/note/314200231/" target="_blank" rel="external">https://www.douban.com/note/314200231/</a></li><li><a href="https://stackoverflow.com/questions/31579509/can-pm2-run-an-npm-start-script" target="_blank" rel="external">https://stackoverflow.com/questions/31579509/can-pm2-run-an-npm-start-script</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;GitHub 地址：  &lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="node.js" scheme="http://quanke.name/categories/node/"/>
    
    
      <category term="PM2" scheme="http://quanke.name/tags/PM2/"/>
    
      <category term="node.js 运行" scheme="http://quanke.name/tags/node-js-%E8%BF%90%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>swagger-edit写接口文档神器的部署和使用</title>
    <link href="http://quanke.name/posts/41016/"/>
    <id>http://quanke.name/posts/41016/</id>
    <published>2017-11-06T08:18:00.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>swagger 是一套开源的API设计工具，包括Swagger UI，Swagger Editor等。</p><p>其中Swagger Editor是个WEB小程序，它可以让你用YAML来定义你的接口规范，并实时验证和现实成接口文档。</p><p>我们主要使用Swagger Editor 编写接口文档，在线 <a href="https://editor.swagger.io" target="_blank" rel="external">Swagger Editor</a> 也是可以使用的，但是访问速度在国内有点慢，所以为了效率，自己在服务器搭建一套服务</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>直接git clone 最新代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git clone https://github.com/swagger-api/swagger-editor.git</div></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>首先确保有node.js 的环境</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cd swagger-edito</div><div class="line">npm install</div></pre></td></tr></table></figure><blockquote><p>安装 PM2 ,如果不会PM2，请查看 <a href="http://quanke.name/2017/11/06/%E4%BD%BF%E7%94%A8PM2%E8%BF%90%E8%A1%8Cnode-js%E6%9C%8D%E5%8A%A1/">《使用PM2运行node.js服务》</a> </p></blockquote><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>使用PM2运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pm2 start npm -- start</div></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>访问：</p><p><a href="http://192.168.2.52:3001/" target="_blank" rel="external">http://192.168.2.52:3001/</a></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="http://blog.csdn.net/wangmeng951011/article/details/67640375" target="_blank" rel="external">http://blog.csdn.net/wangmeng951011/article/details/67640375</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="使用" scheme="http://quanke.name/categories/use/"/>
    
    
      <category term="接口文档" scheme="http://quanke.name/tags/api/"/>
    
      <category term="swagger-api" scheme="http://quanke.name/tags/swagger-api/"/>
    
      <category term="swagger-edit" scheme="http://quanke.name/tags/swagger-edit/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch5xx使用logstash同步mysql</title>
    <link href="http://quanke.name/posts/108/"/>
    <id>http://quanke.name/posts/108/</id>
    <published>2017-11-06T07:53:00.000Z</published>
    <updated>2018-02-02T15:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="下载logstash"><a href="#下载logstash" class="headerlink" title="下载logstash"></a>下载logstash</h4><p>下载地址：<a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">https://www.elastic.co/downloads/logstash</a></p><blockquote><p>当时我下载的是5.6.3版本</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">https://artifacts.elastic.co/downloads/logstash/logstash-5.6.3.tar.gz</div></pre></td></tr></table></figure><p>解压：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tar -zxvf logstash-5.6.3.tar.gz</div></pre></td></tr></table></figure></p><p>进入安装目录</p><p>运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bin/logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos;</div></pre></td></tr></table></figure><p>等待几秒钟 出现  </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">The stdin plugin is now waiting for input:</div></pre></td></tr></table></figure><p>然后输入 </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hello world</div></pre></td></tr></table></figure><p>得到类似的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2017-10-30T02:49:59.005Z test-env hello world</div></pre></td></tr></table></figure></p><h4 id="安装logstash-input-jdbc插件"><a href="#安装logstash-input-jdbc插件" class="headerlink" title="安装logstash-input-jdbc插件"></a>安装logstash-input-jdbc插件</h4><p>1.安装 ruby 和 rubygems（注意：需要 ruby 的版本在 1.8.7 以上）</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">yum install -y ruby rubygems</div></pre></td></tr></table></figure><p>检查 ruby 版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ruby -v</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ruby 1.8.7 (2013-06-27 patchlevel 374) [x86_64-linux]</div></pre></td></tr></table></figure><p>替换国内的镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources --remove http://rubygems.org/</div><div class="line">gem sources -a http://gems.ruby-china.org/</div></pre></td></tr></table></figure><p>验证是否成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources -l</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">*** CURRENT SOURCES ***</div><div class="line"></div><div class="line">http://rubygems.org/</div><div class="line">http://gems.ruby-china.org/</div></pre></td></tr></table></figure><p>修改Gemfile的数据源地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim Gemfile</div></pre></td></tr></table></figure><p>修改 source 的值 为： <code>&quot;https://gems.ruby-china.org/&quot;</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim  Gemfile.jruby-1.9.lock</div></pre></td></tr></table></figure><p>找到 remote 修改它的值为：<code>https://gems.ruby-china.org/</code></p><p>开始安装:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./bin/logstash-plugin install --no-verify  logstash-input-jdbc</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Installing logstash-input-jdbc</div><div class="line">Installation successful</div></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h4><p>最基本的配置文件定义，必须包含input 和 output。如果需要对数据进操作，则需要加上filter段</p><p>配置 java mysql 连接驱动 <code>mysql-connector-java-5.1.42-bin.jar</code> </p><p><a href="https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz" target="_blank" rel="external">https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input &#123;</div><div class="line">  stdin &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  jdbc &#123;</div><div class="line">    jdbc_connection_string =&gt; &quot;jdbc:mysql://dbs1:3306/db2_utan_cs&quot;</div><div class="line">    jdbc_user =&gt; &quot;root&quot;</div><div class="line">    jdbc_password =&gt; &quot;123456&quot;</div><div class="line">    jdbc_driver_library =&gt; &quot;/data/arrow/logstash/mysql-connector-java-5.1.42-bin.jar&quot;</div><div class="line">    jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</div><div class="line">    jdbc_paging_enabled =&gt; &quot;true&quot;</div><div class="line">    jdbc_page_size =&gt; &quot;50000&quot;</div><div class="line">    statement =&gt; &quot;SELECT * FROM crawler_data WHERE id &gt; (SELECT MAX(t1.id) FROM db2_utan_cs.crawler_data AS t1)-70000 AND updatetime &gt; :sql_last_value&quot;</div><div class="line">    use_column_value =&gt; true</div><div class="line">    tracking_column =&gt; &quot;updatetime&quot;</div><div class="line">    schedule =&gt; &quot;* * * * *&quot;</div><div class="line">    type =&gt; &quot;baby_crawler&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">filter &#123;</div><div class="line">  mutate &#123;</div><div class="line">    remove_field =&gt; [ &quot;@timestamp&quot;, &quot;@version&quot;, &quot;id&quot; ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line">output &#123;</div><div class="line">  elasticsearch &#123;</div><div class="line">    hosts =&gt; &quot;192.168.1.21:9201&quot;</div><div class="line">    index =&gt; &quot;baby_crawler_b&quot;</div><div class="line">    document_id =&gt; &quot;%&#123;uniquekey&#125;&quot;</div><div class="line">  &#125;</div><div class="line">  stdout &#123;</div><div class="line">    codec =&gt; json_lines</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line"># 通过手动指定配置文件启动</div><div class="line"> </div><div class="line">/bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf</div><div class="line"> </div><div class="line"># 以daemon方式运行，则在指令后面加一个 &amp; 符号</div><div class="line"> </div><div class="line">/bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf &amp;</div><div class="line"> </div><div class="line"> </div><div class="line"># 如果是通过rpm包安装的logstash则可以使用自带的脚本启动</div><div class="line"> </div><div class="line">/etc/init.d/logstash start </div><div class="line"> </div><div class="line"># 通过这种方式启动，logstash会自动加载 /etc/logstash/conf.d/ 下的配置文件</div></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://tchuairen.blog.51cto.com/3848118/1840596/" target="_blank" rel="external">http://tchuairen.blog.51cto.com/3848118/1840596/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;h4 id=&quot;下载logstash&quot;&gt;&lt;a href=&quot;#下载logstash&quot; class=&quot;headerlink&quot; title=&quot;下载log
      
    
    </summary>
    
      <category term="大数据" scheme="http://quanke.name/categories/bdata/"/>
    
    
      <category term="logstash" scheme="http://quanke.name/tags/logstash/"/>
    
      <category term="elasticsearch" scheme="http://quanke.name/tags/elasticsearch/"/>
    
      <category term="mysql" scheme="http://quanke.name/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch5xx使用logstash同步mysql</title>
    <link href="http://quanke.name/posts/108/"/>
    <id>http://quanke.name/posts/108/</id>
    <published>2017-11-06T07:53:00.000Z</published>
    <updated>2018-02-02T15:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="下载logstash"><a href="#下载logstash" class="headerlink" title="下载logstash"></a>下载logstash</h4><p>下载地址：<a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">https://www.elastic.co/downloads/logstash</a></p><blockquote><p>当时我下载的是5.6.3版本</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">https://artifacts.elastic.co/downloads/logstash/logstash-5.6.3.tar.gz</div></pre></td></tr></table></figure><p>解压：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tar -zxvf logstash-5.6.3.tar.gz</div></pre></td></tr></table></figure></p><p>进入安装目录</p><p>运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">bin/logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos;</div></pre></td></tr></table></figure><p>等待几秒钟 出现  </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">The stdin plugin is now waiting for input:</div></pre></td></tr></table></figure><p>然后输入 </p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hello world</div></pre></td></tr></table></figure><p>得到类似的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2017-10-30T02:49:59.005Z test-env hello world</div></pre></td></tr></table></figure></p><h4 id="安装logstash-input-jdbc插件"><a href="#安装logstash-input-jdbc插件" class="headerlink" title="安装logstash-input-jdbc插件"></a>安装logstash-input-jdbc插件</h4><p>1.安装 ruby 和 rubygems（注意：需要 ruby 的版本在 1.8.7 以上）</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">yum install -y ruby rubygems</div></pre></td></tr></table></figure><p>检查 ruby 版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ruby -v</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ruby 1.8.7 (2013-06-27 patchlevel 374) [x86_64-linux]</div></pre></td></tr></table></figure><p>替换国内的镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources --remove http://rubygems.org/</div><div class="line">gem sources -a http://gems.ruby-china.org/</div></pre></td></tr></table></figure><p>验证是否成功</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources -l</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">*** CURRENT SOURCES ***</div><div class="line"></div><div class="line">http://rubygems.org/</div><div class="line">http://gems.ruby-china.org/</div></pre></td></tr></table></figure><p>修改Gemfile的数据源地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim Gemfile</div></pre></td></tr></table></figure><p>修改 source 的值 为： <code>&quot;https://gems.ruby-china.org/&quot;</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim  Gemfile.jruby-1.9.lock</div></pre></td></tr></table></figure><p>找到 remote 修改它的值为：<code>https://gems.ruby-china.org/</code></p><p>开始安装:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./bin/logstash-plugin install --no-verify  logstash-input-jdbc</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Installing logstash-input-jdbc</div><div class="line">Installation successful</div></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h4><p>最基本的配置文件定义，必须包含input 和 output。如果需要对数据进操作，则需要加上filter段</p><p>配置 java mysql 连接驱动 <code>mysql-connector-java-5.1.42-bin.jar</code> </p><p><a href="https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz" target="_blank" rel="external">https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">input &#123;</div><div class="line">  stdin &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  jdbc &#123;</div><div class="line">    jdbc_connection_string =&gt; &quot;jdbc:mysql://dbs1:3306/db2_utan_cs&quot;</div><div class="line">    jdbc_user =&gt; &quot;root&quot;</div><div class="line">    jdbc_password =&gt; &quot;123456&quot;</div><div class="line">    jdbc_driver_library =&gt; &quot;/data/arrow/logstash/mysql-connector-java-5.1.42-bin.jar&quot;</div><div class="line">    jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</div><div class="line">    jdbc_paging_enabled =&gt; &quot;true&quot;</div><div class="line">    jdbc_page_size =&gt; &quot;50000&quot;</div><div class="line">    statement =&gt; &quot;SELECT * FROM crawler_data WHERE id &gt; (SELECT MAX(t1.id) FROM db2_utan_cs.crawler_data AS t1)-70000 AND updatetime &gt; :sql_last_value&quot;</div><div class="line">    use_column_value =&gt; true</div><div class="line">    tracking_column =&gt; &quot;updatetime&quot;</div><div class="line">    schedule =&gt; &quot;* * * * *&quot;</div><div class="line">    type =&gt; &quot;baby_crawler&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">filter &#123;</div><div class="line">  mutate &#123;</div><div class="line">    remove_field =&gt; [ &quot;@timestamp&quot;, &quot;@version&quot;, &quot;id&quot; ]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line">output &#123;</div><div class="line">  elasticsearch &#123;</div><div class="line">    hosts =&gt; &quot;192.168.1.21:9201&quot;</div><div class="line">    index =&gt; &quot;baby_crawler_b&quot;</div><div class="line">    document_id =&gt; &quot;%&#123;uniquekey&#125;&quot;</div><div class="line">  &#125;</div><div class="line">  stdout &#123;</div><div class="line">    codec =&gt; json_lines</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line"># 通过手动指定配置文件启动</div><div class="line"> </div><div class="line">/bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf</div><div class="line"> </div><div class="line"># 以daemon方式运行，则在指令后面加一个 &amp; 符号</div><div class="line"> </div><div class="line">/bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf &amp;</div><div class="line"> </div><div class="line"> </div><div class="line"># 如果是通过rpm包安装的logstash则可以使用自带的脚本启动</div><div class="line"> </div><div class="line">/etc/init.d/logstash start </div><div class="line"> </div><div class="line"># 通过这种方式启动，logstash会自动加载 /etc/logstash/conf.d/ 下的配置文件</div></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://tchuairen.blog.51cto.com/3848118/1840596/" target="_blank" rel="external">http://tchuairen.blog.51cto.com/3848118/1840596/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;h4 id=&quot;下载logstash&quot;&gt;&lt;a href=&quot;#下载logstash&quot; class=&quot;headerlink&quot; title=&quot;下载log
      
    
    </summary>
    
      <category term="大数据" scheme="http://quanke.name/categories/bdata/"/>
    
    
      <category term="logstash" scheme="http://quanke.name/tags/logstash/"/>
    
      <category term="elasticsearch" scheme="http://quanke.name/tags/elasticsearch/"/>
    
      <category term="mysql" scheme="http://quanke.name/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>已有Android工程 集成React Native 的那些事</title>
    <link href="http://quanke.name/posts/27127/"/>
    <id>http://quanke.name/posts/27127/</id>
    <published>2017-02-28T15:03:00.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p>2017年2月27日，天气晴，我永远记得这天，我心潮澎湃，因为终于把<a href="http://utantop.com/" target="_blank" rel="external">优谈TOP</a> 集成了React Native，从去年开始，公司陆陆续续的集成和学习React Native，通过demo的形式，写了不少组件和API，也能和后端调通，也多次，多个人尝试把优谈TOP集成React Native，但是每次都是失败的，因为缺少经验，不能直接通过错误判断原因，只能通过Google查找各种资料，慢慢解决，下面记录了我们，<a href="http://utantop.com/" target="_blank" rel="external">优谈TOP</a> 原生 集成React Native 的那些事。也许也是你的那些事？</p><h3 id="常规思路："><a href="#常规思路：" class="headerlink" title="常规思路："></a>常规思路：</h3><p>通过百度搜索 <code>已有Android工程集成ReactNative</code> 出现一大堆教程，大部分教程都是通过在原来的基础上增加React Native的支持，比如这个：<a href="http://blog.csdn.net/jj120522/article/details/51982228" target="_blank" rel="external">《Android之原生项目集成React Native》</a> ，这也是官方推荐的集成方式，我也推荐这个，只是我这样，一直报错，有一个启动 MainaAtivity的错，一直过不去，所以我就换一种思路。。。</p><h3 id="在React-Native基础上增加原生"><a href="#在React-Native基础上增加原生" class="headerlink" title="在React Native基础上增加原生"></a>在React Native基础上增加原生</h3><p>开始通过<a href="http://facebook.github.io/react-native/docs/getting-started.html#content" target="_blank" rel="external">官方文档安装和初始化</a>React Native项目。</p><h4 id="创建和运行React-Native-项目"><a href="#创建和运行React-Native-项目" class="headerlink" title="创建和运行React Native 项目"></a>创建和运行React Native 项目</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">react-native init UtanTop</div><div class="line"></div><div class="line">cd UtanTop</div><div class="line"></div><div class="line">react-native run-android</div></pre></td></tr></table></figure><blockquote><p>如果没有错,再继续。如果有错，说明你环境都没有安装好，哈哈。请参考<a href="http://reactnative.cn/docs/0.41/getting-started.html" target="_blank" rel="external">环境安装文档</a></p></blockquote><p>恭喜你，第一步搞定了。接下来，巨坑的地方要来了。</p><h4 id="把原生的-build-gradle-文件先集成进去"><a href="#把原生的-build-gradle-文件先集成进去" class="headerlink" title="把原生的 build.gradle 文件先集成进去"></a>把原生的 <code>build.gradle</code> 文件先集成进去</h4><p>这一步比较简单，就是把<code>gradle</code>相关文件复制替换就可以了，你想的好简单哈。。。</p><p><strong>我建议：</strong></p><p>首先把原项目的gradle相关文件复制到新建的React Native项目，<em>不要破坏原来的React Native项目的配置</em>。</p><blockquote><p>如果原生项目里有Module，先不要把Module导入，为了保险，把最简单的导入。</p></blockquote><h5 id="修改Root-目录下的build-gradle"><a href="#修改Root-目录下的build-gradle" class="headerlink" title="修改Root 目录下的build.gradle"></a>修改Root 目录下的<code>build.gradle</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        mavenLocal()</div><div class="line">        jcenter()</div><div class="line">        maven &#123;</div><div class="line">            url &quot;http://192.168.1.205:8081/repository/utancenter/&quot;</div><div class="line">        &#125;</div><div class="line">        maven &#123;</div><div class="line">            // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm</div><div class="line">            url &quot;$rootDir/../node_modules/react-native/android&quot;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果有其他maven仓库直接这么写就可以了。</p><h5 id="配置app目录下的build-gradle"><a href="#配置app目录下的build-gradle" class="headerlink" title="配置app目录下的build.gradle"></a>配置app目录下的<code>build.gradle</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">buildTypes &#123;</div><div class="line"></div><div class="line"></div><div class="line">//        release &#123;</div><div class="line">//            // 不显示Log</div><div class="line">//            buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;</div><div class="line">//</div><div class="line">//            minifyEnabled enableProguardInReleaseBuilds</div><div class="line">//            zipAlignEnabled true</div><div class="line">//            shrinkResources true</div><div class="line">//            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-project.txt&apos;</div><div class="line">//            signingConfig signingConfigs.release</div><div class="line">//</div><div class="line">//            applicationVariants.all &#123; variant -&gt;</div><div class="line">//                variant.outputs.each &#123; output -&gt;</div><div class="line">//                    def outputFile = output.outputFile</div><div class="line">//                    if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123;</div><div class="line">//</div><div class="line">//                        //if (&quot;woman&quot;.equals(WOMAN))&#123;</div><div class="line">//                        //  def fileName = &quot;WomanTop_v$&#123;defaultConfig.versionName&#125;_$&#123;variant.productFlavors[0].name&#125;.apk&quot;</div><div class="line">//                        //output.outputFile = new File(outputFile.parent+File.separator+&quot;v&quot;+defaultConfig.versionName, fileName)</div><div class="line">//                        //&#125; else &#123;</div><div class="line">//                        def fileName = &quot;UtanTop_v$&#123;defaultConfig.versionName&#125;_$&#123;variant.productFlavors[0].name&#125;.apk&quot;</div><div class="line">//                        output.outputFile = new File(outputFile.parent + File.separator + &quot;v&quot; + defaultConfig.versionName, fileName)</div><div class="line">//                        //&#125;</div><div class="line">//</div><div class="line">//</div><div class="line">//                    &#125;</div><div class="line">//                &#125;</div><div class="line">//            &#125;</div><div class="line">//        &#125;</div><div class="line"></div><div class="line">        release &#123;</div><div class="line">            minifyEnabled enableProguardInReleaseBuilds</div><div class="line">            proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>贴这个的意思就是先把打渠道包的去掉，使用React Native生成的配置，之后打渠道包在说，记得把下面几段也要先注释掉。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">//    // 多渠道打包</div><div class="line">//    productFlavors &#123;</div><div class="line"></div><div class="line">//        T1 &#123;&#125;</div><div class="line">//        T2 &#123;&#125;</div><div class="line">//        T3 &#123;&#125;</div><div class="line">//</div><div class="line">//    &#125;</div><div class="line">//</div><div class="line">//    productFlavors.all &#123; flavor -&gt;</div><div class="line">//        flavor.manifestPlaceholders = [CHANNEL_VALUE: name]</div><div class="line">//    &#125;</div></pre></td></tr></table></figure><p>如果集成友盟的多渠道包，还需要在<code>AndroidManifest.xml</code>中注释掉。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;meta-data</div><div class="line">           android:name=&quot;UMENG_APPKEY&quot;</div><div class="line">           android:value=&quot;$&#123;UMENG_APPKEY&#125;&quot; /&gt;</div></pre></td></tr></table></figure><p>在这个时候我们还没集成源码，再执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">react-native run-android</div></pre></td></tr></table></figure><blockquote><p>如果编译通过，恭喜你，如果没有过那是正常的，因为还有一个坑。</p></blockquote><p>我的报错信息是</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">* What went wrong:</div><div class="line">Execution failed for task &apos;:app:packageAllDebugClassesForMultiDex&apos;.</div><div class="line">&gt; java.util.zip.ZipException: duplicate entry: bolts/AggregateException.class</div></pre></td></tr></table></figure><p>是因为导入了重复的条目。</p><blockquote><p>可能是在某些某些gradle版本才有吧。。。</p></blockquote><p>我的解决方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">compile(&apos;com.facebook.fresco:fresco:0.10.0&apos;) &#123;</div><div class="line">    exclude group: &apos;com.parse.bolts&apos;,</div><div class="line">            module: &apos;bolts-android&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">compile (&apos;com.facebook.fresco:animated-gif:0.10.0&apos;)&#123;</div><div class="line">    exclude group: &apos;com.parse.bolts&apos;,</div><div class="line">            module: &apos;bolts-android&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这时候再执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">react-native run-android</div></pre></td></tr></table></figure><p>现在问题应该不大了，按道理可以运行起来了，反正我的运行起来了，但是还没有加入源码。。。</p><h5 id="现在就把java-res-libs-assets-目录下的文件和-AndroidManifest-xml-复制到React-Native项目中。"><a href="#现在就把java-res-libs-assets-目录下的文件和-AndroidManifest-xml-复制到React-Native项目中。" class="headerlink" title="现在就把java res libs assets 目录下的文件和 AndroidManifest.xml 复制到React Native项目中。"></a>现在就把<code>java</code> <code>res</code> <code>libs</code> <code>assets</code> 目录下的文件和 <code>AndroidManifest.xml</code> 复制到React Native项目中。</h5><p>把<code>MainApplication</code> 集成你原生项目的<code>Application</code> </p><blockquote><p>一般项目都会自定一个<code>Application</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class MainApplication extends UtanToutiaoApp implements ReactApplication &#123;</div><div class="line"></div><div class="line">  private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123;</div><div class="line">    @Override</div><div class="line">    public boolean getUseDeveloperSupport() &#123;</div><div class="line">      return BuildConfig.DEBUG;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected List&lt;ReactPackage&gt; getPackages() &#123;</div><div class="line">      return Arrays.&lt;ReactPackage&gt;asList(</div><div class="line">          new MainReactPackage()</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public ReactNativeHost getReactNativeHost() &#123;</div><div class="line">    return mReactNativeHost;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void onCreate() &#123;</div><div class="line">    super.onCreate();</div><div class="line">    SoLoader.init(this, /* native exopackage */ false);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>注意：不要把<code>MainActivity</code> <code>MainApplication</code> ,文件覆盖了。</p></blockquote><p>再执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">react-native run-android</div></pre></td></tr></table></figure><p>应该可以成功了，如果默认启动的是<code>MainActivity</code>，那展示的就是React Native 界面，如果默认不是<code>MainActivity</code>，那就通过下面的方式启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">Intent i = new Intent(context, MainReactActivity.class);</div><div class="line">    </div><div class="line">context.startActivity(i);</div></pre></td></tr></table></figure><p>到这里我反正就ok了，不知道你ok了没？</p><p>如果不OK ，请留言，一起探讨。。</p><p>还有我在学习和使用React Native 之后也会贴出来供大伙参考。。请关注 quanke</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2017年2月27日，天气晴，我永远记得这天，我心潮澎湃，因为终于把&lt;a hr
      
    
    </summary>
    
      <category term="React Native" scheme="http://quanke.name/categories/rn/"/>
    
    
      <category term="React Native" scheme="http://quanke.name/tags/rn/"/>
    
      <category term="React" scheme="http://quanke.name/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包</title>
    <link href="http://quanke.name/posts/55306/"/>
    <id>http://quanke.name/posts/55306/</id>
    <published>2017-02-22T16:07:42.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><h1 id="Android-Gradle-相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包"><a href="#Android-Gradle-相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包" class="headerlink" title="Android Gradle 相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包"></a>Android Gradle 相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包</h1><p>简介：<br>公司的新需求：同一份代码打出另一个包名的apk，即包名不同、名称不同的两个apk。因为市场是识别包名的，所有可以相同的代码可以发布多个APP，以便于测试什么样的名字被用户接受（本人不太认同这种观点，这里只谈技术），可以在同一个手机同时安装测试包和发布包（大部分测试的接口地址与发布的接口地址是不一样的，还有一些公司还有开发的接口），方便测试</p><p>我经过多方渠道发现大致有一下三种方法：</p><ul><li><strong>通过ant打多包名应用</strong></li><li><strong>建立多个与“main”同级的文件夹，修改清单文件及build.gradle以达到打多包名效果</strong></li><li><strong>通过修改build.gradle文件的applicationId达到打多包名的效果，原理与第二种方法但比较简单</strong></li></ul><p>因为是新手，对ant并不太了解，原理也不太清楚，为了赶时间所以直接选择了第二种与第三种方法，经过测试发现第三种方法要更加简单的多，所以最后直接使用了第三种方法，以下为详解。</p><hr><p>因为要修改的是build.gradle文件而该文件一经修改就要重新编译，用过史丢丢的童鞋应该都清楚等待编译完成是是件多么蛋疼的事情所以建议大家一次性修改完成以便节约开发时间。</p><p>上面已经说过该方法主要是通过修改build.gradle文件的applicationId达到打多包名的效果的，下面便粘出本人代码供大家参考。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">      app_one &#123;</div><div class="line">          applicationId &quot;com.example.app1&quot;</div><div class="line">          manifestPlaceholders = [</div><div class="line">                  app_name:&quot;测试-1&quot;</div><div class="line">          ]</div><div class="line">      &#125;</div><div class="line">      app_two &#123;</div><div class="line">          applicationId &quot;com.example.app2&quot;</div><div class="line">          manifestPlaceholders = [</div><div class="line">                  app_name:&quot;测试-2&quot;</div><div class="line">          ]</div><div class="line">      &#125;</div><div class="line">      app_three &#123;</div><div class="line">          applicationId &quot;com.example.app3&quot;</div><div class="line">          manifestPlaceholders = [</div><div class="line">                  app_name:&quot;测试-3&quot;</div><div class="line">          ]</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>是不是感觉这个方法很眼熟？<br>没错就是多渠道打包的地方，通过添加这段代码后需要用到gradle面板进行打包，得到app_one 通过查看包名发现它的包名为 <code>com.example.app1</code> 显示的名称也为 <code>测试-1</code>，app_two 与 app_three 效果等同，至此已经完成多包名打包，且通过同一份代码打出了不同包名、不同名称的三个应用，而需求也达到了。</p><p>可能有的朋友会问如果还需要其他的渠道包怎么办，如果有10的渠道而又要打包两个不同的应用那岂不是要写20个类似于app_one的东西，那不是要很麻烦？没错我正好也碰到了这种情况，经过多次研究测试发现并没有那么麻烦，只需设定一个默认的包名、应用名即可，废话不多说，直接贴代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">       if (PACKAGE == &quot;one&quot;) &#123;</div><div class="line">           applicationId &quot;com.example.app1&quot;</div><div class="line">           manifestPlaceholders = [</div><div class="line">                   app_name:&quot;测试-1&quot;</div><div class="line">           ]</div><div class="line">       &#125; else &#123;</div><div class="line">           applicationId &quot;com.example.app2&quot;</div><div class="line">           manifestPlaceholders = [</div><div class="line">                   app_name:&quot;测试-2&quot;</div><div class="line">           ]</div><div class="line">       &#125;</div><div class="line">       minSdkVersion 14</div><div class="line">       targetSdkVersion 23</div><div class="line">       versionCode 1</div><div class="line">       versionName &quot;1.0&quot;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   buildTypes &#123;</div><div class="line">       release &#123;</div><div class="line">           minifyEnabled false</div><div class="line">           proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   productFlavors &#123;</div><div class="line">       app_one &#123;&#125;</div><div class="line">       app_two &#123;&#125;</div><div class="line">       app_three &#123;&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>嗯，就是这样，在defaultConfig里面设置一个默认的包名与应用名就可以了。</p><p>好了，到了这一步我们就要用到另一个神奇的文件了</p><p><img src="http://upload-images.jianshu.io/upload_images/432952-e297ef08da09dbd1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工程目录下配置文件"></p><p>看看你的工程根目录下得这个东西，没错就是它，这里我设置了一个字段“PACKAGE”，即告诉Studio我想要什么包，到这里相信大家也就明白我写的判断的目的了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">PACKAGE=one</div></pre></td></tr></table></figure><p>只要通过修改这一字段为“one”，然后通过打包后就可以得到三个“测试-1”的app_one、app_two、app_three的apk文件了，同理将其修改为其他字段即可打出其他包名、应用名的应用了。<br>但是转到本人公司项目后发现这种方法竟然失灵了，即修改 properties 文件内的字段后得不到我想要的包，经过探索发现可能是与项目工程的大小有关，改完重启后就可以了。<br>当然还有另一个最重要的地方</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    package=&quot;com.example.morepackagenametest&quot;&gt;</div><div class="line"></div><div class="line">    &lt;application</div><div class="line">        android:allowBackup=&quot;true&quot;</div><div class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</div><div class="line">        android:label=&quot;$&#123;app_name&#125;&quot;</div><div class="line">        android:supportsRtl=&quot;true&quot;</div><div class="line">        android:theme=&quot;@style/AppTheme&quot;&gt;</div><div class="line">        &lt;activity android:name=&quot;.MainActivity&quot;&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</div><div class="line"></div><div class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div><div class="line">    &lt;/application&gt;</div><div class="line"></div><div class="line">&lt;/manifest&gt;</div></pre></td></tr></table></figure><p>不同服务器地址以生成不同安装包方法类似，我这里不细说，有问题请留言</p><p>就是这里了，即之前定义的名字赋给应用了，在这里大家要注意一下在该项目的其他 model 内的清单文件里最好不要写  <code>android：label</code> 这句了，否则会报错的，至于是什么错一眼就可以看到了，当然如果报错了有两个方法：</p><ol><li>删掉其他 model 内清单文件下<code>application</code>的 <code>label</code> 属性</li><li>通过在 <code>application</code> 下添加 <code>tools:replace=&quot;android:label&quot;</code> 属性解决</li></ol><p>好了，打完收工。期待大神的批评指导。</p><ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p>此文同事编写，此后会增加不同服务器地址以生成不同安装包的demo</p><p>原文：<a href="http://blog.csdn.net/qq_33673284/article/details/52875696" target="_blank" rel="external">http://blog.csdn.net/qq_33673284/article/details/52875696</a></p><p>最后附上资源下载地址  <a href="http://download.csdn.net/detail/qq_33673284/9659262" target="_blank" rel="external">Android 多包名打包应用</a>  供各位参考</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Android-Gradle-相同应用多包名打包，实现测试发布包分离
      
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android/"/>
    
    
      <category term="Gradle" scheme="http://quanke.name/tags/Gradle/"/>
    
      <category term="Android多渠道打包" scheme="http://quanke.name/tags/android-pg/"/>
    
  </entry>
  
  <entry>
    <title>一个老司机工程师整理的自动化测试资料</title>
    <link href="http://quanke.name/posts/16982/"/>
    <id>http://quanke.name/posts/16982/</id>
    <published>2017-02-22T16:05:15.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><h4 id="Python教程"><a href="#Python教程" class="headerlink" title="Python教程"></a>Python教程</h4><hr><p><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000</a></p><h4 id="Appium："><a href="#Appium：" class="headerlink" title="Appium："></a>Appium：</h4><p><a href="http://appium.io/slate/en/master/#" target="_blank" rel="external">http://appium.io/slate/en/master/#</a></p><p>Appium 中文 Appium API 文档<br><a href="https://testerhome.com/topics/3144" target="_blank" rel="external">https://testerhome.com/topics/3144</a></p><p>Appium移动自动化测试（虫师写的系列，质量高）<br><a href="http://www.cnblogs.com/fnng/p/4540731.html" target="_blank" rel="external">http://www.cnblogs.com/fnng/p/4540731.html</a></p><p>Robot Framework +Appium的简单教程及实例<br><a href="http://blog.csdn.net/xyh421/article/details/52119872" target="_blank" rel="external">http://blog.csdn.net/xyh421/article/details/52119872</a></p><p>Python + Appium+ IOS自动化测试<br><a href="http://blog.csdn.net/temanm/article/details/49641133" target="_blank" rel="external">http://blog.csdn.net/temanm/article/details/49641133</a></p><p>Saucelabs+Java+TestNG+Appium+Maven+Git+Jenkins+ReportNG for Android 自动化测试<br><a href="http://blog.csdn.net/wanglin_lin/article/details/51931728" target="_blank" rel="external">http://blog.csdn.net/wanglin_lin/article/details/51931728</a></p><h4 id="Selenium-2"><a href="#Selenium-2" class="headerlink" title="Selenium 2"></a>Selenium 2</h4><hr><p>Selenium 2 入门<br><a href="http://www.ibm.com/developerworks/cn/web/wa-selenium2/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/web/wa-selenium2/</a></p><h4 id="Robot-Framework自动化测试"><a href="#Robot-Framework自动化测试" class="headerlink" title="Robot Framework自动化测试"></a>Robot Framework自动化测试</h4><hr><p>Robot Framework自动化测试（一）—第一个脚本<br><a href="http://www.cnblogs.com/fnng/p/3871712.html" target="_blank" rel="external">http://www.cnblogs.com/fnng/p/3871712.html</a></p><p>Robot Framework自动化测试 —视频与教程免费分享（里面有 <code>PDF</code> 质量非常高）<br><a href="http://www.cnblogs.com/fnng/p/4333977.html" target="_blank" rel="external">http://www.cnblogs.com/fnng/p/4333977.html</a></p><p>Jenkins+robotframework+svn持续集成环境配置<br><a href="http://lijunwei1228ok.blog.163.com/blog/static/97383797201407113453672/" target="_blank" rel="external">http://lijunwei1228ok.blog.163.com/blog/static/97383797201407113453672/</a></p><p>这个是一个程序员学习自动化测试的一个过程和资料，之后会有一些原创内容，欢迎关注</p><pre><code>如果你想零基础开始 从入门到精通 学习软件测试，建议花几块钱买视频教程</code></pre><p><a href="https://item.taobao.com/item.htm?id=544901106180" target="_blank" rel="external">https://item.taobao.com/item.htm?id=544901106180</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Python教程&quot;&gt;&lt;a href=&quot;#Python教程&quot; clas
      
    
    </summary>
    
      <category term="自动化测试" scheme="http://quanke.name/categories/autotest/"/>
    
    
      <category term="自动化测试" scheme="http://quanke.name/tags/autotest/"/>
    
      <category term="软件测试" scheme="http://quanke.name/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>APP版本管理SDK项目实战-准备篇</title>
    <link href="http://quanke.name/posts/47009/"/>
    <id>http://quanke.name/posts/47009/</id>
    <published>2016-10-26T12:42:19.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p>因为友盟APP版本管理服务关闭（这是官方通知：<a href="http://bbs.umeng.com/thread-14590-1-1.html" target="_blank" rel="external">http://bbs.umeng.com/thread-14590-1-1.html</a> ），我计划做一个类似友盟的APP版本管理的功能，开放SDK，方便大家使用，我会把开发过程的思路分享给大家。</p><h4 id="项目简介："><a href="#项目简介：" class="headerlink" title="项目简介："></a>项目简介：</h4><p>版本管理项目我觉得对于所有的APP都是需要的，前期希望能做到和友盟一样。支持自动更新、手动更新、静默更新、强制更新、断点续传、忽略版本，服务端开放RESTFul的API，支持WEB管理页面，文件存储对接七牛，之后会支持各种存储</p><p>整个项目会涉及到API设计、移动端SDK开发、服务端开发、服务器选型、我打算全部自己一个人搞定</p><p>API我打算采用RESTFul架构，使用swagger在线调试API，分别用POST、PUT、GET、DELETE方法对资源做CURD操作。使用RESTFul的难点在于如何定义好各种资源的表述，即URI的定义。</p><p>SDK开发则打算第一版只用原生实现，优先Android SDK开发，之后再开发IOS SDK。</p><p>服务端开发准备使用最经典的SSM，数据库使用最最最经典的MySQL。</p><p>WEB管理后台使用Bootstrap响应式后台管理系统meadmin模板</p><p>服务器先自己本地开发，之后考虑阿里云或者其他。</p><h4 id="功能需求整理："><a href="#功能需求整理：" class="headerlink" title="功能需求整理："></a>功能需求整理：</h4><h5 id="SDK"><a href="#SDK" class="headerlink" title="SDK:"></a>SDK:</h5><ul><li>自动更新</li><li>手动更新</li><li>静默更新</li><li>强制更新</li><li>断点续传</li><li>忽略版本</li></ul><h5 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h5><ul><li>web管理</li><li>七牛存储</li><li>多个APP管理</li><li>渠道包支持</li><li>统计</li></ul><h4 id="写在最后："><a href="#写在最后：" class="headerlink" title="写在最后："></a>写在最后：</h4><p>因为是SDK，管理使用模板，所以没有原型设计，功能确定好，就可以设计API了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为友盟APP版本管理服务关闭（这是官方通知：&lt;a href=&quot;http://
      
    
    </summary>
    
      <category term="项目实战" scheme="http://quanke.name/categories/project/"/>
    
    
      <category term="SDK" scheme="http://quanke.name/tags/SDK/"/>
    
      <category term="Android" scheme="http://quanke.name/tags/Android/"/>
    
      <category term="JavaEE" scheme="http://quanke.name/tags/JavaEE/"/>
    
      <category term="IOS" scheme="http://quanke.name/tags/IOS/"/>
    
      <category term="Spring Boot" scheme="http://quanke.name/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Android DownloadManager ERROR_UNKNOWN 在API 17 巨坑完美解决</title>
    <link href="http://quanke.name/posts/42104/"/>
    <id>http://quanke.name/posts/42104/</id>
    <published>2016-10-26T12:36:20.000Z</published>
    <updated>2018-01-31T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>欢迎关注<a href="http://quanke.name/">http://quanke.name/</a></li><li>转载请注明出处，谢谢</li></ul><p>现在做了一个下载，为了兼容性直接使用Android Sdk 自带的 <a href="https://developer.android.com/reference/android/app/DownloadManager.html" target="_blank" rel="external">DownloadManager</a> 开发，在其他手机上都是OK，只有在有一台vivo上不行。</p><p>我尝试使用vivo系统浏览器去下载这个链接，也是OK的，这个排除了网络问题和系统下载的bug的问题。</p><p>尝试去找错误给我返回一个<code>ERROR_UNKNOWN</code>,完全SB了，此路不通。</p><p>尝试换一个链接去下载，居然也是OK的，所以确定了是链接的问题，链接有什么问题？我对比了一下，除了下载失败链接里包含了中括号<code>[]</code>,其他也没有什么不一样的，所以我尝试着使用<code>%5B</code>、<code>%5D</code> 替换 <code>[]</code>,居然好了。这也太奇葩了吧。。。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">url = url.replace(&quot;[&quot;,&quot;%5B&quot;).replace(&quot;]&quot;,&quot;%5D&quot;);</div></pre></td></tr></table></figure><p>之后我去Google了一下，搞明白了，原来Android系统在18之前有这么一个问题，之后修复了。</p><p>最终解决：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(Build.VERSION.SDK_INT&lt;=Build.VERSION_CODES.JELLY_BEAN_MR2)&#123;</div><div class="line">            uri = uri.replace(&quot;[&quot;,&quot;%5B&quot;).replace(&quot;]&quot;,&quot;%5D&quot;);</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>参考：</p><p><a href="http://stackoverflow.com/questions/37976748/downloadmanager-fails-with-error-unknown-on-api-17" target="_blank" rel="external">http://stackoverflow.com/questions/37976748/downloadmanager-fails-with-error-unknown-on-api-17</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;欢迎关注&lt;a href=&quot;http://quanke.name/&quot;&gt;http://quanke.name/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;转载请注明出处，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在做了一个下载，为了兼容性直接使用Android Sdk 自带的 &lt;a hr
      
    
    </summary>
    
      <category term="android开发" scheme="http://quanke.name/categories/android/"/>
    
    
      <category term="android" scheme="http://quanke.name/tags/android/"/>
    
  </entry>
  
</feed>
