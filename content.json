{"meta":{"title":"全科-不安分的码农","subtitle":"android，ios，html5，微服务架构，XP，scrum，项目管理（PMP）","description":null,"author":"全科","url":"http://quanke.name"},"pages":[{"title":"全科的作品","date":"2015-05-08T07:55:21.000Z","updated":"2017-11-06T07:19:25.000Z","comments":true,"path":"app/index.html","permalink":"http://quanke.name/app/index.html","excerpt":"","text":"##拓拓 ###免费电话、虚拟社交 传送 ##最美创意 ###创意广告 传送 ##随口记语音记账 ###通过语音记账，使用语义识别，自动识别说的话 传送 ##inkNet（国内、泰国） ###上海汽车车联网平台，通过手机控制汽车 传送 ##上海汽车售后(国内、泰国) ###上海汽车售后服务平台 传送 ##喜马拉雅听车机APP ###上海汽车喜马拉雅车机APP，可以在汽车上听喜马拉雅所有资源 传送 ##搜狐违章车机APP ###上海汽车搜狐违章车机APP，可以在汽车上查询违章信息 传送 ##52面试 ###做面试习题的APP 传送 ##国诚金融 ###国诚金融P2P金融APP Android传送 ios传送 ##商铺云收银系统 ###移动收银系统 传送 ##驾驶模式 ###给车友打造的一个开车时语音播报微信、QQ消息的APP 传送 ##骑遇 ###骑行APP 传送"},{"title":"categories","date":"2016-07-22T14:03:10.000Z","updated":"2017-11-06T07:19:25.000Z","comments":false,"path":"categories/index.html","permalink":"http://quanke.name/categories/index.html","excerpt":"","text":""},{"title":"开源书籍","date":"2018-02-02T13:31:30.000Z","updated":"2018-02-02T15:24:44.000Z","comments":true,"path":"free-books/index.html","permalink":"http://quanke.name/free-books/index.html","excerpt":"","text":"Thinking in Java (Java 编程思想) 阅读地址：https://java.quanke.name"},{"title":"全科的开源项目","date":"2015-05-08T13:31:30.000Z","updated":"2017-11-06T07:19:25.000Z","comments":true,"path":"open-source/index.html","permalink":"http://quanke.name/open-source/index.html","excerpt":"","text":"##AFormChange ###AFormChange Android表单值修改框架 https://git.oschina.net/quanke/AFormChange ##AValidations Android表单验证框架 https://git.oschina.net/quanke/AValidations"},{"title":"标签","date":"2016-07-22T14:08:05.000Z","updated":"2017-11-06T07:19:25.000Z","comments":false,"path":"tags/index.html","permalink":"http://quanke.name/tags/index.html","excerpt":"","text":""},{"title":"《Spring Boot 与 kotlin 实战》","date":"2018-02-02T14:38:51.000Z","updated":"2018-02-03T15:04:45.000Z","comments":true,"path":"spring-boot-with-kotlin-in-action/index.html","permalink":"http://quanke.name/spring-boot-with-kotlin-in-action/index.html","excerpt":"","text":"我的第一个Kotlin应用 使用Spring Boot和Kotlin创建RESTfull API Spring Boot 与 kotlin 使用Thymeleaf模板引擎渲染web视图 Spring Boot 与 Kotlin 使用Freemarker模板引擎渲染web视图 Spring Boot 与 Kotlin Web应用的统一异常处理 Spring Boot 与 Kotlin 处理Web表单提交 Spring Boot 与 Kotlin 验证web表单信息 Spring Boot 与 Kotlin 上传文件 Spring Boot 与 Kotlin 使用JdbcTemplate连接MySQL Spring Boot 与 Kotlin 使用Spring-data-jpa简化数据访问层 Spring Boot 与 Kotlin 使用Redis数据库 Spring Boot 与 Kotlin 使用MongoDB数据库 Spring Boot 与 Kotlin 整合MyBatis Spring Boot 与 Kotlin 使用Spring Data Rest创建HAL风格Restful接口 Spring Boot 与 Kotlin 整合全文搜索引擎Elasticsearch Spring Boot 与 Kotlin 定时任务（Scheduling Tasks）"},{"title":"写一些小计划，监督自己","date":"2015-05-09T07:11:04.000Z","updated":"2017-11-06T07:19:25.000Z","comments":true,"path":"todo/index.html","permalink":"http://quanke.name/todo/index.html","excerpt":"","text":"#TODO 写一些小计划，监督自己 2015年7月11日 写LiveOak系列教程 2015-05-09 考PMP，把学习中的一些心得写出来 深入学习敏捷 学习微服务架构 如何敏捷创业"}],"posts":[{"title":"Spring Boot 与 Kotlin 定时任务（Scheduling Tasks）","slug":"kotlin/Spring-Boot-与-Kotlin-定时任务（Scheduling-Tasks）","date":"2018-02-03T14:58:06.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/30080/","link":"","permalink":"http://quanke.name/posts/30080/","excerpt":"","text":"在编写Spring Boot应用中会遇到这样的场景，比如：需要定时地发送一些短信、邮件之类的操作，也可能会定时地检查和监控一些标志、参数等。 创建定时任务在Spring Boot中编写定时任务是非常简单的事，下面通过实例介绍如何在Spring Boot中创建定时任务，实现每过5秒输出一下当前时间。 在Spring Boot的主类中加入@EnableScheduling注解，启用定时任务的配置 import org.springframework.boot.SpringApplicationimport org.springframework.boot.autoconfigure.SpringBootApplicationimport org.springframework.scheduling.annotation.EnableScheduling/** * Created by http://quanke.name on 2018/1/12. */@SpringBootApplication@EnableSchedulingclass Applicationfun main(args: Array&lt;String&gt;) &#123; SpringApplication.run(Application::class.java, *args)&#125; 创建定时任务实现类import org.apache.commons.logging.LogFactoryimport org.springframework.scheduling.annotation.Scheduledimport org.springframework.stereotype.Componentimport java.text.SimpleDateFormatimport java.util.*/** * Created by http://quanke.name on 2018/1/12. */@Componentclass ScheduledTasks &#123; val log = LogFactory.getLog(ScheduledTasks::class.java)!! private val dateFormat = SimpleDateFormat(&quot;HH:mm:ss&quot;) @Scheduled(fixedRate = 1000) fun reportCurrentTime() &#123; log.info(&quot;现在时间 , $&#123;dateFormat.format(Date())&#125;&quot;) &#125;&#125; 运行程序，控制台中可以看到类似如下输出，定时任务开始正常运作了。 2018-01-21 23:09:01.112 INFO 23832 --- [ main] n.q.kotlin.chaper11_8_1.ApplicationKt : Started ApplicationKt in 8.024 seconds (JVM running for 8.724)2018-01-21 23:09:02.112 INFO 23832 --- [pool-2-thread-1] n.q.k.chaper11_8_1.task.ScheduledTasks : 现在时间 , 23:09:022018-01-21 23:09:03.042 INFO 23832 --- [pool-2-thread-1] n.q.k.chaper11_8_1.task.ScheduledTasks : 现在时间 , 23:09:032018-01-21 23:09:04.042 INFO 23832 --- [pool-2-thread-1] n.q.k.chaper11_8_1.task.ScheduledTasks : 现在时间 , 23:09:042018-01-21 23:09:05.042 INFO 23832 --- [pool-2-thread-1] n.q.k.chaper11_8_1.task.ScheduledTasks : 现在时间 , 23:09:05 @Scheduled详解在上面的入门例子中，使用了@Scheduled(fixedRate = 1000) 注解来定义每过1秒执行的任务，对于@Scheduled的使用可以总结如下几种方式： @Scheduled(fixedRate = 1000) ：上一次开始执行时间点之后1秒再执行 @Scheduled(fixedDelay = 1000) ：上一次执行完毕时间点之后1秒再执行 @Scheduled(initialDelay=1000, fixedRate=5000) ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次 @Scheduled(cron=”/1 “) ：通过cron表达式定义规则 @Scheduled 注解是单线程的，如果需要多线程，请增加@Async 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot与Kotlin  整合全文搜索引擎Elasticsearch","slug":"kotlin/Spring-Boot与Kotlin-整合全文搜索引擎Elasticsearch","date":"2018-02-03T14:57:38.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/17411/","link":"","permalink":"http://quanke.name/posts/17411/","excerpt":"","text":"Elasticsearch 在全文搜索里面基本是无敌的，在大数据里面也很有建树，完全可以当nosql（本来也是nosql）使用。 这篇文章简单介绍Spring Boot使用Kotlin语言连接操作 Elasticsearch。但是不会做很详细的介绍，如果要深入了解Elasticsearch在Java/kotlin中的使用，请参考我之前编写的《Elasticsearch Java API 手册》 https://gitee.com/quanke/elasticsearch-java/ 里面包含使用实例，包含我们使用踩过的坑。 如果完全不了解Elasticsearch请先了解，安装好Elasticsearch服务 有多种方式连接Elasticsearch Spring Data Elasticsearch elasticsearch Java client 其他第三方库 需要注意的是，如果使用Spring Data Elasticsearch，spring boot 1.5++版本的不支持最新版本的elasticsearch。 下面是spring data elasticsearch 和elasticsearch对应的版本 spring data elasticsearch elasticsearch 3.0.0.RC2 5.5.0 3.0.0.M4 5.4.0 2.0.4.RELEASE 2.4.0 2.0.0.RELEASE 2.2.0 1.4.0.M1 1.7.3 1.3.0.RELEASE 1.5.2 1.2.0.RELEASE 1.4.4 1.1.0.RELEASE 1.3.2 1.0.0.RELEASE 1.1.1 我们使用的Elasticsearch版本是5.5.6，spring boot 使用的版本是1.5.6 而且支持Elasticsearch5.0以上的版本的spring data elasticsearch还不是RELEASE版本，所有我们采用的是elasticsearch Java client的方式,但是现在官方推荐更好的方式可以参考我写的《Elasticsearch Java Rest API 手册》 https://gitee.com/quanke/elasticsearch-java-rest，但是这篇文章还是使用`elasticsearch Java client` 构建Spring Boot Kotlin 项目 如果构建项目有问题的您，可以参考我之前的文章《使用Spring Boot和Kotlin创建RESTfull API》 使用Gradle构建,在build.gradle文件中添加 dependencies &#123; compile &quot;org.elasticsearch:elasticsearch:$elasticsearch_version&quot; compile &quot;org.elasticsearch.client:transport:$elasticsearch_version&quot;&#125; 完整的build.gradle文件 group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; ext.springfox_swagger2_version = &apos;2.7.0&apos; ext.mysql_version = &apos;5.1.21&apos; ext.mybatis_version = &apos;1.1.1&apos; ext.elasticsearch_version = &apos;5.5.1&apos; ext.fastjson_version = &apos;1.2.7&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;apply plugin: &quot;kotlin-jpa&quot; //https://stackoverflow.com/questions/32038177/kotlin-with-jpa-default-constructor-helljar &#123; baseName = &apos;chapter11-6-8-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile(&quot;org.jetbrains.kotlin:kotlin-reflect:$&#123;kotlin_version&#125;&quot;) compile &quot;org.springframework.boot:spring-boot-starter-web:$spring_boot_version&quot; compile &quot;org.elasticsearch:elasticsearch:$elasticsearch_version&quot; compile &quot;org.elasticsearch.client:transport:$elasticsearch_version&quot; compile &quot;com.alibaba:fastjson:$fastjson_version&quot; compile &quot;org.apache.commons:commons-lang3:3.6&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 先写测试基类ElasticsearchClient import com.alibaba.fastjson.JSONimport com.alibaba.fastjson.serializer.SerializerFeatureimport org.elasticsearch.action.search.SearchResponseimport org.elasticsearch.client.transport.TransportClientimport org.elasticsearch.common.settings.Settingsimport org.elasticsearch.common.transport.InetSocketTransportAddressimport org.elasticsearch.transport.client.PreBuiltTransportClientimport org.junit.Afterimport org.junit.Beforeimport java.net.InetAddress/** * Elasticsearch 5.5.1 的client 和 ElasticsearchTemplate的初始化 * 作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。 * Created by http://quanke.name on 2017/11/10. */open class ElasticsearchClient &#123; protected var client: TransportClient? = null @Before @Throws(Exception::class) fun setUp() &#123; val esSettings = Settings.builder() .put(&quot;cluster.name&quot;, &quot;utan-es&quot;) //设置ES实例的名称 .put(&quot;client.transport.sniff&quot;, true) //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中 .build() /** * 这里的连接方式指的是没有安装x-pack插件,如果安装了x-pack则参考 [ElasticsearchXPackClient] * 1. java客户端的方式是以tcp协议在9300端口上进行通信 * 2. http客户端的方式是以http协议在9200端口上进行通信 */ client = PreBuiltTransportClient(esSettings) .addTransportAddress(InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300)) println(&quot;ElasticsearchClient 连接成功&quot;) &#125; @After @Throws(Exception::class) fun tearDown() &#123; if (client != null) &#123; client!!.close() &#125; &#125; protected fun println(searchResponse: SearchResponse) &#123; val searchHits = searchResponse.hits.hits for (searchHit in searchHits) &#123; println(JSON.toJSONString(searchHit.source, SerializerFeature.PrettyFormat)) &#125; &#125;&#125; 运行单元测试 import org.elasticsearch.index.query.QueryBuilders.matchAllQueryimport org.junit.Testimport org.junit.runner.RunWithimport org.springframework.boot.test.context.SpringBootTestimport org.springframework.test.context.junit4.SpringRunner/** * Created by http://quanke.name on 2018/1/9. */@RunWith(SpringRunner::class)@SpringBootTestclass ApplicationTests : ElasticsearchClient() &#123; @Test fun `es test&quot;`() &#123; val qb = matchAllQuery() val response = client!!.prepareSearch(&quot;twitter&quot;)//可以是多个index .setTypes(&quot;tweet&quot;)//可以是多个类型 .setQuery(qb) // Query 查询条件 .get() println(response) &#125;&#125; 我们写了一个dayu-spring-boot-starter-es ,有机会开源出来 更多Spring Boot 和 kotlin相关内容 欢迎关注《Spring Boot 与 kotlin 实战》 参考 https://gitee.com/quanke/elasticsearch-java-rest https://gitee.com/quanke/elasticsearch-java 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot与Kotlin使用Spring Data Rest创建HAL风格Restful接口","slug":"kotlin/Spring-Boot与Kotlin使用Spring-Data-Rest创建HAL风格Restful接口","date":"2018-02-03T14:57:06.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/42854/","link":"","permalink":"http://quanke.name/posts/42854/","excerpt":"","text":"REST web服务已成为在web上应用程序集成的首选方式。在其核心中，REST定义了系统由客户端交互的资源组成。这些资源以超媒体驱动的方式实现。Spring MVC为构建这些服务提供了坚实的基础。但是，对于多域对象系统，即使实施REST web服务的最简单原则也可能相当乏味，并且导致大量样板代码。 Spring Data REST构建在Spring Data repositories之上，并自动将其导出为REST资源。它利用超媒体来允许客户端查找存储库暴露的功能，并将这些资源自动集成到相关的超媒体功能中。 根据model，生成HAL风格的restful API 根据model，维护实体之间的关系 支持分页 允许动态地过滤集合资源 允许通过处理Spring ApplicationEvents处理REST请求。 目前支持JPA，MongoDB，Neo4j，Solr，Cassandra，Gemfire。 支持自定义 将Spring Data REST添加到Spring Boot项目dependencies &#123; ... compile &quot;org.springframework.boot:spring-boot-starter-data-rest:$spring_boot_version&quot; ...&#125; 完整的build.gradle文件 group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; ext.springfox_swagger2_version = &apos;2.7.0&apos; ext.mysql_version = &apos;5.1.21&apos; ext.mybatis_version = &apos;1.1.1&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;apply plugin: &quot;kotlin-jpa&quot; //https://stackoverflow.com/questions/32038177/kotlin-with-jpa-default-constructor-helljar &#123; baseName = &apos;chapter11-6-7-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile(&quot;org.jetbrains.kotlin:kotlin-reflect:$&#123;kotlin_version&#125;&quot;) compile &quot;org.springframework.boot:spring-boot-starter-data-jpa:$spring_boot_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-data-rest:$spring_boot_version&quot; compile &quot;mysql:mysql-connector-java:$mysql_version&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 创建对象Userimport javax.persistence.*/** * Created by http://quanke.name on 2018/1/10. */@Entitydata class User( @Id @GeneratedValue(strategy = GenerationType.AUTO) var id: Long = -1, @Column(nullable = false) var username: String = &quot;&quot;, var password: String = &quot;&quot;) 创建UserRepository 增加@RepositoryRestResource注解 关于@RepositoryRestResource详细的使用介绍，请参考： https://springcloud.cc/spring-data-rest-zhcn.html import name.quanke.kotlin.chaper11_6_7.entity.Userimport org.springframework.data.jpa.repository.JpaRepositoryimport org.springframework.data.jpa.repository.Queryimport org.springframework.data.repository.query.Paramimport org.springframework.data.rest.core.annotation.RepositoryRestResource@RepositoryRestResource(path=&quot;user&quot;)interface UserRepository : JpaRepository&lt;User, Long&gt; &#123; fun findByUsername(username: String): List&lt;User&gt; fun findByUsernameAndPassword(username: String, password: String?): User @Query(&quot;from User u where u.username=:username&quot;) fun findUser(@Param(&quot;username&quot;) username: String): User&#125; 配置在application.yml文件中增加spring: datasource: url: jdbc:mysql://localhost:3306/test username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver 启动import org.springframework.boot.SpringApplicationimport org.springframework.boot.autoconfigure.SpringBootApplication/** * Created by http://quanke.name on 2018/1/9. *///参考：http://blog.csdn.net/soul_code/article/details/54108105@SpringBootApplicationclass Applicationfun main(args: Array&lt;String&gt;) &#123; SpringApplication.run(Application::class.java, *args)&#125; 测试访问 127.0.0.1:8080/user 返回：&#123; &quot;_embedded&quot;: &#123; &quot;users&quot;: [ &#123; &quot;username&quot;: &quot;http://gof.quanke.name&quot;, &quot;password&quot;: &quot;1111&quot;, &quot;_links&quot;: &#123; &quot;self&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/73&quot; &#125;, &quot;user&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/73&quot; &#125; &#125; &#125;, &#123; &quot;username&quot;: &quot;java.quanke.name&quot;, &quot;password&quot;: &quot;12&quot;, &quot;_links&quot;: &#123; &quot;self&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/74&quot; &#125;, &quot;user&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/74&quot; &#125; &#125; &#125;, &#123; &quot;username&quot;: &quot;test.quanke.name&quot;, &quot;password&quot;: &quot;aa&quot;, &quot;_links&quot;: &#123; &quot;self&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/75&quot; &#125;, &quot;user&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/75&quot; &#125; &#125; &#125;, &#123; &quot;username&quot;: &quot;es.quanke.name&quot;, &quot;password&quot;: &quot;12&quot;, &quot;_links&quot;: &#123; &quot;self&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/76&quot; &#125;, &quot;user&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/76&quot; &#125; &#125; &#125;, &#123; &quot;username&quot;: &quot;as.quanke.name&quot;, &quot;password&quot;: &quot;12&quot;, &quot;_links&quot;: &#123; &quot;self&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/77&quot; &#125;, &quot;user&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/77&quot; &#125; &#125; &#125;, &#123; &quot;username&quot;: &quot;vertx.quanke.name&quot;, &quot;password&quot;: &quot;12&quot;, &quot;_links&quot;: &#123; &quot;self&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/78&quot; &#125;, &quot;user&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/78&quot; &#125; &#125; &#125; ] &#125;, &quot;_links&quot;: &#123; &quot;self&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user&#123;?page,size,sort&#125;&quot;, &quot;templated&quot;: true &#125;, &quot;profile&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/profile/user&quot; &#125;, &quot;search&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/search&quot; &#125; &#125;, &quot;page&quot;: &#123; &quot;size&quot;: 20, &quot;totalElements&quot;: 6, &quot;totalPages&quot;: 1, &quot;number&quot;: 0 &#125;&#125; 访问 127.0.0.1:8083/user/73 注意： 73 是user id 根据自己的实际情况测试 返回： &#123; &quot;username&quot;: &quot;http://gof.quanke.name&quot;, &quot;password&quot;: &quot;1111&quot;, &quot;_links&quot;: &#123; &quot;self&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/73&quot; &#125;, &quot;user&quot;: &#123; &quot;href&quot;: &quot;http://127.0.0.1:8083/user/73&quot; &#125; &#125;&#125; Spring Data REST 能做的事情很多，这篇文章先介绍到这里，先在这里埋个坑，之后会出更加详细的文章说Spring Data REST。 参考 https://springcloud.cc/spring-data-rest-zhcn.html https://www.jianshu.com/p/84f2bbffb885 https://www.cnblogs.com/aguncn/p/6762392.html http://blog.csdn.net/soul_code/article/details/54108105 https://github.com/spring-projects/spring-data-examples/tree/master/rest 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 Kotlin 整合MyBatis","slug":"kotlin/Spring-Boot-与-Kotlin-整合MyBatis","date":"2018-02-03T14:55:38.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/45445/","link":"","permalink":"http://quanke.name/posts/45445/","excerpt":"","text":"最近使用jpa比较多，再看看mybatis的xml方式写sql觉得不爽，接口定义与映射离散在不同文件中，使得阅读起来并不是特别方便。 因此使用Spring Boot去整合MyBatis，在注解里写sql 参考《我的第一个Kotlin应用》 创建项目，在build.gradle文件中引入依赖compile &quot;org.mybatis.spring.boot:mybatis-spring-boot-starter:$mybatis_version&quot;compile &quot;mysql:mysql-connector-java:$mysql_version&quot; 完整的build.gradle文件 group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; ext.springfox_swagger2_version = &apos;2.7.0&apos; ext.mysql_version = &apos;5.1.21&apos; ext.mybatis_version = &apos;1.1.1&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;apply plugin: &quot;kotlin-jpa&quot; //https://stackoverflow.com/questions/32038177/kotlin-with-jpa-default-constructor-helljar &#123; baseName = &apos;chapter11-6-5-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile(&quot;org.jetbrains.kotlin:kotlin-reflect:$&#123;kotlin_version&#125;&quot;) compile &quot;org.mybatis.spring.boot:mybatis-spring-boot-starter:$mybatis_version&quot; compile &quot;mysql:mysql-connector-java:$mysql_version&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 在application.yml文件中配置mysql的连接spring: datasource: url: jdbc:mysql://localhost:3306/test username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver 使用MyBatis在Mysql中创建User表，包含id(BIGINT)、username(VARCHAR)、age(INT)字段。同时，创建映射对象User data class User(var id: Long? = -1, var username: String = &quot;&quot;, val age: Int? = 0) 创建User映射的操作UserMapper，为了后续单元测试验证，实现插入和查询操作 import name.quanke.kotlin.chaper11_6_5.entity.Userimport org.apache.ibatis.annotations.Insertimport org.apache.ibatis.annotations.Mapperimport org.apache.ibatis.annotations.Paramimport org.apache.ibatis.annotations.Select/** * Created by http://quanke.name on 2018/1/11. */@Mapperinterface UserMapper &#123; @Select(&quot;SELECT * FROM USER WHERE USERNAME = #&#123;username&#125;&quot;) fun findByUserName(@Param(&quot;username&quot;) username: String): List&lt;User&gt; @Insert(&quot;INSERT INTO USER(USERNAME, PASSWORD) VALUES(#&#123;username&#125;, #&#123;password&#125;)&quot;) fun insert(@Param(&quot;username&quot;) username: String, @Param(&quot;password&quot;) password: String): Int&#125; 启动 Spring Boot 类import org.springframework.boot.SpringApplicationimport org.springframework.boot.autoconfigure.SpringBootApplication/** * Created by http://quanke.name on 2018/1/9. */@SpringBootApplicationclass Applicationfun main(args: Array&lt;String&gt;) &#123; SpringApplication.run(Application::class.java, *args)&#125; 单元测试import name.quanke.kotlin.chaper11_6_5.repository.UserMapperimport org.apache.commons.logging.LogFactoryimport org.junit.Testimport org.junit.runner.RunWithimport org.springframework.boot.test.context.SpringBootTestimport org.springframework.test.context.junit4.SpringRunnerimport javax.annotation.Resource/** * Created by http://quanke.name on 2018/1/9. */@RunWith(SpringRunner::class)@SpringBootTestclass ApplicationTests &#123; val log = LogFactory.getLog(ApplicationTests::class.java)!! @Resource lateinit var userMapper: UserMapper @Test fun `MyBatis test&quot;`() &#123; log.info(&quot;查询用户名为【quanke.name】的用户：$&#123;userMapper.findByUserName(&quot;quanke.name&quot;)&#125;&quot;) userMapper.insert(&quot;quanke&quot;, &quot;123&quot;) log.info(&quot;查询用户名为【quanke】的用户：$&#123;userMapper.findByUserName(&quot;quanke&quot;)&#125;&quot;) &#125;&#125; 参考 http://www.mybatis.org/mybatis-3/zh/configuration.html#properties 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 Kotlin 使用MongoDB数据库","slug":"kotlin/Spring-Boot-与-Kotlin-使用MongoDB数据库","date":"2018-02-03T14:55:05.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/17896/","link":"","permalink":"http://quanke.name/posts/17896/","excerpt":"","text":"我们在产品中用到NoSQL数据库MongoDB。 下面就来简单介绍一下MongoDB，并且通过一个例子来介绍Spring Boot中对MongoDB访问的配置和使用。 MongoDB简介MongoDB是一个基于分布式文件存储的数据库，它是一个介于关系数据库和非关系数据库之间的产品，其主要目标是在键/值存储方式（提供了高性能和高度伸缩性）和传统的RDBMS系统（具有丰富的功能）之间架起一座桥梁，它集两者的优势于一身。 MongoDB支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型，也因为他的存储格式也使得它所存储的数据在Nodejs程序应用中使用非常流畅。 既然称为NoSQL数据库，Mongo的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 但是，MongoDB也不是万能的，同MySQL等关系型数据库相比，它们在针对不同的数据类型和事务要求上都存在自己独特的优势。在数据存储的选择中，坚持多样化原则，选择更好更经济的方式，而不是自上而下的统一化。 较常见的，我们可以直接用MongoDB来存储键值对类型的数据，如：验证码、Session等；由于MongoDB的横向扩展能力，也可以用来存储数据规模会在未来变的非常巨大的数据，如：日志、评论等；由于MongoDB存储数据的弱类型，也可以用来存储一些多变json数据，如：与外系统交互时经常变化的JSON报文。而对于一些对数据有复杂的高事务性要求的操作，如：账户交易等就不适合使用MongoDB来存储。 MongoDB官网 访问MongoDB在Spring Boot中，对如此受欢迎的MongoDB，同样提供了自配置功能。 引入依赖Spring Boot中可以通过在pom.xml中加入spring-boot-starter-data-mongodb引入对mongodb的访问支持依赖。它的实现依赖spring-data-mongodb。是的，您没有看错，又是spring-data的子项目，之前介绍过spring-data-jpa、spring-data-redis，对于mongodb的访问，spring-data也提供了强大的支持，下面就开始动手试试吧。 compile &quot;org.springframework.boot:spring-boot-starter-data-mongodb:$spring_boot_version&quot; 完整build.gradle group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; ext.springfox_swagger2_version = &apos;2.7.0&apos; ext.mysql_version = &apos;5.1.21&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;apply plugin: &quot;kotlin-jpa&quot; //https://stackoverflow.com/questions/32038177/kotlin-with-jpa-default-constructor-helljar &#123; baseName = &apos;chapter11-6-4-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile(&quot;org.jetbrains.kotlin:kotlin-reflect:$&#123;kotlin_version&#125;&quot;) compile &quot;org.springframework.boot:spring-boot-starter-web:$spring_boot_version&quot;// compile &quot;org.springframework.boot:spring-boot-starter-data-jpa:$spring_boot_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-data-mongodb:$spring_boot_version&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 快速开始使用Spring-data-mongodb若MongoDB的安装配置采用默认端口，那么在自动配置的情况下，我们不需要做任何参数配置，就能马上连接上本地的MongoDB。下面直接使用spring-data-mongodb来尝试对mongodb的存取操作。（记得mongod启动您的mongodb） 创建要存储的User实体，包含属性：id、username、age import org.springframework.data.annotation.Idimport org.springframework.data.mongodb.core.mapping.Document@Documentdata class User(@Id var id: Long? = -1, var username: String = &quot;&quot;, val age: Int? = 0) 实现User的数据访问对象：UserRepositoryimport name.quanke.kotlin.chaper11_6_4.entity.Userimport org.springframework.data.mongodb.repository.MongoRepositoryimport org.springframework.stereotype.Repository/** * Created by http://quanke.name on 2018/1/11. */@Repositoryinterface UserRepository : MongoRepository&lt;User, Long&gt; &#123; fun findByUsername(username: String): User&#125; 通过上面的例子，我们可以轻而易举的对MongoDB进行访问，但是实战中，应用服务器与MongoDB通常不会部署于同一台设备之上，这样就无法使用自动化的本地配置来进行使用。这个时候，我们也可以方便的配置来完成支持，只需要在application.properties中加入mongodb服务端的相关配置，具体示例如下： 参数配置在application.yml文件中增加spring: data: mongodb: uri: mongodb://192.168.2.53:27017/test 在尝试此配置时，记得在mongo中对test库创建具备读写权限的用户（用户名为name，密码为pass），不同版本的用户创建语句不同，注意查看文档做好准备工作 若使用mongodb 2.x，也可以通过如下参数配置，该方式不支持mongodb 3.x。 spring: data: mongodb: host: mongodb:localhost spring.data.mongodb.port=27017 单元测试import name.quanke.kotlin.chaper11_6_4.entity.Userimport name.quanke.kotlin.chaper11_6_4.repository.UserRepositoryimport org.apache.commons.logging.LogFactoryimport org.junit.Testimport org.junit.runner.RunWithimport org.springframework.beans.factory.annotation.Autowiredimport org.springframework.boot.test.context.SpringBootTestimport org.springframework.test.context.junit4.SpringRunner/** * Created by http://quanke.name on 2018/1/9. */@RunWith(SpringRunner::class)@SpringBootTestclass ApplicationTests &#123; val log = LogFactory.getLog(ApplicationTests::class.java)!! @Autowired lateinit var userRepository: UserRepository @Test fun `redis string test&quot;`() &#123; userRepository.save(User(1L, &quot;quanke&quot;, 30)) userRepository.save(User(2L, &quot;quanke.name&quot;, 40)) log.info(&quot;数据总条数：$&#123;userRepository.count()&#125;&quot;) log.info(&quot;用户名字为 quanke : $&#123;userRepository.findByUsername(&quot;quanke&quot;)&#125;&quot;) &#125;&#125; 参考 https://spring.io/guides/gs/accessing-data-mongodb/ http://blog.didispace.com/springbootmongodb/ 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 Kotlin 使用Redis数据库","slug":"kotlin/Spring-Boot-与-Kotlin-使用Redis数据库","date":"2018-02-03T14:54:26.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/59946/","link":"","permalink":"http://quanke.name/posts/59946/","excerpt":"","text":"Spring Boot中除了对常用的关系型数据库提供了优秀的自动化支持之外，对于很多NoSQL数据库一样提供了自动化配置的支持，包括：Redis, MongoDB, Elasticsearch, Solr和Cassandra。 使用RedisRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。 Redis官网 Redis中文社区 引入依赖Spring Boot提供的数据访问框架Spring Data Redis基于Jedis。可以通过引入spring-boot-starter-data-redis来配置依赖关系。 compile &quot;org.springframework.boot:spring-boot-starter-data-redis:$spring_boot_version&quot; 注意：spring boot 1.4 以后改名叫spring-boot-starter-data-redis 1.4之前使用 spring-boot-starter-redis 用kotlin，需要增加一个插件 apply plugin: &quot;kotlin-jpa&quot; //https://stackoverflow.com/questions/32038177/kotlin-with-jpa-default-constructor-hell 完整的build.gradle文件 group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; ext.springfox_swagger2_version = &apos;2.7.0&apos; ext.mysql_version = &apos;5.1.21&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;apply plugin: &quot;kotlin-jpa&quot; //https://stackoverflow.com/questions/32038177/kotlin-with-jpa-default-constructor-helljar &#123; baseName = &apos;chapter11-6-3-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile(&quot;org.jetbrains.kotlin:kotlin-reflect:$&#123;kotlin_version&#125;&quot;) compile &quot;org.springframework.boot:spring-boot-starter-web:$spring_boot_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-data-redis:$spring_boot_version&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 参数配置按照惯例在application.yml中加入Redis服务端的相关配置，具体说明如下： spring: redis: database: 2 host: 192.168.1.29 port: 6379 其中spring.redis.database的配置通常使用0即可，Redis在配置的时候可以设置数据库数量，默认为16，可以理解为数据库的schema 测试使用上面的配置就可以了 spring: redis: database: 2 # Redis数据库索引（默认为0） host: 192.168.1.29 port: 6379 # Redis服务器连接端口 password: 123456 # Redis服务器连接密码（默认为空） pool: max-active: 8 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 8 # 连接池中的最大空闲连接 min-idle: 0 # 连接池中的最小空闲连接 timeout: 0 # 连接超时时间（毫秒） 创建User实体类 import java.io.Serializabledata class User(val username: String, val age: Int?) : Serializable 测试访问通过编写测试用例，举例说明如何访问Redis。 import name.quanke.kotlin.chaper11_6_3.entity.Userimport org.apache.commons.logging.LogFactoryimport org.junit.Testimport org.junit.runner.RunWithimport org.springframework.boot.test.context.SpringBootTestimport org.springframework.data.redis.core.RedisTemplateimport org.springframework.data.redis.core.StringRedisTemplateimport org.springframework.test.context.junit4.SpringRunnerimport javax.annotation.Resource/** * Created by http://quanke.name on 2018/1/9. */@RunWith(SpringRunner::class)@SpringBootTestclass ApplicationTests &#123; val log = LogFactory.getLog(ApplicationTests::class.java)!! @Resource lateinit var stringRedisTemplate: StringRedisTemplate @Resource lateinit var redisTemplate: RedisTemplate&lt;String, User&gt; @Test fun `redis string test&quot;`() &#123; // 保存字符串 stringRedisTemplate.opsForValue().set(&quot;url&quot;, &quot;http://quanke.name&quot;) log.info(&quot;全科的博客地址: $&#123;stringRedisTemplate.opsForValue().get(&quot;url&quot;)&#125;&quot;) &#125; @Test fun `redis object test&quot;`() &#123; // 保存对象 val user = User(&quot;超人&quot;, 20) redisTemplate.opsForValue().set(user.username, user) log.info(&quot;超人的年龄：$&#123;redisTemplate.opsForValue().get(&quot;超人&quot;).age&#125;&quot;) &#125;&#125; 当然spring-boot-starter-data-redis中提供的数据操作远不止这些，本文仅作为在Spring Boot中使用redis时的配置参考，更多对于redis的操作使用，请参考 Spring Data Redis Reference 。 参考 https://spring.io/guides/gs/messaging-redis/ http://blog.didispace.com/springbootredis/ 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 Kotlin使用Spring-data-jpa简化数据访问层","slug":"kotlin/Spring-Boot-与-Kotlin使用Spring-data-jpa简化数据访问层","date":"2018-02-03T14:53:46.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/49275/","link":"","permalink":"http://quanke.name/posts/49275/","excerpt":"","text":"在《Spring Boot 与 Kotlin 使用JdbcTemplate连接MySQL》 中介绍了一种基本的数据访问方式，结合构建RESTful API和使用Thymeleaf模板引擎渲染Web视图的内容就已经可以完成App服务端和Web站点的开发任务了。 然而，在实际开发过程中，对数据库的操作无非就“增删改查”。就最为普遍的单表操作而言，除了表和字段不同外，语句都是类似的，开发人员需要写大量类似而枯燥的语句来完成业务逻辑。 为了解决这些大量枯燥的数据操作语句，我们第一个想到的是使用ORM框架，比如：Hibernate。通过整合Hibernate之后，我们以操作Java实体的方式最终将数据改变映射到数据库表中。 为了解决抽象各个Java实体基本的“增删改查”操作，我们通常会以泛型的方式封装一个模板Dao来进行抽象简化，但是这样依然不是很方便，我们需要针对每个实体编写一个继承自泛型模板Dao的接口，再编写该接口的实现。虽然一些基础的数据访问已经可以得到很好的复用，但是在代码结构上针对每个实体都会有一堆Dao的接口和实现。 由于模板Dao的实现，使得这些具体实体的Dao层已经变的非常“薄”，有一些具体实体的Dao实现可能完全就是对模板Dao的简单代理，并且往往这样的实现类可能会出现在很多实体上。Spring-data-jpa的出现正可以让这样一个已经很“薄”的数据访问层变成只是一层接口的编写方式。比如，下面的例子： import name.quanke.kotlin.chaper11_6_2.entity.Userimport org.springframework.data.jpa.repository.JpaRepositoryimport org.springframework.data.jpa.repository.Queryimport org.springframework.data.repository.query.Param/** * Created by http://quanke.name on 2018/1/10. */interface UserRepository : JpaRepository&lt;User, Long&gt; &#123; fun findByUsername(username: String): List&lt;User&gt; @Query(&quot;from User u where u.username=:username&quot;) fun findUser(@Param(&quot;username&quot;) username: String): User&#125; 只需要通过编写一个继承自JpaRepository的接口就能完成数据访问，下面以一个具体实例来体验Spring-data-jpa给我们带来的强大功能。 由于Spring-data-jpa依赖于Hibernate。如果您对Hibernate有一定了解，下面内容可以毫不费力的看懂并上手使用Spring-data-jpa。如果您还是Hibernate新手，您可以先按如下方式入门，再建议回头学习一下Hibernate以帮助这部分的理解和进一步使用。 工程配置在build.gradle中添加相关依赖，加入以下内容： compile &quot;org.springframework.boot:spring-boot-starter-data-jpa:$spring_boot_version&quot; 如果使用jpa必须增加kotlin-jpa插件 和kotlin-spring插件一样，kotlin-jpa是一个包含在no-arg之上的插件。 该插件自动指定@Entity，@Embeddable和@MappedSuperclass no-arg注释。 buildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot; &#125;&#125;apply plugin: &quot;kotlin-jpa&quot; 如果使用的 Gradle plugins DSL plugins &#123; id &quot;org.jetbrains.kotlin.plugin.jpa&quot; version &quot;1.2.20&quot;&#125; 完整的build.gradle group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; ext.springfox_swagger2_version = &apos;2.7.0&apos; ext.mysql_version = &apos;5.1.21&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;apply plugin: &quot;kotlin-jpa&quot; //https://stackoverflow.com/questions/32038177/kotlin-with-jpa-default-constructor-helljar &#123; baseName = &apos;chapter11-6-2-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile(&quot;org.jetbrains.kotlin:kotlin-reflect:$&#123;kotlin_version&#125;&quot;) compile &quot;org.springframework.boot:spring-boot-starter-web:$spring_boot_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-data-jpa:$spring_boot_version&quot; compile &quot;mysql:mysql-connector-java:$mysql_version&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 在application.yml中配置：数据库连接信息（如使用嵌入式数据库则不需要）、自动创建表结构的设置，例如使用mysql的情况如下： spring: datasource: url: jdbc:mysql://localhost:3306/test username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver spring.jpa.properties.hibernate.hbm2ddl.auto是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下： create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。至此已经完成基础配置，如果您有在Spring下整合使用过它的话，相信你已经感受到Spring Boot的便利之处：JPA的传统配置在persistence.xml文件中，但是这里我们不需要。当然，最好在构建项目时候按照之前提过的最佳实践的工程结构来组织，这样以确保各种配置都能被框架扫描到。 创建实体创建一个User实体，包含id（主键）、username（姓名）、password（密码）属性，通过ORM框架其会被映射到数据库表中，由于配置了hibernate.hbm2ddl.auto，在应用启动的时候框架会自动去数据库中创建对应的表。 import javax.persistence.*/** * Created by http://quanke.name on 2018/1/10. */@Entitydata class User( @Id @GeneratedValue(strategy = GenerationType.AUTO) var id: Long = -1, @Column(nullable = false) var username: String = &quot;&quot;, var password: String = &quot;&quot;) 创建数据访问接口下面针对User实体创建对应的Repository接口实现对该实体的数据访问，如下代码：import name.quanke.kotlin.chaper11_6_2.entity.Userimport org.springframework.data.jpa.repository.JpaRepositoryimport org.springframework.data.jpa.repository.Queryimport org.springframework.data.repository.query.Param/** * Created by http://quanke.name on 2018/1/10. */interface UserRepository : JpaRepository&lt;User, Long&gt; &#123; fun findByUsername(username: String): List&lt;User&gt; fun findByUsernameAndPassword(username: String, password: String?): User @Query(&quot;from User u where u.username=:username&quot;) fun findUser(@Param(&quot;username&quot;) username: String): User&#125; 在Spring-data-jpa中，只需要编写类似上面这样的接口就可实现数据访问。不再像我们以往编写了接口时候还需要自己编写接口实现类，直接减少了我们的文件清单。 下面对上面的UserRepository做一些解释，该接口继承自JpaRepository，通过查看JpaRepository接口的API文档，可以看到该接口本身已经实现了创建（save）、更新（save）、删除（delete）、查询（findAll、findOne）等基本操作的函数，因此对于这些基础操作的数据访问就不需要开发者再自己定义。 在我们实际开发中，JpaRepository接口定义的接口往往还不够或者性能不够优化，我们需要进一步实现更复杂一些的查询或操作。由于本文重点在spring boot中整合spring-data-jpa，在这里先抛砖引玉简单介绍一下spring-data-jpa中让我们兴奋的功能，后续再单独开篇讲一下spring-data-jpa中的常见使用。 在上例中，我们可以看到下面两个函数： fun findByName(name:String ):User fun findByNameAndAge(name:String , age:Int ):User 它们分别实现了按name查询User实体和按name和age查询User实体，可以看到我们这里没有任何类SQL语句就完成了两个条件查询方法。这就是Spring-data-jpa的一大特性：通过解析方法名创建查询。 除了通过解析方法名来创建查询外，它也提供通过使用@Query 注解来创建查询，您只需要编写JPQL语句，并通过类似“:name”来映射@Param指定的参数，就像例子中的第三个findUser函数一样。 Spring-data-jpa的能力远不止本文提到的这些，由于本文主要以整合介绍为主，对于Spring-data-jpa的使用只是介绍了常见的使用方式。诸如@Modifying操作、分页排序、原生SQL支持以及与Spring MVC的结合使用等等内容就不在本文中详细展开，这里先挖个坑，后续再补文章填坑，如您对这些感兴趣可以关注我博客或简书，同样欢迎大家留言交流想法。 单元测试在完成了上面的数据访问接口之后，按照惯例就是编写对应的单元测试来验证编写的内容是否正确。这里就不多做介绍，主要通过数据操作和查询来反复验证操作的正确性。 import name.quanke.kotlin.chaper11_6_2.entity.Userimport name.quanke.kotlin.chaper11_6_2.repository.UserRepositoryimport org.apache.commons.logging.LogFactoryimport org.junit.Testimport org.junit.runner.RunWithimport org.springframework.beans.factory.annotation.Autowiredimport org.springframework.boot.test.context.SpringBootTestimport org.springframework.test.context.junit4.SpringRunner/** * Created by http://quanke.name on 2018/1/9. */@RunWith(SpringRunner::class)@SpringBootTestclass ApplicationTests &#123; val log = LogFactory.getLog(ApplicationTests::class.java)!! @Autowired lateinit var userRepository: UserRepository @Test fun `jpa test&quot;`() &#123;// val username = &quot;quanke&quot;// val password = &quot;123456&quot; val user = User() user.username = &quot;quanke.name&quot; user.password = &quot;12&quot; userRepository.save(user) log.info(&quot;总共用户: $&#123;userRepository.count()&#125;&quot;) log.info(&quot;名字为quanke的用户: $&#123;userRepository.findByUsername(&quot;quanke.name&quot;)&#125;&quot;) &#125; 参考 https://spring.io/guides/gs/accessing-data-jpa/ http://blog.didispace.com/springbootdata2/ 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 Kotlin 使用JdbcTemplate连接MySQL","slug":"kotlin/Spring-Boot-与-Kotlin-使用JdbcTemplate连接MySQL","date":"2018-02-03T14:52:50.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/56945/","link":"","permalink":"http://quanke.name/posts/56945/","excerpt":"","text":"之前介绍了一些Web层的例子，包括构建RESTful API、使用Thymeleaf模板引擎渲染Web视图，但是这些内容还不足以构建一个动态的应用。通常我们做App也好，做Web应用也好，都需要内容，而内容通常存储于各种类型的数据库，服务端在接收到访问请求之后需要访问数据库获取并处理成展现给用户使用的数据形式。 本文介绍在Spring Boot基础下配置数据源和通过JdbcTemplate编写数据访问的示例。 数据源配置在我们访问数据库的时候，需要先配置一个数据源，下面分别介绍一下几种不同的数据库配置方式。 首先，为了连接数据库需要引入jdbc支持，在build.gradle中引入如下配置： compile &quot;org.springframework.boot:spring-boot-starter-jdbc:$spring_boot_version&quot; 连接数据源以MySQL数据库为例，先引入MySQL连接的依赖包，在build.gradle中加入： compile &quot;mysql:mysql-connector-java:$mysql_version&quot; 完整build.gradle group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; ext.springfox_swagger2_version = &apos;2.7.0&apos; ext.mysql_version = &apos;5.1.21&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;jar &#123; baseName = &apos;chapter11-6-1-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-web:$spring_boot_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-jdbc:$spring_boot_version&quot; compile &quot;mysql:mysql-connector-java:$mysql_version&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 在src/main/resources/application.yml中配置数据源信息 spring: datasource: url: jdbc:mysql://localhost:3306/test username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver 连接JNDI数据源当你将应用部署于应用服务器上的时候想让数据源由应用服务器管理，那么可以使用如下配置方式引入JNDI数据源。 如果对JNDI不是很了解的，请参考 https://baike.baidu.com/item/JNDI/3792442?fr=aladdin spring.datasource.jndi-name=java:jboss/datasources/customers 使用JdbcTemplate操作数据库Spring的JdbcTemplate是自动配置的，你可以直接使用@Autowired来注入到你自己的bean中来使用。 举例：我们在创建User表，包含属性id,name、age，下面来编写数据访问对象和单元测试用例。 定义包含有插入、删除、查询的抽象接口UserService interface UserService &#123; /** * 获取用户总量 */ val allUsers: Int? /** * 新增一个用户 * @param name * @param age */ fun create(name: String, password: String?) /** * 根据name删除一个用户高 * @param name */ fun deleteByName(name: String) /** * 删除所有用户 */ fun deleteAllUsers()&#125; 通过JdbcTemplate实现UserService中定义的数据访问操作 import org.springframework.beans.factory.annotation.Autowiredimport org.springframework.jdbc.core.JdbcTemplateimport org.springframework.stereotype.Service/** * Created by http://quanke.name on 2018/1/10. */@Serviceclass UserServiceImpl : UserService &#123; @Autowired private val jdbcTemplate: JdbcTemplate? = null override val allUsers: Int? get() = jdbcTemplate!!.queryForObject(&quot;select count(1) from USER&quot;, Int::class.java) override fun create(name: String, password: String?) &#123; jdbcTemplate!!.update(&quot;insert into USER(USERNAME, PASSWORD) values(?, ?)&quot;, name, password) &#125; override fun deleteByName(name: String) &#123; jdbcTemplate!!.update(&quot;delete from USER where USERNAME = ?&quot;, name) &#125; override fun deleteAllUsers() &#123; jdbcTemplate!!.update(&quot;delete from USER&quot;) &#125;&#125; 创建对UserService的单元测试用例，通过创建、删除和查询来验证数据库操作的正确性。 /** * Created by http://quanke.name on 2018/1/9. */@RunWith(SpringRunner::class)@SpringBootTestclass ApplicationTests &#123; val log = LogFactory.getLog(ApplicationTests::class.java)!! @Autowired lateinit var userService: UserService @Test fun `jdbc test&quot;`() &#123; val username = &quot;quanke&quot; val password = &quot;123456&quot; // 插入5个用户 userService.create(&quot;$username a&quot;, &quot;$password 1&quot;) userService.create(&quot;$username b&quot;, &quot;$password 2&quot;) userService.create(&quot;$username c&quot;, &quot;$password 3&quot;) userService.create(&quot;$username d&quot;, &quot;$password 4&quot;) userService.create(&quot;$username e&quot;, &quot;$password 5&quot;) log.info(&quot;总共用户 $&#123;userService.allUsers&#125;&quot;) // 删除两个用户 userService.deleteByName(&quot;$username a&quot;) userService.deleteByName(&quot;$username b&quot;) log.info(&quot;总共用户 $&#123;userService.allUsers&#125;&quot;) &#125;&#125; 上面介绍的JdbcTemplate只是最基本的几个操作，更多其他数据访问操作的使用请参考：JdbcTemplate API 通过上面这个简单的例子，我们可以看到在Spring Boot下访问数据库的配置依然秉承了框架的初衷：简单。我们只需要在pom.xml中加入数据库依赖，再到application.yml中配置连接信息，不需要像Spring应用中创建JdbcTemplate的Bean，就可以直接在自己的对象中注入使用。 参考 https://spring.io/guides/gs/relational-data-access/ http://blog.didispace.com/springbootdata1/ 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 Kotlin 上传文件","slug":"kotlin/Spring-Boot-与-Kotlin-上传文件","date":"2018-02-03T14:52:15.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/48021/","link":"","permalink":"http://quanke.name/posts/48021/","excerpt":"","text":"如果我们做一个小型的web站，而且刚好选择的kotlin 和Spring Boot技术栈，那么上传文件的必不可少了，当然，如果你做一个中大型的web站，那建议你使用云存储，能省不少事情。 这篇文章就介绍怎么使用kotlin 和Spring Boot上传文件 构建工程 如果对于构建工程还不是很熟悉的可以参考《我的第一个Kotlin应用》 完整build.gradle文件 group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;jar &#123; baseName = &apos;chapter11-5-6-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-web:$spring_boot_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-thymeleaf:$spring_boot_version&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 创建文件上传controller import name.quanke.kotlin.chaper11_5_6.storage.StorageFileNotFoundExceptionimport name.quanke.kotlin.chaper11_5_6.storage.StorageServiceimport org.springframework.beans.factory.annotation.Autowiredimport org.springframework.core.io.Resourceimport org.springframework.http.HttpHeadersimport org.springframework.http.ResponseEntityimport org.springframework.stereotype.Controllerimport org.springframework.ui.Modelimport org.springframework.web.bind.annotation.*import org.springframework.web.multipart.MultipartFileimport org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilderimport org.springframework.web.servlet.mvc.support.RedirectAttributesimport java.io.IOExceptionimport java.util.stream.Collectors/** * 文件上传控制器 * Created by http://quanke.name on 2018/1/12. */@Controllerclass FileUploadController @Autowiredconstructor(private val storageService: StorageService) &#123; @GetMapping(&quot;/&quot;) @Throws(IOException::class) fun listUploadedFiles(model: Model): String &#123; model.addAttribute(&quot;files&quot;, storageService .loadAll() .map &#123; path -&gt; MvcUriComponentsBuilder .fromMethodName(FileUploadController::class.java, &quot;serveFile&quot;, path.fileName.toString()) .build().toString() &#125; .collect(Collectors.toList())) return &quot;uploadForm&quot; &#125; @GetMapping(&quot;/files/&#123;filename:.+&#125;&quot;) @ResponseBody fun serveFile(@PathVariable filename: String): ResponseEntity&lt;Resource&gt; &#123; val file = storageService.loadAsResource(filename) return ResponseEntity .ok() .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=\\&quot;&quot; + file.filename + &quot;\\&quot;&quot;) .body(file) &#125; @PostMapping(&quot;/&quot;) fun handleFileUpload(@RequestParam(&quot;file&quot;) file: MultipartFile, redirectAttributes: RedirectAttributes): String &#123; storageService.store(file) redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;You successfully uploaded &quot; + file.originalFilename + &quot;!&quot;) return &quot;redirect:/&quot; &#125; @ExceptionHandler(StorageFileNotFoundException::class) fun handleStorageFileNotFound(exc: StorageFileNotFoundException): ResponseEntity&lt;*&gt; &#123; return ResponseEntity.notFound().build&lt;Any&gt;() &#125;&#125; 上传文件服务的接口 import org.springframework.core.io.Resourceimport org.springframework.web.multipart.MultipartFileimport java.nio.file.Pathimport java.util.stream.Streaminterface StorageService &#123; fun init() fun store(file: MultipartFile) fun loadAll(): Stream&lt;Path&gt; fun load(filename: String): Path fun loadAsResource(filename: String): Resource fun deleteAll()&#125; 上传文件服务 import org.springframework.beans.factory.annotation.Autowiredimport org.springframework.core.io.Resourceimport org.springframework.core.io.UrlResourceimport org.springframework.stereotype.Serviceimport org.springframework.util.FileSystemUtilsimport org.springframework.util.StringUtilsimport org.springframework.web.multipart.MultipartFileimport java.io.IOExceptionimport java.net.MalformedURLExceptionimport java.nio.file.Filesimport java.nio.file.Pathimport java.nio.file.Pathsimport java.nio.file.StandardCopyOptionimport java.util.stream.Stream@Serviceclass FileSystemStorageService @Autowiredconstructor(properties: StorageProperties) : StorageService &#123; private val rootLocation: Path init &#123; this.rootLocation = Paths.get(properties.location) &#125; override fun store(file: MultipartFile) &#123; val filename = StringUtils.cleanPath(file.originalFilename) try &#123; if (file.isEmpty) &#123; throw StorageException(&quot;Failed to store empty file &quot; + filename) &#125; if (filename.contains(&quot;..&quot;)) &#123; // This is a security check throw StorageException( &quot;Cannot store file with relative path outside current directory &quot; + filename) &#125; Files.copy(file.inputStream, this.rootLocation.resolve(filename), StandardCopyOption.REPLACE_EXISTING) &#125; catch (e: IOException) &#123; throw StorageException(&quot;Failed to store file &quot; + filename, e) &#125; &#125; override fun loadAll(): Stream&lt;Path&gt; &#123; try &#123; return Files.walk(this.rootLocation, 1) .filter &#123; path -&gt; path != this.rootLocation &#125; .map &#123; path -&gt; this.rootLocation.relativize(path) &#125; &#125; catch (e: IOException) &#123; throw StorageException(&quot;Failed to read stored files&quot;, e) &#125; &#125; override fun load(filename: String): Path &#123; return rootLocation.resolve(filename) &#125; override fun loadAsResource(filename: String): Resource &#123; try &#123; val file = load(filename) val resource = UrlResource(file.toUri()) return if (resource.exists() || resource.isReadable) &#123; resource &#125; else &#123; throw StorageFileNotFoundException( &quot;Could not read file: &quot; + filename) &#125; &#125; catch (e: MalformedURLException) &#123; throw StorageFileNotFoundException(&quot;Could not read file: &quot; + filename, e) &#125; &#125; override fun deleteAll() &#123; FileSystemUtils.deleteRecursively(rootLocation.toFile()) &#125; override fun init() &#123; try &#123; Files.createDirectories(rootLocation) &#125; catch (e: IOException) &#123; throw StorageException(&quot;Could not initialize storage&quot;, e) &#125; &#125;&#125; 自定义异常 open class StorageException : RuntimeException &#123; constructor(message: String) : super(message) constructor(message: String, cause: Throwable) : super(message, cause)&#125; class StorageFileNotFoundException : StorageException &#123; constructor(message: String) : super(message) constructor(message: String, cause: Throwable) : super(message, cause)&#125; 配置文件上传目录 import org.springframework.boot.context.properties.ConfigurationProperties@ConfigurationProperties(&quot;storage&quot;)class StorageProperties &#123; /** * Folder location for storing files */ var location = &quot;upload-dir&quot;&#125; 启动Spring Boot /** * Created by http://quanke.name on 2018/1/9. */@SpringBootApplication@EnableConfigurationProperties(StorageProperties::class)class Application &#123; @Bean internal fun init(storageService: StorageService) = CommandLineRunner &#123; storageService.deleteAll() storageService.init() &#125; companion object &#123; @Throws(Exception::class) @JvmStatic fun main(args: Array&lt;String&gt;) &#123; SpringApplication.run(Application::class.java, *args) &#125; &#125;&#125; 创建一个简单的 html模板 src/main/resources/templates/uploadForm.html &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;body&gt;&lt;div th:if=&quot;$&#123;message&#125;&quot;&gt; &lt;h2 th:text=&quot;$&#123;message&#125;&quot;/&gt;&lt;/div&gt;&lt;div&gt; &lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; action=&quot;/&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;File to upload:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/div&gt;&lt;div&gt; &lt;ul&gt; &lt;li th:each=&quot;file : $&#123;files&#125;&quot;&gt; &lt;a th:href=&quot;$&#123;file&#125;&quot; th:text=&quot;$&#123;file&#125;&quot;/&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 配置文件application.yml spring: http: multipart: max-file-size: 128KB max-request-size: 128KB 更多Spring Boot 和 kotlin相关内容，欢迎关注《Spring Boot 与 kotlin 实战》 源码：https://github.com/quanke/spring-boot-with-kotlin-in-action/ 参考: https://spring.io/guides/gs/uploading-files/ 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 Kotlin 验证web表单信息","slug":"kotlin/Spring-Boot-与-Kotlin-验证web表单信息","date":"2018-02-03T14:51:29.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/46111/","link":"","permalink":"http://quanke.name/posts/46111/","excerpt":"","text":"在做web开发的时候，我们需要验证表单，确认用户提交的信息是安全的，比如用户名不能超过多少位，密码不能少于多少位等等。 那么如何在Spring Boot 与 Kotlin中验证表单信息？ 在springmvc工程中，需要检查表单信息，表单信息验证主要通过注解的形式。 表单验证下面我们在之前《Spring Boot 与 Kotlin使用Freemarker模板引擎渲染web视图》项目的基础上，增加表单验证。 build.gradle 文件增加依赖 compile &quot;org.hibernate:hibernate-validator&quot;compile &quot;org.apache.tomcat.embed:tomcat-embed-el&quot; 完整的build.gradle文件 group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;jar &#123; baseName = &apos;chapter11-5-5-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-web:$spring_boot_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-thymeleaf:$spring_boot_version&quot; compile &quot;org.hibernate:hibernate-validator&quot; compile &quot;org.apache.tomcat.embed:tomcat-embed-el&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 创建UserForm类 import javax.validation.constraints.Minimport javax.validation.constraints.NotNullimport javax.validation.constraints.Size/** * Created by http://quanke.name on 2018/1/12. * https://stackoverflow.com/questions/36515094/kotlin-and-valid-spring-annotation * https://stonesoupprogramming.com/2017/06/21/spring-bean-validation-example-jsr-303-in-kotlin/ */data class UserForm(@get:NotNull(message = &quot;&#123;name.required&#125;&quot;) @get:Size(min = 2, max = 5,message = &quot;&#123;name.size&#125;&quot;) var name: String? = &quot;&quot;, @get:Min(18) var age: Int? = 0) 如果是Spring boot 可以不增加 @get注解，如果使用kotlin 语言实现必须加@get 这个实体类，在2个属性:name,age.它们各自有验证的注解： @Size(min=2, max=5) name的长度为2-30个字符 @NotNull 不为空 @Min(18)age不能小于18 创建WebController import name.quanke.kotlin.chaper11_5_5.entity.UserFormimport org.springframework.stereotype.Controllerimport org.springframework.validation.Errorsimport org.springframework.web.bind.annotation.GetMappingimport org.springframework.web.bind.annotation.PostMappingimport org.springframework.web.servlet.config.annotation.ViewControllerRegistryimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapterimport javax.validation.Valid/** * Created by http://quanke.name on 2018/1/12. */@Controllerclass WebController : WebMvcConfigurerAdapter() &#123; override fun addViewControllers(registry: ViewControllerRegistry?) &#123; registry!!.addViewController(&quot;/results&quot;).setViewName(&quot;results&quot;) &#125; @GetMapping(&quot;/&quot;) fun index(userForm: UserForm): String &#123; return &quot;index&quot; &#125; @PostMapping(&quot;/&quot;) fun checkPersonInfo(@Valid userForm: UserForm, errors: Errors): String &#123; val result: String = when &#123; //Test for errors errors.hasErrors() -&gt; &quot;index&quot; else -&gt; &#123; //Otherwise proceed to the next page &quot;redirect:/results&quot; &#125; &#125; return result &#125;&#125; 创建form表单src/main/resources/templates/index.html &lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;title&gt;quanke.name&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Form&lt;/h1&gt;&lt;form action=&quot;#&quot; th:action=&quot;@&#123;/&#125;&quot; th:object=&quot;$&#123;userForm&#125;&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;Name:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; th:field=&quot;*&#123;name&#125;&quot; /&gt;&lt;/td&gt; &lt;td th:if=&quot;$&#123;#fields.hasErrors(&apos;name&apos;)&#125;&quot; th:errors=&quot;*&#123;name&#125;&quot;&gt;Name Error&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Age:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; th:field=&quot;*&#123;age&#125;&quot; /&gt;&lt;/td&gt; &lt;td th:if=&quot;$&#123;#fields.hasErrors(&apos;age&apos;)&#125;&quot; th:errors=&quot;*&#123;age&#125;&quot;&gt;Age Error&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 成功页面src/main/resources/templates/results.html &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; &lt;title&gt;quanke&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;quanke.name&lt;/h1&gt;Congratulations! You are old enough to sign up for this site&lt;/body&gt;&lt;/html&gt; 在src/main/resources/目录下增加ValidationMessages.properties文件 # \\u8FD9\\u91CC\\u8981\\u6CE8\\u610F\\u7F16\\u7801\\u95EE\\u9898name.required=\\u540D\\u5B57\\u4E0D\\u80FD\\u4E3A\\u7A7Aname.size=\\u540D\\u5B57\\u957F\\u5EA6\\u8FD4\\u56DE\\u53EA\\u80FD\\u662F2-5 Spring Boot 启动 import org.springframework.boot.SpringApplicationimport org.springframework.boot.autoconfigure.SpringBootApplication/** * Created by http://quanke.name on 2018/1/9. */@SpringBootApplicationclass Applicationfun main(args: Array&lt;String&gt;) &#123; SpringApplication.run(Application::class.java, *args)&#125; 参考资料 https://spring.io/guides/gs/validating-form-input/ https://stonesoupprogramming.com/2017/06/21/spring-bean-validation-example-jsr-303-in-kotlin/ https://stackoverflow.com/questions/36515094/kotlin-and-valid-spri 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 Kotlin 处理Web表单提交","slug":"kotlin/Spring-Boot-与-Kotlin-处理Web表单提交","date":"2018-02-03T14:50:38.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/55956/","link":"","permalink":"http://quanke.name/posts/55956/","excerpt":"","text":"我们在做web开发的时候，肯定逃不过表单提交，这篇文章通过Spring Boot使用Kotlin 语言 创建和提交一个表单。 下面我们在之前《Spring Boot 与 Kotlin使用Freemarker模板引擎渲染web视图》项目的基础上，增加处理表单提交。 build.gradle 文件没有变化，这里贴一下完整的build.gradle group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;jar &#123; baseName = &apos;chapter11-5-4-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-web:$spring_boot_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-thymeleaf:$spring_boot_version&quot;// compile &quot;com.fasterxml.jackson.module:jackson-module-kotlin:$kotlin_version&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 创建实体类Hello /** * Created by http://quanke.name on 2018/1/12. */data class Hello(var id: Long? = 0, var content: String? = &quot;&quot;) 创建Controller import name.quanke.kotlin.chaper11_5_4.entity.Helloimport org.springframework.stereotype.Controllerimport org.springframework.ui.ModelMapimport org.springframework.web.bind.annotation.ModelAttributeimport org.springframework.web.bind.annotation.PostMappingimport org.springframework.web.bind.annotation.RequestMapping/** * Created by http://quanke.name on 2018/1/10. */@Controllerclass HelloController &#123; @RequestMapping(&quot;/&quot;) fun index(map: ModelMap): String &#123;// / 加入一个属性，用来在模板中读取 map.addAttribute(&quot;host&quot;, &quot;http://quanke.name&quot;) map.addAttribute(&quot;hello&quot;,Hello()) // return模板文件的名称，对应src/main/resources/templates/index.html return &quot;index&quot; &#125; @PostMapping(&quot;/hello&quot;) fun helloPostSubmit(@ModelAttribute hello: Hello): String &#123; return &quot;result&quot; &#125;&#125; 页面展示层 src/main/resources/templates/index.html &lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;title&gt;quanke.name&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=&quot;$&#123;host&#125;&quot;&gt;Hello World&lt;/h1&gt;&lt;h1&gt;Form&lt;/h1&gt;&lt;form action=&quot;#&quot; th:action=&quot;@&#123;/hello&#125;&quot; th:object=&quot;$&#123;hello&#125;&quot; method=&quot;post&quot;&gt; &lt;p&gt;Id: &lt;input type=&quot;text&quot; th:field=&quot;*&#123;id&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;Message: &lt;input type=&quot;text&quot; th:field=&quot;*&#123;content&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt; &lt;input type=&quot;reset&quot; value=&quot;Reset&quot;/&gt;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; src/main/resources/templates/result.html &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Result&lt;/h1&gt;&lt;p th:text=&quot;&apos;id: &apos; + $&#123;hello.id&#125;&quot;/&gt;&lt;p th:text=&quot;&apos;content: &apos; + $&#123;hello.content&#125;&quot;/&gt;&lt;a href=&quot;/&quot;&gt;Submit another message&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; Spring Boot 启动 import org.springframework.boot.SpringApplicationimport org.springframework.boot.autoconfigure.SpringBootApplication/** * Created by http://quanke.name on 2018/1/9. */@SpringBootApplicationclass Applicationfun main(args: Array&lt;String&gt;) &#123; SpringApplication.run(Application::class.java, *args)&#125; 启动工程，访问ttp://localhost:8080/: 参考 https://spring.io/guides/gs/handling-form-submission/ 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 Kotlin Web应用的统一异常处理","slug":"kotlin/Spring-Boot-与-Kotlin-Web应用的统一异常处理","date":"2018-02-03T14:49:38.000Z","updated":"2018-02-03T14:59:15.000Z","comments":true,"path":"posts/44428/","link":"","permalink":"http://quanke.name/posts/44428/","excerpt":"","text":"做Web应用，请求处理过程中发生错误是非常常见的。Spring Boot提供了一个默认的映射：/error，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。 选择一个之前实现过的Web应用（chapter11-5-1 ）为基础，启动该应用，访问一个不存在的URL，或是修改处理内容，直接抛出异常，如：@RequestMapping(&quot;/hello&quot;)@Throws(Exception::class)fun hello() &#123; throw Exception(&quot;发生错误&quot;)&#125; 注意版本实例修改默认端口，现在为8083,如果想修改为默认的，请修改application.yml文件 server: port: 8080 此时，可以看到类似下面的报错页面，该页面就是Spring Boot提供的默认error映射页面。 Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Fri Jan 19 10:01:32 CST 2018There was an unexpected error (type=Internal Server Error, status=500).???? 统一异常处理虽然，Spring Boot中实现了默认的error映射，但是在实际应用中，上面你的错误页面对用户来说并不够友好，我们通常需要去实现我们自己的异常提示。 下面我们以之前的Web应用例子为基础（chapter11-5-1 ），进行统一异常处理的改造。 创建全局异常处理类：通过使用@ControllerAdvice定义统一的异常处理类，而不是在每个Controller中逐个定义。@ExceptionHandler用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到error.html中 @ControllerAdvice 注解的类需要增加 @RestController //springboot1.5.7版本,如果不加 这个会报错 jsonErrorHandler import org.springframework.web.bind.annotation.ControllerAdviceimport org.springframework.web.bind.annotation.ExceptionHandlerimport org.springframework.web.bind.annotation.RestControllerimport org.springframework.web.servlet.ModelAndViewimport javax.servlet.http.HttpServletRequest/** * Created by http://quanke.name on 2018/1/10. */@ControllerAdvice@RestController //springboot1.5.7版本,如果不加 这个会报错 jsonErrorHandlerclass GlobalExceptionHandler &#123; @ExceptionHandler(value = Exception::class) @Throws(Exception::class) fun defaultErrorHandler(req: HttpServletRequest, e: Exception): ModelAndView &#123; val mav = ModelAndView() mav.addObject(&quot;exception&quot;, e) mav.addObject(&quot;url&quot;, req.requestURL) mav.viewName = &quot;error&quot; return mav &#125;&#125; 实现error.html页面展示：在templates目录下创建error.html，将请求的URL和Exception对象的message输出。 &lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;统一异常处理&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;http://quanke.name Error Handler&lt;/h1&gt;&lt;div th:text=&quot;$&#123;url&#125;&quot;&gt;&lt;/div&gt;&lt;div th:text=&quot;$&#123;exception.message&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动该应用，访问：http://localhost:8083/hello，可以看到如下错误提示页面。 http://quanke.name Error Handlerhttp://127.0.0.1:8083/hello发生错误 通过实现上述内容之后，我们只需要在Controller中抛出Exception，当然我们可能会有多种不同的Exception。然后在@ControllerAdvice类中，根据抛出的具体Exception类型匹配@ExceptionHandler中配置的异常类型来匹配错误映射和处理。 返回JSON格式在上述例子中，通过@ControllerAdvice统一定义不同Exception映射到不同错误处理页面。而当我们要实现RESTful API时，返回的错误是JSON格式的数据，而不是HTML页面，这时候我们也能轻松支持。 本质上，只需在@ExceptionHandler之后加入@ResponseBody，就能让处理函数return的内容转换为JSON格式。 下面以一个具体示例来实现返回JSON格式的异常处理。 创建统一的JSON返回对象，code：消息类型，message：消息内容，url：请求的url，data：请求返回的数据 data class ErrorInfo&lt;T&gt;(var code: Int? = null, var message: String? = &quot;&quot;, var url: String? = &quot;&quot;, var data: T? = null) 创建一个自定义异常，用来实验捕获该异常，并返回json /** * Created by http://quanke.name on 2018/1/11. */class QkException(message: String) : Exception(message) Controller中增加json映射，抛出QkException异常 import name.quanke.kotlin.chaper11_5_3.exception.QkExceptionimport org.springframework.stereotype.Controllerimport org.springframework.web.bind.annotation.RequestMapping/** * Created by http://quanke.name on 2018/1/10. */@Controllerclass UserController &#123; @RequestMapping(&quot;/json&quot;) @Throws(QkException::class) fun json(): String &#123; throw QkException(&quot;发生错误 json&quot;) &#125;&#125; 为QkException异常创建对应的处理 import name.quanke.kotlin.chaper11_5_3.entity.ErrorInfoimport org.springframework.web.bind.annotation.ControllerAdviceimport org.springframework.web.bind.annotation.ExceptionHandlerimport org.springframework.web.bind.annotation.RestControllerimport javax.servlet.http.HttpServletRequest/** * Created by http://quanke.name on 2018/1/10. */@ControllerAdvice@RestController //springboot1.5.7版本,如果不加 这个会报错 jsonErrorHandlerclass GlobalExceptionHandler &#123; @ExceptionHandler(value = QkException::class) @Throws(QkException::class) fun jsonErrorHandler(req: HttpServletRequest, e: QkException): ErrorInfo&lt;String&gt; &#123; val r = ErrorInfo&lt;String&gt;() r.message = e.message r.code = 1 r.data = &quot;Some Data&quot; r.url = req.requestURL.toString() return r &#125; 启动应用，访问：http://localhost:8083/json，可以得到如下返回内容： &#123; &quot;code&quot;: 1, &quot;message&quot;: &quot;发生错误 json&quot;, &quot;url&quot;: &quot;http://127.0.0.1:8083/json&quot;, &quot;data&quot;: &quot;Some Data&quot;&#125; 至此，已完成在Spring Boot中创建统一的异常处理，实际实现还是依靠Spring MVC的注解，更多更深入的使用可参考[Spring MVC]的文档。 参考 https://spring.io/guides/gs/serving-web-content/ 源码 https://github.com/quanke/spring-boot-with-kotlin-in-action/chapter11-5-3 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 Kotlin 使用Freemarker模板引擎渲染web视图","slug":"kotlin/Spring-Boot-与-Kotlin-使用Freemarker模板引擎渲染web视图","date":"2018-02-02T16:01:59.000Z","updated":"2018-02-03T15:04:49.000Z","comments":true,"path":"posts/39947/","link":"","permalink":"http://quanke.name/posts/39947/","excerpt":"","text":"在《Spring Boot 与 Kotlin 使用Thymeleaf模板引擎渲染web视图》 一文中，我们使用Thymeleaf模板引擎渲染web视图，体验了kotlin 与spring boot结合是相当好的，这篇文章中继续介绍web视图，但是是使用Freemarker模板引擎渲染web视图。 Web相关的介绍这里就不多阐述，还没了解的请移步《Spring Boot 与 Kotlin 使用Thymeleaf模板引擎渲染web视图》 FreeMarkerFreeMarker是一款模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。 FreeMarker是免费的，基于Apache许可证2.0版本发布。其模板编写为FreeMarker Template Language（FTL），属于简单、专用的语言。需要准备数据在真实编程语言中来显示，比如数据库查询和业务运算， 之后模板显示已经准备好的数据。在模板中，主要用于如何展现数据， 而在模板之外注意于要展示什么数据 。 基本语法： ${…}：FreeMarker将会输出真实的值来替换大括号内的表达式，这样的表达式被称为interpolation（插值）。 注释：注释和HTML的注释也很相似，但是它们使用&lt;#– and –&gt;来标识。不像HTML注释那样，FTL注释不会出现在输出中（不出现在访问者的页面中），因为FreeMarker会跳过它们。 FTL标签（FreeMarker模板的语言标签）：FTL标签和HTML标签有一些相似之处，但是它们是FreeMarker的指令，是不会在输出中打印的。这些标签的名字以#开头。（用户自定义的FTL标签则需要使用@来代替#） 模版实例&lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome $&#123;username&#125;!&lt;/h1&gt; &lt;p&gt;Our latest product: &lt;a href=&quot;$&#123;latestProduct.url&#125;&quot;&gt;$&#123;latestProduct.name&#125;&lt;/a&gt;! &lt;/body&gt;&lt;/html&gt; 在Spring Boot中使用FreeMarker相关的，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。 compile &quot;org.springframework.boot:spring-boot-starter-freemarker:$spring_boot_version&quot; 完整的build.gradle group &apos;name.quanke.kotlin&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123; ext.kotlin_version = &apos;1.2.10&apos; ext.spring_boot_version = &apos;1.5.4.RELEASE&apos; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;)// Kotlin整合SpringBoot的默认无参构造函数，默认把所有的类设置open类插件 classpath(&quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot;) classpath(&quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot;) &#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;jar &#123; baseName = &apos;chapter11-5-2-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-web:$spring_boot_version&quot; compile &quot;org.springframework.boot:spring-boot-starter-freemarker:$spring_boot_version&quot; testCompile &quot;org.springframework.boot:spring-boot-starter-test:$spring_boot_version&quot; testCompile &quot;org.jetbrains.kotlin:kotlin-test-junit:$kotlin_version&quot;&#125;compileKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123; kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 举个例子：通过FreeMarker渲染一个页面。import org.springframework.stereotype.Controllerimport org.springframework.ui.Modelimport org.springframework.web.bind.annotation.RequestMapping/** * Created by http://quanke.name on 2018/1/10. */@Controllerclass HelloController &#123; @RequestMapping(&quot;/&quot;) fun index(model: Model): String &#123;// / 加入一个属性，用来在模板中读取 model.addAttribute(&quot;host&quot;, &quot;http://quanke.name&quot;) // return模板文件的名称，对应src/main/resources/templates/index.ftl return &quot;index&quot; &#125;&#125; 默认在 src/main/resources/templates目录下增加index.ftl文件 注意Freemarker模版的后缀默认是ftl,Thymeleaf模版后缀默认是html &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h4&gt;我的博客：$&#123;host&#125;！&lt;/h4&gt;&lt;h1&gt;quanke.name&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 增加使用 kotlin语言实现的 Spring Boot启动方法： import org.springframework.boot.SpringApplicationimport org.springframework.boot.autoconfigure.SpringBootApplication/** * Created by http://quanke.name on 2018/1/9. */@SpringBootApplicationclass Applicationfun main(args: Array&lt;String&gt;) &#123; SpringApplication.run(Application::class.java, *args)&#125; 在application.yml文中增加： #设定ftl文件路径spring: freemarker: template-loader-path: classpath:/templates 如上页面，直接打开html页面展现Hello World，但是启动程序后，访问http://localhost:8080/，则是展示Controller中host的值：http://quanke.name，做到了不破坏HTML自身内容的数据逻辑分离。 更多 FreeMarker相关的，还请访问 FreeMarker 官网 查询使用。 源码 https://github.com/quanke/spring-boot-with-kotlin-in-action/chapter11-5-2 参考 https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples/spring-boot-sample-web-freemarker 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Spring Boot 与 kotlin 使用Thymeleaf模板引擎渲染web视图","slug":"kotlin/Spring-Boot-与-kotlin-使用Thymeleaf模板引擎渲染web视图","date":"2018-02-02T16:01:48.000Z","updated":"2018-02-02T16:03:45.000Z","comments":true,"path":"posts/15187/","link":"","permalink":"http://quanke.name/posts/15187/","excerpt":"","text":"在《使用Spring Boot和Kotlin创建RESTfull API》一文中，我们完成了一个简单的RESTful 服务，体验了Spring Boot 与 kotlin结合的神力，但是往往我们也需要web的支持，那么本篇就在上一个文章的基础上介绍Spring Boot 与 kotlin 使用Thymeleaf模板引擎渲染web视图。 静态资源访问在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源，使用Spring Boot 与 kotlin如何去支持这些静态资源？，很简单。 默认配置Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则： /static/public/resources/META-INF/resources 举例：我们可以在src/main/resources/目录下创建static，在该位置放置一个图片文件。启动程序后，尝试访问http://localhost:8080/ruby.jpg。如能显示图片，配置成功。 渲染Web页面之前通过@RestController处理请求，返回的内容为json对象。如果需要渲染html页面，要如何实现呢？ 模板引擎在Spring Boot推荐的模板引擎下，我们可以很快的上手开发动态网站。 Spring Boot提供了默认配置的模板引擎主要有以下几种： ThymeleafFreeMarkerGroovyMustache Spring Boot建议使用这些模板引擎，避免使用JSP，若一定要使用JSP将无法实现Spring Boot的多种特性，具体可见后文：支持JSP的配置 当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。 ThymeleafThymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。 Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。 示例模板：&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;quanke.name&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=&quot;$&#123;host&#125;&quot;&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 可以看到Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。 在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。 compile &quot;org.springframework.boot:spring-boot-starter-thymeleaf:$spring_boot_version&quot; 在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。 import org.springframework.stereotype.Controllerimport org.springframework.ui.ModelMapimport org.springframework.web.bind.annotation.RequestMapping/** * Created by http://quanke.name on 2018/1/10. */@Controllerclass HelloController &#123; @RequestMapping(&quot;/&quot;) fun index(map: ModelMap): String &#123;// / 加入一个属性，用来在模板中读取 map.addAttribute(&quot;host&quot;, &quot;http://quanke.name&quot;) // return模板文件的名称，对应src/main/resources/templates/index.html return &quot;index&quot; &#125;&#125; 默认在 src/main/resources/templates目录下增加index.html文件 &lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;quanke.name&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text=&quot;$&#123;host&#125;&quot;&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 增加使用 kotlin语言实现的 Spring Boot启动方法： import org.springframework.boot.SpringApplicationimport org.springframework.boot.autoconfigure.SpringBootApplication/** * Created by http://quanke.name on 2018/1/9. */@SpringBootApplicationclass Applicationfun main(args: Array&lt;String&gt;) &#123; SpringApplication.run(Application::class.java, *args)&#125; 如上页面，直接打开html页面展现Hello World，但是启动程序后，访问http://localhost:8080/，则是展示Controller中host的值：http://quanke.name，做到了不破坏HTML自身内容的数据逻辑分离。 更多Thymeleaf的页面语法，还请访问Thymeleaf的官方文档查询使用。 Thymeleaf的默认参数配置 如有需要修改默认配置的时候，只需复制下面要修改的属性到application.yml中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。 # Enable template caching.spring.thymeleaf.cache=true # Check that the templates location exists.spring.thymeleaf.check-template-location=true # Content-Type value.spring.thymeleaf.content-type=text/html # Enable MVC Thymeleaf view resolution.spring.thymeleaf.enabled=true # Template encoding.spring.thymeleaf.encoding=UTF-8 # Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.excluded-view-names= # Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.mode=HTML5 # Prefix that gets prepended to view names when building a URL.spring.thymeleaf.prefix=classpath:/templates/ # Suffix that gets appended to view names when building a URL.spring.thymeleaf.suffix=.html spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved. 测试环境或者开发环境避免出现不可预期问题一般设置：spring.thymeleaf.cache=true 支持JSP的配置Spring Boot并不建议使用，但如果一定要使用，可以参考此工程作为脚手架：JSP支持 总的来说Kotlin 对于Spring Boot的支持非常好，只需要把Java语言的spring boot使用，翻译成kotlin就可以。 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"使用Spring Boot和Kotlin创建RESTfull API","slug":"kotlin/使用Spring-Boot和Kotlin创建RESTfull-API","date":"2018-02-02T16:00:25.000Z","updated":"2018-02-02T16:03:45.000Z","comments":true,"path":"posts/55365/","link":"","permalink":"http://quanke.name/posts/55365/","excerpt":"","text":"使用Kotlin 结合SpringBoot 开发一个RESTFul版本的 Hello World。 如果单单Kotlin 我是不相信在短时间内有产生多大的风波，但是如果Kotlin​ 能和 Java 开发神器 SpringBoot 结合起来，我感觉能飞。。。 1.首先新建Gradle的Kotlin工程打开IDEA ，File-&gt;New-&gt;Project 输入相关信息之后下一步： 一般GroupId为公司域名反着写，加上项目名字 建议选中 Use auto-import，自动导包 ,使用本地 Gradle，但是需要先安装Gradle（https://gradle.org/install/） 如果没有选择 使用本地 Gradle 项目创建完成之后Gradle的包需要下载，这个时间有点长，以前做Android就深受其苦，所有要做好心理准备，除非你有一个好用的FQ工具。 项目创建完成之后会生成一个Gradle文件build.gradle和settings.gradle,settings.gradle文件我们暂且不管，先看看build.gradle文件：group &apos;name.quanke.kotlin.restful&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123;ext.kotlin_version = &apos;1.2.10&apos;repositories &#123;mavenCentral()&#125;dependencies &#123;classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;&#125;&#125;apply plugin: &apos;kotlin&apos;repositories &#123;mavenCentral()&#125;dependencies &#123;compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot;&#125;compileKotlin &#123;kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123;kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 下载依赖和插件也是一个漫长痛苦的过程。各位不要心急，慢慢来，一次不行多试几次。 从生成的配置文件看，IDEA已经自动把Gradle构建Kotlin工程插件kotlin-gradle-plugin，以及Kotlin 标准库kotlin-stdlib添加到build.gradle文件中了。 2.配置build.gradle文件group &apos;name.quanke.kotlin.rest&apos;version &apos;1.0-SNAPSHOT&apos;buildscript &#123;ext.kotlin_version = &apos;1.2.10&apos;ext.spring_boot_version = &apos;1.5.4.RELEASE&apos;repositories &#123;mavenCentral()&#125;dependencies &#123;classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-plugin// org.jetbrains.kotlin:kotlin-allopen 是全开放编译器插件。我们使用Kotlin 调用Java的Spring AOP框架和库，需要类为 open（可被继承实现），而Kotlin 类和函数都是默认 final 的，这样我们需要为每个类和函数前面加上open修饰符。// 这样的代码写起来，可费事了。还好，我们有all-open 编译器插件。它会适配 Kotlin 以满足这些框架的需求，并使用指定的注解标注类而其成员无需显式使用 open 关键字打开。 例如，当我们使用 Spring 时，就不需要打开所有的类，跟我们在Java中写代码一样，只需要用相应的注解标注即可。classpath &quot;org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_version&quot;&#125;&#125;apply plugin: &apos;kotlin&apos;apply plugin: &quot;kotlin-spring&quot; // See https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-pluginapply plugin: &apos;org.springframework.boot&apos;jar &#123;baseName = &apos;0_2RestfulApi-service&apos;version = &apos;0.1.0&apos;&#125;repositories &#123;mavenCentral()&#125;dependencies &#123;compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version&quot;compile &apos;org.springframework.boot:spring-boot-starter-web&apos;testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;)&#125;compileKotlin &#123;kotlinOptions.jvmTarget = &quot;1.8&quot;&#125;compileTestKotlin &#123;kotlinOptions.jvmTarget = &quot;1.8&quot;&#125; 3.创建包在kotlin目录下面创建：name.quanke.kotlin.rest 注意：不能直接在kotlin目录下面写Application 类，不然会报错Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package 3.创建数据模型Greeting类：package name.quanke.kotlin.rest/*** Created by http://quanke.name on 2018/1/9.*/data class Greeting(val id: Long, val content: String) 如果是Java写的话，想象一下这需要多少行代码，看看kotlin，不明则厉。。。 5.创建GreetingControllerpackage name.quanke.kotlin.restimport org.springframework.web.bind.annotation.GetMappingimport org.springframework.web.bind.annotation.RequestParamimport org.springframework.web.bind.annotation.RestControllerimport java.util.concurrent.atomic.AtomicLong/*** Created by http://quanke.name on 2018/1/9.*/@RestControllerclass GreetingController &#123;val counter = AtomicLong()@GetMapping(&quot;/greeting&quot;)fun greeting(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;) name: String) =Greeting(counter.incrementAndGet(), &quot;Hello, $name&quot;)&#125; 6.创建Applicationpackage name.quanke.kotlin.restimport org.springframework.boot.SpringApplicationimport org.springframework.boot.autoconfigure.SpringBootApplication/*** Created by http://quanke.name on 2018/1/9.*/@SpringBootApplicationclass Applicationfun main(args: Array&lt;String&gt;) &#123;SpringApplication.run(Application::class.java, *args)&#125; 点击Gradle的bootRun： 或者点击 如果没有毛病，访问 http://127.0.0.1:8080/greeting?name=quanke.name 输出： 那么恭喜你，一个kotlin 和spring boot的web服务就这么搞定了。。。 服务默认是8080端口，如果8080端口刚好被占用了，那在resources目录下新建一个application.yml文件： server: port: 1234 把端口改成你想要的。 当然这只是开始的演示，么有什么卵用。。。之后可以用于生产的demo，呼之欲出。 欢迎关注： 《Spring Boot in kotlin 实战》","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"我的第一个Kotlin应用","slug":"kotlin/我的第一个Kotlin应用","date":"2018-02-02T14:38:51.000Z","updated":"2018-02-02T16:03:31.000Z","comments":true,"path":"posts/41862/","link":"","permalink":"http://quanke.name/posts/41862/","excerpt":"","text":"今天开始正式学习Kotlin这门语言，学习之前看了很多关于Kotlin的推广文，本来一门新的语言很难普及，有Google站台，心里有底了很多，本人做过Android开发，所以对于Android相关的东西还是比较关注的。 废话说了这么多，现在正式开始我的第一个Kotlin应用，当然从打印Hello World开始。 Kotlin有多种方式打印Hello World，比如通过命令行、通过应用等。按道理通过命令行打印“Hello World”比较简单，但是我今天不去讲命令行的实现方式，因为在之后的学习中用的很少、而且命令行的形式比较简单。所有我们主要是通过应用的方式去学习。有一些教程使用 gradle去创建项目，我觉得第一个Kotlin应用太麻烦了，怕不懂，所以我今天实现一个极其简单的Kotlin应用。 我这里用的IDE是Intelli IDEA，亲儿子当然要用，不解释，如果亲一定要用其他的，不好意思，我这里不提供方法，因为我也不会。 首先安装最新版本的Intelli IDEA，File-&gt;New-&gt;Project 选择 Kotlin -&gt; Kotlin/JVM 新建完项目之后，新建HelloWorld.kt类： package name.quanke.kotlin.helloworldclass HelloWorld &#123;&#125;/*** Created by quanke.name on 2018/1/8.*/fun main(args: Array&lt;String&gt;) &#123;println(&quot;Hello World!&quot;)&#125; 运行后输出：Hello World! 到此为止我的第一个Kotlin应用结束了！ 这是《Spring Boot in kotlin 实战》的开始篇，欢迎关注！","categories":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://quanke.name/tags/kotlin/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://quanke.name/tags/spring-boot/"}],"keywords":[{"name":"Spring Boot与kotlin实战","slug":"Spring-Boot与kotlin实战","permalink":"http://quanke.name/categories/Spring-Boot与kotlin实战/"}]},{"title":"Elasticsearch Java API 搜索之Scrolls(四)","slug":"es/Elasticsearch-Java-API-搜索之Scrolls-四","date":"2017-12-06T14:47:00.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/3267/","link":"","permalink":"http://quanke.name/posts/3267/","excerpt":"","text":"Using scrolls in Java首先需要阅读 scroll documentation 一般搜索请求都是返回一”页”数据，无论数据量多大都一起返回给用户，Scroll API可以允许我们检索大量数据（甚至全部数据）。Scroll API允许我们做一个初始阶段搜索并且持续批量从Elasticsearch里拉取结果直到没有结果剩下。这有点像传统数据库里的cursors（游标）。Scroll API的创建并不是为了实时的用户响应，而是为了处理大量的数据（Scrolling is not intended for real time user requests, but rather for processing large amounts of data）。从 scroll 请求返回的结果只是反映了 search 发生那一时刻的索引状态，就像一个快照(The results that are returned from a scroll request reflect the state of the index at the time that the initial search request was made, like a snapshot in time)。后续的对文档的改动（索引、更新或者删除）都只会影响后面的搜索请求。 import static org.elasticsearch.index.query.QueryBuilders.*; QueryBuilder qb = termQuery(&quot;multi&quot;, &quot;test&quot;);SearchResponse scrollResp = client.prepareSearch(test) .addSort(FieldSortBuilder.DOC_FIELD_NAME, SortOrder.ASC) .setScroll(new TimeValue(60000)) //为了使用 scroll，初始搜索请求应该在查询中指定 scroll 参数，告诉 Elasticsearch 需要保持搜索的上下文环境多长时间（滚动时间） .setQuery(qb) .setSize(100).get(); //max of 100 hits will be returned for each scroll//Scroll until no hits are returneddo &#123; for (SearchHit hit : scrollResp.getHits().getHits()) &#123; //Handle the hit... &#125; scrollResp = client.prepareSearchScroll(scrollResp.getScrollId()).setScroll(new TimeValue(60000)).execute().actionGet();&#125; while(scrollResp.getHits().getHits().length != 0); // Zero hits mark the end of the scroll and the while loop. 如果超过滚动时间，继续使用该滚动ID搜索数据，则会报错： Caused by: SearchContextMissingException[No search context found for id [2861]] at org.elasticsearch.search.SearchService.findContext(SearchService.java:613) at org.elasticsearch.search.SearchService.executeQueryPhase(SearchService.java:403) at org.elasticsearch.search.action.SearchServiceTransportAction$SearchQueryScrollTransportHandler.messageReceived(SearchServiceTransportAction.java:384) at org.elasticsearch.search.action.SearchServiceTransportAction$SearchQueryScrollTransportHandler.messageReceived(SearchServiceTransportAction.java:381) at org.elasticsearch.transport.TransportRequestHandler.messageReceived(TransportRequestHandler.java:33) at org.elasticsearch.transport.RequestHandlerRegistry.processMessageReceived(RequestHandlerRegistry.java:75) at org.elasticsearch.transport.TransportService$4.doRun(TransportService.java:376) at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) 虽然当滚动有效时间已过，搜索上下文(Search Context)会自动被清除，但是一值保持滚动代价也是很大的，所以当我们不在使用滚动时要尽快使用Clear-Scroll API进行清除。 清除Scroll/** * 清除滚动ID * @param client * @param scrollIdList * @return */ public static boolean clearScroll(Client client, List&lt;String&gt; scrollIdList)&#123; ClearScrollRequestBuilder clearScrollRequestBuilder = client.prepareClearScroll(); clearScrollRequestBuilder.setScrollIds(scrollIdList); ClearScrollResponse response = clearScrollRequestBuilder.get(); return response.isSucceeded(); &#125; /** * 清除滚动ID * @param client * @param scrollId * @return */ public static boolean clearScroll(Client client, String scrollId)&#123; ClearScrollRequestBuilder clearScrollRequestBuilder = client.prepareClearScroll(); clearScrollRequestBuilder.addScrollId(scrollId); ClearScrollResponse response = clearScrollRequestBuilder.get(); return response.isSucceeded(); &#125; 实例public class ScrollsAPI extends ElasticsearchClientBase &#123; private String scrollId; @Test public void testScrolls() throws Exception &#123; SearchResponse scrollResp = client.prepareSearch(&quot;twitter&quot;) .addSort(FieldSortBuilder.DOC_FIELD_NAME, SortOrder.ASC) .setScroll(new TimeValue(60000)) //为了使用 scroll，初始搜索请求应该在查询中指定 scroll 参数，告诉 Elasticsearch 需要保持搜索的上下文环境多长时间（滚动时间） .setQuery(QueryBuilders.termQuery(&quot;user&quot;, &quot;kimchy&quot;)) // Query 查询条件 .setSize(5).get(); //max of 100 hits will be returned for each scroll //Scroll until no hits are returned scrollId = scrollResp.getScrollId(); do &#123; for (SearchHit hit : scrollResp.getHits().getHits()) &#123; //Handle the hit... System.out.println(&quot;&quot; + hit.getSource().toString()); &#125; scrollResp = client.prepareSearchScroll(scrollId).setScroll(new TimeValue(60000)).execute().actionGet(); &#125; while (scrollResp.getHits().getHits().length != 0); // Zero hits mark the end of the scroll and the while loop. &#125; @Override public void tearDown() throws Exception &#123; ClearScrollRequestBuilder clearScrollRequestBuilder = client.prepareClearScroll(); clearScrollRequestBuilder.addScrollId(scrollId); ClearScrollResponse response = clearScrollRequestBuilder.get(); if (response.isSucceeded()) &#123; System.out.println(&quot;成功清除&quot;); &#125; super.tearDown(); &#125;&#125; ScrollsAPI.java 本手册完整实例","categories":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}],"tags":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/tags/es/"},{"name":"大数据","slug":"bdaga","permalink":"http://quanke.name/tags/bdaga/"}],"keywords":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}]},{"title":"Elasticsearch Java API 搜索之简介（三）","slug":"es/Elasticsearch-Java-API-搜索（三）","date":"2017-12-06T14:25:00.000Z","updated":"2018-02-02T15:26:11.000Z","comments":true,"path":"posts/44811/","link":"","permalink":"http://quanke.name/posts/44811/","excerpt":"","text":"Elasticsearch Java API 搜索之简介搜索查询，返回查询匹配的结果，搜索一个index / type 或者多个index / type，可以使用 query Java API 作为查询条件，下面是例子： import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.action.search.SearchType;import org.elasticsearch.index.query.QueryBuilders.*; SearchResponse response = client.prepareSearch(&quot;index1&quot;, &quot;index2&quot;) .setTypes(&quot;type1&quot;, &quot;type2&quot;) .setSearchType(SearchType.DFS_QUERY_THEN_FETCH) .setQuery(QueryBuilders.termQuery(&quot;multi&quot;, &quot;test&quot;)) // Query 查询条件 .setPostFilter(QueryBuilders.rangeQuery(&quot;age&quot;).from(12).to(18)) // Filter 过滤 .setFrom(0).setSize(60).setExplain(true) .get(); 所有的参数都是可选的，下面是最简单的调用： // MatchAll on the whole cluster with all default optionsSearchResponse response = client.prepareSearch().get(); 尽管Java API默认提供QUERY_AND_FETCH 和 DFS_QUERY_AND_FETCH 两种 search types ，但是这种模式应该由系统选择，用户不要手动指定 更多请移步 REST search 文档 如何有任何问题请关注微信公众号给我留言","categories":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}],"tags":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/tags/es/"},{"name":"大数据","slug":"bdaga","permalink":"http://quanke.name/tags/bdaga/"}],"keywords":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}]},{"title":"多种方式解决spring boot swagger ui使用 nginx 部署后无法使用问题","slug":"nginx/种方式解决spring-boot-swagger-ui使用-nginx-部署后无法使用问题","date":"2017-12-05T14:19:00.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/21506/","link":"","permalink":"http://quanke.name/posts/21506/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 spring boot 使用 swagger ui 做接口文档，很是方便 本地测试都没有问题 将一个Spring boot工程部署到生产环境， 配置nginx： server &#123; listen 80; server_name quanke.name; location / &#123; proxy_pass http://127.0.0.1:3101; &#125;&#125; 浏览器中访问： quanke.name, 选中某一接口点击try it out,显示: No Content。 Request URL:http://127.0.0.1:3101/test 而不是 http://quanke.name/test 通过朋友+搜索知道有两种方法解决此问题： 第一种：修改nginx配置文件把server &#123; listen 80; server_name quanke.name; location / &#123; proxy_pass http://127.0.0.1:3101; &#125;&#125; 修改为： server &#123; listen 80; server_name quanke.name; location / &#123; proxy_pass http://127.0.0.1:3101; proxy_set_header Host $host; # 指定host &#125;&#125; 第二种：启动工程时显式添加属性Java 启动的时候指定swagger.v2.host： -Dspringfox.documentation.swagger.v2.host=quanke.name 启动命令实例： java -jar -Dspringfox.documentation.swagger.v2.host=quanke.name /data/app/quanke/api.jar 或者在配置文件（application.properties）中进行配置 如何有任何问题请关注微信公众号给我留言","categories":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}],"tags":[{"name":"java","slug":"java","permalink":"http://quanke.name/tags/java/"},{"name":"spirng boot","slug":"spirng-boot","permalink":"http://quanke.name/tags/spirng-boot/"},{"name":"nginx","slug":"nginx","permalink":"http://quanke.name/tags/nginx/"},{"name":"swagger ui","slug":"swagger-ui","permalink":"http://quanke.name/tags/swagger-ui/"}],"keywords":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}]},{"title":"Elasticsearch Java API 索引的增删改查（二）","slug":"es/Easticsearch-Java-API-索引的增删改查（二）","date":"2017-11-15T12:10:00.000Z","updated":"2018-02-02T15:26:27.000Z","comments":true,"path":"posts/51297/","link":"","permalink":"http://quanke.name/posts/51297/","excerpt":"","text":"本节介绍以下 CRUD API： 单文档 APIs Index API Get API Delete API Delete By Query API Update API 多文档 APIs Multi Get API Bulk API Using Bulk Processor Multi Get APIBulk API 注意:所有的单文档的CRUD API，index参数只能接受单一的索引库名称，或者是一个指向单一索引库的alias。 Index APIIndex API 允许我们存储一个JSON格式的文档，使数据可以被搜索。文档通过index、type、id唯一确定。我们可以自己提供一个id，或者也使用Index API 为我们自动生成一个。 这里有几种不同的方式来产生JSON格式的文档(document)： 手动方式，使用原生的byte[]或者String 使用Map方式，会自动转换成与之等价的JSON 使用第三方库来序列化beans，如Jackson 使用内置的帮助类 XContentFactory.jsonBuilder() 手动方式数据格式String json = &quot;&#123;&quot; + &quot;\\&quot;user\\&quot;:\\&quot;kimchy\\&quot;,&quot; + &quot;\\&quot;postDate\\&quot;:\\&quot;2013-01-30\\&quot;,&quot; + &quot;\\&quot;message\\&quot;:\\&quot;trying out Elasticsearch\\&quot;&quot; + &quot;&#125;&quot;; 实例/** * 手动生成JSON */ @Test public void CreateJSON()&#123; String json = &quot;&#123;&quot; + &quot;\\&quot;user\\&quot;:\\&quot;fendo\\&quot;,&quot; + &quot;\\&quot;postDate\\&quot;:\\&quot;2013-01-30\\&quot;,&quot; + &quot;\\&quot;message\\&quot;:\\&quot;Hell word\\&quot;&quot; + &quot;&#125;&quot;; IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;) .setSource(json) .get(); System.out.println(response.getResult()); &#125; Map方式Map是key:value数据类型，可以代表json结构. Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;();json.put(&quot;user&quot;,&quot;kimchy&quot;);json.put(&quot;postDate&quot;,new Date());json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;); 实例 /** * 使用集合 */ @Test public void CreateList()&#123; Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;(); json.put(&quot;user&quot;,&quot;kimchy&quot;); json.put(&quot;postDate&quot;,&quot;2013-01-30&quot;); json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;); IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;) .setSource(json) .get(); System.out.println(response.getResult()); &#125; 序列化方式ElasticSearch已经使用了jackson，可以直接使用它把javabean转为json. import com.fasterxml.jackson.databind.*;// instance a json mapperObjectMapper mapper = new ObjectMapper(); // create once, reuse// generate jsonbyte[] json = mapper.writeValueAsBytes(yourbeaninstance); 实例/** * 使用JACKSON序列化 * @throws Exception */ @Test public void CreateJACKSON() throws Exception&#123; CsdnBlog csdn=new CsdnBlog(); csdn.setAuthor(&quot;fendo&quot;); csdn.setContent(&quot;这是JAVA书籍&quot;); csdn.setTag(&quot;C&quot;); csdn.setView(&quot;100&quot;); csdn.setTitile(&quot;编程&quot;); csdn.setDate(new Date().toString()); // instance a json mapper ObjectMapper mapper = new ObjectMapper(); // create once, reuse // generate json byte[] json = mapper.writeValueAsBytes(csdn); IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;) .setSource(json) .get(); System.out.println(response.getResult()); &#125; XContentBuilder帮助类方式ElasticSearch提供了一个内置的帮助类XContentBuilder来产生JSON文档 // Index nameString _index = response.getIndex();// Type nameString _type = response.getType();// Document ID (generated or not)String _id = response.getId();// Version (if it&apos;s the first time you index this document, you will get: 1)long _version = response.getVersion();// status has stored current instance statement.RestStatus status = response.status(); 实例/** * 使用ElasticSearch 帮助类 * @throws IOException */ @Test public void CreateXContentBuilder() throws IOException&#123; XContentBuilder builder = XContentFactory.jsonBuilder() .startObject() .field(&quot;user&quot;, &quot;ccse&quot;) .field(&quot;postDate&quot;, new Date()) .field(&quot;message&quot;, &quot;this is Elasticsearch&quot;) .endObject(); IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodata&quot;).setSource(builder).get(); System.out.println(&quot;创建成功!&quot;); &#125; 综合实例 import java.io.IOException; import java.net.InetAddress; import java.net.UnknownHostException; import java.util.Date; import java.util.HashMap; import java.util.Map; import org.elasticsearch.action.index.IndexResponse; import org.elasticsearch.client.transport.TransportClient; import org.elasticsearch.common.settings.Settings; import org.elasticsearch.common.transport.InetSocketTransportAddress; import org.elasticsearch.common.xcontent.XContentBuilder; import org.elasticsearch.common.xcontent.XContentFactory; import org.elasticsearch.transport.client.PreBuiltTransportClient; import org.junit.Before; import org.junit.Test; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; public class CreateIndex &#123; private TransportClient client; @Before public void getClient() throws Exception&#123; //设置集群名称 Settings settings = Settings.builder().put(&quot;cluster.name&quot;, &quot;my-application&quot;).build();// 集群名 //创建client client = new PreBuiltTransportClient(settings) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;127.0.0.1&quot;), 9300)); &#125; /** * 手动生成JSON */ @Test public void CreateJSON()&#123; String json = &quot;&#123;&quot; + &quot;\\&quot;user\\&quot;:\\&quot;fendo\\&quot;,&quot; + &quot;\\&quot;postDate\\&quot;:\\&quot;2013-01-30\\&quot;,&quot; + &quot;\\&quot;message\\&quot;:\\&quot;Hell word\\&quot;&quot; + &quot;&#125;&quot;; IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;) .setSource(json) .get(); System.out.println(response.getResult()); &#125; /** * 使用集合 */ @Test public void CreateList()&#123; Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;(); json.put(&quot;user&quot;,&quot;kimchy&quot;); json.put(&quot;postDate&quot;,&quot;2013-01-30&quot;); json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;); IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;) .setSource(json) .get(); System.out.println(response.getResult()); &#125; /** * 使用JACKSON序列化 * @throws Exception */ @Test public void CreateJACKSON() throws Exception&#123; CsdnBlog csdn=new CsdnBlog(); csdn.setAuthor(&quot;fendo&quot;); csdn.setContent(&quot;这是JAVA书籍&quot;); csdn.setTag(&quot;C&quot;); csdn.setView(&quot;100&quot;); csdn.setTitile(&quot;编程&quot;); csdn.setDate(new Date().toString()); // instance a json mapper ObjectMapper mapper = new ObjectMapper(); // create once, reuse // generate json byte[] json = mapper.writeValueAsBytes(csdn); IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodate&quot;) .setSource(json) .get(); System.out.println(response.getResult()); &#125; /** * 使用ElasticSearch 帮助类 * @throws IOException */ @Test public void CreateXContentBuilder() throws IOException&#123; XContentBuilder builder = XContentFactory.jsonBuilder() .startObject() .field(&quot;user&quot;, &quot;ccse&quot;) .field(&quot;postDate&quot;, new Date()) .field(&quot;message&quot;, &quot;this is Elasticsearch&quot;) .endObject(); IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendodata&quot;).setSource(builder).get(); System.out.println(&quot;创建成功!&quot;); &#125; &#125; 你还可以通过startArray(string)和endArray()方法添加数组。.field()方法可以接受多种对象类型。你可以给它传递数字、日期、甚至其他XContentBuilder对象。 Get API根据id查看文档： GetResponse response = client.prepareGet(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;).get(); 更多请查看 rest get API 文档 配置线程operationThreaded 设置为 true 是在不同的线程里执行此次操作 下面的例子是operationThreaded 设置为 false ：GetResponse response = client.prepareGet(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;) .setOperationThreaded(false) .get(); Delete API根据ID删除： DeleteResponse response = client.prepareDelete(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;).get(); 更多请查看 delete API 文档 配置线程operationThreaded 设置为 true 是在不同的线程里执行此次操作 下面的例子是operationThreaded 设置为 false ：GetResponse response = client.prepareGet(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;) .setOperationThreaded(false) .get(); DeleteResponse response = client.prepareDelete(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;) .setOperationThreaded(false) .get(); Delete By Query API通过查询条件删除 BulkByScrollResponse response = DeleteByQueryAction.INSTANCE.newRequestBuilder(client) .filter(QueryBuilders.matchQuery(&quot;gender&quot;, &quot;male&quot;)) //查询条件 .source(&quot;persons&quot;) //index(索引名) .get(); //执行long deleted = response.getDeleted(); //删除文档的数量 如果需要执行的时间比较长，可以使用异步的方式处理,结果在回调里面获取 DeleteByQueryAction.INSTANCE.newRequestBuilder(client) .filter(QueryBuilders.matchQuery(&quot;gender&quot;, &quot;male&quot;)) //查询 .source(&quot;persons&quot;) //index(索引名) .execute(new ActionListener&lt;BulkByScrollResponse&gt;() &#123; //回调监听 @Override public void onResponse(BulkByScrollResponse response) &#123; long deleted = response.getDeleted(); //删除文档的数量 &#125; @Override public void onFailure(Exception e) &#123; // Handle the exception &#125; &#125;); Update API有两种方式更新索引： 创建 UpdateRequest,通过client发送； 使用 prepareUpdate() 方法； 使用UpdateRequestUpdateRequest updateRequest = new UpdateRequest();updateRequest.index(&quot;index&quot;);updateRequest.type(&quot;type&quot;);updateRequest.id(&quot;1&quot;);updateRequest.doc(jsonBuilder() .startObject() .field(&quot;gender&quot;, &quot;male&quot;) .endObject());client.update(updateRequest).get(); 使用 prepareUpdate() 方法 这里官方的示例有问题，new Script（）参数错误，所以一下代码是我自己写的（2017/11/10） client.prepareUpdate(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;) .setScript(new Script(&quot;ctx._source.gender = \\&quot;male\\&quot;&quot; ,ScriptService.ScriptType.INLINE, null, null))//脚本可以是本地文件存储的，如果使用文件存储的脚本，需要设置 ScriptService.ScriptType.FILE .get();client.prepareUpdate(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;) .setDoc(jsonBuilder() //合并到现有文档 .startObject() .field(&quot;gender&quot;, &quot;male&quot;) .endObject()) .get(); Update by script使用脚本更新文档 UpdateRequest updateRequest = new UpdateRequest(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;) .script(new Script(&quot;ctx._source.gender = \\&quot;male\\&quot;&quot;));client.update(updateRequest).get(); Update by merging documents合并文档 UpdateRequest updateRequest = new UpdateRequest(&quot;index&quot;, &quot;type&quot;, &quot;1&quot;) .doc(jsonBuilder() .startObject() .field(&quot;gender&quot;, &quot;male&quot;) .endObject());client.update(updateRequest).get(); Upsert更新插入,如果存在文档就更新，如果不存在就插入 IndexRequest indexRequest = new IndexRequest(&quot;index&quot;, &quot;type&quot;, &quot;1&quot;) .source(jsonBuilder() .startObject() .field(&quot;name&quot;, &quot;Joe Smith&quot;) .field(&quot;gender&quot;, &quot;male&quot;) .endObject());UpdateRequest updateRequest = new UpdateRequest(&quot;index&quot;, &quot;type&quot;, &quot;1&quot;) .doc(jsonBuilder() .startObject() .field(&quot;gender&quot;, &quot;male&quot;) .endObject()) .upsert(indexRequest); //如果不存在此文档 ，就增加 `indexRequest`client.update(updateRequest).get(); 如果 index/type/1 存在，类似下面的文档： &#123; &quot;name&quot; : &quot;Joe Dalton&quot;, &quot;gender&quot;: &quot;male&quot; &#125; 如果不存在，会插入新的文档： &#123; &quot;name&quot; : &quot;Joe Smith&quot;, &quot;gender&quot;: &quot;male&quot;&#125; Multi Get API一次获取多个文档 MultiGetResponse multiGetItemResponses = client.prepareMultiGet() .add(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;) //一个id的方式 .add(&quot;twitter&quot;, &quot;tweet&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;) //多个id的方式 .add(&quot;another&quot;, &quot;type&quot;, &quot;foo&quot;) //可以从另外一个索引获取 .get();for (MultiGetItemResponse itemResponse : multiGetItemResponses) &#123; //迭代返回值 GetResponse response = itemResponse.getResponse(); if (response.isExists()) &#123; //判断是否存在 String json = response.getSourceAsString(); //_source 字段 &#125;&#125; 更多请浏览REST multi get 文档 Bulk APIBulk API，批量插入： import static org.elasticsearch.common.xcontent.XContentFactory.*; BulkRequestBuilder bulkRequest = client.prepareBulk();// either use client#prepare, or use Requests# to directly build index/delete requestsbulkRequest.add(client.prepareIndex(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;) .setSource(jsonBuilder() .startObject() .field(&quot;user&quot;, &quot;kimchy&quot;) .field(&quot;postDate&quot;, new Date()) .field(&quot;message&quot;, &quot;trying out Elasticsearch&quot;) .endObject() ) );bulkRequest.add(client.prepareIndex(&quot;twitter&quot;, &quot;tweet&quot;, &quot;2&quot;) .setSource(jsonBuilder() .startObject() .field(&quot;user&quot;, &quot;kimchy&quot;) .field(&quot;postDate&quot;, new Date()) .field(&quot;message&quot;, &quot;another post&quot;) .endObject() ) );BulkResponse bulkResponse = bulkRequest.get();if (bulkResponse.hasFailures()) &#123; // process failures by iterating through each bulk response item //处理失败&#125; 使用 Bulk ProcessorBulkProcessor 提供了一个简单的接口，在给定的大小数量上定时批量自动请求 创建BulkProcessor实例首先创建BulkProcessor实例 import org.elasticsearch.action.bulk.BackoffPolicy;import org.elasticsearch.action.bulk.BulkProcessor;import org.elasticsearch.common.unit.ByteSizeUnit;import org.elasticsearch.common.unit.ByteSizeValue;import org.elasticsearch.common.unit.TimeValue; BulkProcessor bulkProcessor = BulkProcessor.builder( client, //增加elasticsearch客户端 new BulkProcessor.Listener() &#123; @Override public void beforeBulk(long executionId, BulkRequest request) &#123; ... &#125; //调用bulk之前执行 ，例如你可以通过request.numberOfActions()方法知道numberOfActions @Override public void afterBulk(long executionId, BulkRequest request, BulkResponse response) &#123; ... &#125; //调用bulk之后执行 ，例如你可以通过request.hasFailures()方法知道是否执行失败 @Override public void afterBulk(long executionId, BulkRequest request, Throwable failure) &#123; ... &#125; //调用失败抛 Throwable &#125;) .setBulkActions(10000) //每次10000请求 .setBulkSize(new ByteSizeValue(5, ByteSizeUnit.MB)) //拆成5mb一块 .setFlushInterval(TimeValue.timeValueSeconds(5)) //无论请求数量多少，每5秒钟请求一次。 .setConcurrentRequests(1) //设置并发请求的数量。值为0意味着只允许执行一个请求。值为1意味着允许1并发请求。 .setBackoffPolicy( BackoffPolicy.exponentialBackoff(TimeValue.timeValueMillis(100), 3))//设置自定义重复请求机制，最开始等待100毫秒，之后成倍更加，重试3次，当一次或多次重复请求失败后因为计算资源不够抛出 EsRejectedExecutionException 异常，可以通过BackoffPolicy.noBackoff()方法关闭重试机制 .build(); BulkProcessor 默认设置 bulkActions 1000 bulkSize 5mb 不设置flushInterval concurrentRequests 为 1 ，异步执行 backoffPolicy 重试 8次，等待50毫秒 增加requests然后增加requests到BulkProcessorbulkProcessor.add(new IndexRequest(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;).source(/* your doc here */));bulkProcessor.add(new DeleteRequest(&quot;twitter&quot;, &quot;tweet&quot;, &quot;2&quot;)); 关闭 Bulk Processor当所有文档都处理完成，使用awaitClose 或 close 方法关闭BulkProcessor: bulkProcessor.awaitClose(10, TimeUnit.MINUTES); 或 bulkProcessor.close(); 在测试中使用Bulk Processor如果你在测试种使用Bulk Processor可以执行同步方法BulkProcessor bulkProcessor = BulkProcessor.builder(client, new BulkProcessor.Listener() &#123; /* Listener methods */ &#125;) .setBulkActions(10000) .setConcurrentRequests(0) .build();// Add your requestsbulkProcessor.add(/* Your requests */);// Flush any remaining requestsbulkProcessor.flush();// Or close the bulkProcessor if you don&apos;t need it anymorebulkProcessor.close();// Refresh your indicesclient.admin().indices().prepareRefresh().get();// Now you can start searching!client.prepareSearch().get(); 所有实例 已经上传到Git 更多请浏览 spring-boot-starter-es 开源项目 如何有任何问题请关注微信公众号给我留言","categories":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}],"tags":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/tags/es/"},{"name":"大数据","slug":"bdaga","permalink":"http://quanke.name/tags/bdaga/"}],"keywords":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}]},{"title":"Elasticsearch Java API - 客户端连接(TransportClient，PreBuiltXPackTransportClient)（一）","slug":"es/Elasticsearch-Java-API-客户端连接，TransportClient，PreBuiltXPackTransportClient（一）副本","date":"2017-11-13T11:01:00.000Z","updated":"2018-02-02T15:25:37.000Z","comments":true,"path":"posts/39952/","link":"","permalink":"http://quanke.name/posts/39952/","excerpt":"","text":"Elasticsearch Java API 客户端连接一个是TransportClient，一个是NodeClient，还有一个XPackTransportClient TransportClient： 作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。 NodeClient 作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的。 XPackTransportClient： 服务安装了 x-pack 插件 重要：客户端版本应该和服务端版本保持一致 TransportClient旨在被Java高级REST客户端取代，该客户端执行HTTP请求而不是序列化的Java请求。 在即将到来的Elasticsearch版本中将不赞成使用TransportClient，建议使用Java高级REST客户端。 上面的警告比较尴尬，但是在 5xx版本中使用还是没有问题的，可能使用rest 客户端兼容性更好做一些。 Elasticsearch Java Rest API 手册 Maven RepositoryElasticsearch Java API包已经上传到 Maven Central 在pom.xml文件中增加： transport 版本号最好就是与Elasticsearch版本号一致。 &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;5.6.3&lt;/version&gt;&lt;/dependency&gt; Transport Client不设置集群名称// on startup//此步骤添加IP，至少一个，如果设置了&quot;client.transport.sniff&quot;= true 一个就够了，因为添加了自动嗅探配置TransportClient client = new PreBuiltTransportClient(Settings.EMPTY) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host1&quot;), 9300)) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host2&quot;), 9300));// on shutdown 关闭clientclient.close(); 设置集群名称Settings settings = Settings.builder() .put(&quot;cluster.name&quot;, &quot;myClusterName&quot;).build(); //设置ES实例的名称TransportClient client = new PreBuiltTransportClient(settings); //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中//Add transport addresses and do something with the client... 增加自动嗅探配置Settings settings = Settings.builder() .put(&quot;client.transport.sniff&quot;, true).build();TransportClient client = new PreBuiltTransportClient(settings); 其他配置client.transport.ignore_cluster_name //设置 true ，忽略连接节点集群名验证client.transport.ping_timeout //ping一个节点的响应时间 默认5秒client.transport.nodes_sampler_interval //sample/ping 节点的时间间隔，默认是5s 对于ES Client，有两种形式，一个是TransportClient，一个是NodeClient。两个的区别为：TransportClient作为一个外部访问者，通过HTTP去请求ES的集群，对于集群而言，它是一个外部因素。NodeClient顾名思义，是作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的，不像TransportClient那样，ES集群对它一无所知。NodeClient通信的性能会更好，但是因为是ES的一环，所以它出问题，也会给ES集群带来问题。NodeClient可以设置不作为数据节点，在elasticsearch.yml中设置，这样就不会在此节点上分配数据。 如果用ES的节点，仁者见仁智者见智。 实例package name.quanke.es.study;import name.quanke.es.study.util.Utils;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.transport.InetSocketTransportAddress;import org.elasticsearch.transport.client.PreBuiltTransportClient;import org.junit.After;import org.junit.Before;import java.net.InetAddress;/** * Elasticsearch 5.5.1 的client 和 ElasticsearchTemplate的初始化 * 作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。 * Created by http://quanke.name on 2017/11/10. */public class ElasticsearchClient &#123; protected TransportClient client; @Before public void setUp() throws Exception &#123; Settings esSettings = Settings.builder() .put(&quot;cluster.name&quot;, &quot;utan-es&quot;) //设置ES实例的名称 .put(&quot;client.transport.sniff&quot;, true) //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中 .build(); /** * 这里的连接方式指的是没有安装x-pack插件,如果安装了x-pack则参考&#123;@link ElasticsearchXPackClient&#125; * 1. java客户端的方式是以tcp协议在9300端口上进行通信 * 2. http客户端的方式是以http协议在9200端口上进行通信 */ client = new PreBuiltTransportClient(esSettings) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300)); System.out.println(&quot;ElasticsearchClient 连接成功&quot;); &#125; @After public void tearDown() throws Exception &#123; if (client != null) &#123; client.close(); &#125; &#125; protected void println(SearchResponse searchResponse) &#123; Utils.println(searchResponse); &#125;&#125; 本实例代码已经上传到 Git ElasticsearchClient.java 所有实例 已经上传到Git XPackTransportClient如果 ElasticSearch 服务安装了 x-pack 插件，需要PreBuiltXPackTransportClient实例才能访问 使用Maven管理项目，把下面代码增加到pom.xml; 一定要修改默认仓库地址为https://artifacts.elastic.co/maven ，因为这个库没有上传到Maven中央仓库,如果有自己的 maven ，请配置代理 &lt;project ...&gt; &lt;repositories&gt; &lt;!-- add the elasticsearch repo --&gt; &lt;repository&gt; &lt;id&gt;elasticsearch-releases&lt;/id&gt; &lt;url&gt;https://artifacts.elastic.co/maven&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; ... &lt;/repositories&gt; ... &lt;dependencies&gt; &lt;!-- add the x-pack jar as a dependency --&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;x-pack-transport&lt;/artifactId&gt; &lt;version&gt;5.6.3&lt;/version&gt; &lt;/dependency&gt; ... &lt;/dependencies&gt; ... &lt;/project&gt; 实例/** * Elasticsearch XPack Client * Created by http://quanke.name on 2017/11/10. */public class ElasticsearchXPackClient &#123; protected TransportClient client; @Before public void setUp() throws Exception &#123; /** * 如果es集群安装了x-pack插件则以此种方式连接集群 * 1. java客户端的方式是以tcp协议在9300端口上进行通信 * 2. http客户端的方式是以http协议在9200端口上进行通信 */ Settings settings = Settings.builder() .put(&quot;xpack.security.user&quot;, &quot;elastic:utan100&quot;) .put(&quot;cluster.name&quot;, &quot;utan-es&quot;) .build(); client = new PreBuiltXPackTransportClient(settings) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300));// final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();// credentialsProvider.setCredentials(AuthScope.ANY,// new UsernamePasswordCredentials(&quot;elastic&quot;, &quot;utan100&quot;)); System.out.println(&quot;ElasticsearchXPackClient 启动成功&quot;); &#125; @Test public void testClientConnection() throws Exception &#123; System.out.println(&quot;--------------------------&quot;); &#125; @After public void tearDown() throws Exception &#123; if (client != null) &#123; client.close(); &#125; &#125; protected void println(SearchResponse searchResponse) &#123; Utils.println(searchResponse); &#125;&#125; 本实例代码已经上传到 Git ElasticsearchXPackClient.java 所有实例 已经上传到Git 更多请浏览 spring-boot-starter-es 开源项目 如何有任何问题请关注微信公众号给我留言","categories":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}],"tags":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/tags/es/"},{"name":"大数据","slug":"bdaga","permalink":"http://quanke.name/tags/bdaga/"},{"name":"Java","slug":"Java","permalink":"http://quanke.name/tags/Java/"},{"name":"API","slug":"API","permalink":"http://quanke.name/tags/API/"}],"keywords":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}]},{"title":"Elasticsearch Java API - 客户端连接(TransportClient，PreBuiltXPackTransportClient)（一）","slug":"es/Elasticsearch-Java-API-客户端连接，TransportClient，PreBuiltXPackTransportClient（一）","date":"2017-11-13T11:01:00.000Z","updated":"2018-02-02T15:25:32.000Z","comments":true,"path":"posts/39952/","link":"","permalink":"http://quanke.name/posts/39952/","excerpt":"","text":"Elasticsearch Java API 客户端连接一个是TransportClient，一个是NodeClient，还有一个XPackTransportClient TransportClient： 作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。 NodeClient 作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的。 XPackTransportClient： 服务安装了 x-pack 插件 重要：客户端版本应该和服务端版本保持一致 TransportClient旨在被Java高级REST客户端取代，该客户端执行HTTP请求而不是序列化的Java请求。 在即将到来的Elasticsearch版本中将不赞成使用TransportClient，建议使用Java高级REST客户端。 上面的警告比较尴尬，但是在 5xx版本中使用还是没有问题的，可能使用rest 客户端兼容性更好做一些。 Elasticsearch Java Rest API 手册 Maven RepositoryElasticsearch Java API包已经上传到 Maven Central 在pom.xml文件中增加： transport 版本号最好就是与Elasticsearch版本号一致。 &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;5.6.3&lt;/version&gt;&lt;/dependency&gt; Transport Client不设置集群名称// on startup//此步骤添加IP，至少一个，如果设置了&quot;client.transport.sniff&quot;= true 一个就够了，因为添加了自动嗅探配置TransportClient client = new PreBuiltTransportClient(Settings.EMPTY) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host1&quot;), 9300)) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host2&quot;), 9300));// on shutdown 关闭clientclient.close(); 设置集群名称Settings settings = Settings.builder() .put(&quot;cluster.name&quot;, &quot;myClusterName&quot;).build(); //设置ES实例的名称TransportClient client = new PreBuiltTransportClient(settings); //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中//Add transport addresses and do something with the client... 增加自动嗅探配置Settings settings = Settings.builder() .put(&quot;client.transport.sniff&quot;, true).build();TransportClient client = new PreBuiltTransportClient(settings); 其他配置client.transport.ignore_cluster_name //设置 true ，忽略连接节点集群名验证client.transport.ping_timeout //ping一个节点的响应时间 默认5秒client.transport.nodes_sampler_interval //sample/ping 节点的时间间隔，默认是5s 对于ES Client，有两种形式，一个是TransportClient，一个是NodeClient。两个的区别为：TransportClient作为一个外部访问者，通过HTTP去请求ES的集群，对于集群而言，它是一个外部因素。NodeClient顾名思义，是作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的，不像TransportClient那样，ES集群对它一无所知。NodeClient通信的性能会更好，但是因为是ES的一环，所以它出问题，也会给ES集群带来问题。NodeClient可以设置不作为数据节点，在elasticsearch.yml中设置，这样就不会在此节点上分配数据。 如果用ES的节点，仁者见仁智者见智。 实例package name.quanke.es.study;import name.quanke.es.study.util.Utils;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.transport.InetSocketTransportAddress;import org.elasticsearch.transport.client.PreBuiltTransportClient;import org.junit.After;import org.junit.Before;import java.net.InetAddress;/** * Elasticsearch 5.5.1 的client 和 ElasticsearchTemplate的初始化 * 作为一个外部访问者，请求ES的集群，对于集群而言，它是一个外部因素。 * Created by http://quanke.name on 2017/11/10. */public class ElasticsearchClient &#123; protected TransportClient client; @Before public void setUp() throws Exception &#123; Settings esSettings = Settings.builder() .put(&quot;cluster.name&quot;, &quot;utan-es&quot;) //设置ES实例的名称 .put(&quot;client.transport.sniff&quot;, true) //自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中 .build(); /** * 这里的连接方式指的是没有安装x-pack插件,如果安装了x-pack则参考&#123;@link ElasticsearchXPackClient&#125; * 1. java客户端的方式是以tcp协议在9300端口上进行通信 * 2. http客户端的方式是以http协议在9200端口上进行通信 */ client = new PreBuiltTransportClient(esSettings) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300)); System.out.println(&quot;ElasticsearchClient 连接成功&quot;); &#125; @After public void tearDown() throws Exception &#123; if (client != null) &#123; client.close(); &#125; &#125; protected void println(SearchResponse searchResponse) &#123; Utils.println(searchResponse); &#125;&#125; 本实例代码已经上传到 Git ElasticsearchClient.java 所有实例 已经上传到Git XPackTransportClient如果 ElasticSearch 服务安装了 x-pack 插件，需要PreBuiltXPackTransportClient实例才能访问 使用Maven管理项目，把下面代码增加到pom.xml; 一定要修改默认仓库地址为https://artifacts.elastic.co/maven ，因为这个库没有上传到Maven中央仓库,如果有自己的 maven ，请配置代理 &lt;project ...&gt; &lt;repositories&gt; &lt;!-- add the elasticsearch repo --&gt; &lt;repository&gt; &lt;id&gt;elasticsearch-releases&lt;/id&gt; &lt;url&gt;https://artifacts.elastic.co/maven&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; ... &lt;/repositories&gt; ... &lt;dependencies&gt; &lt;!-- add the x-pack jar as a dependency --&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;x-pack-transport&lt;/artifactId&gt; &lt;version&gt;5.6.3&lt;/version&gt; &lt;/dependency&gt; ... &lt;/dependencies&gt; ... &lt;/project&gt; 实例/** * Elasticsearch XPack Client * Created by http://quanke.name on 2017/11/10. */public class ElasticsearchXPackClient &#123; protected TransportClient client; @Before public void setUp() throws Exception &#123; /** * 如果es集群安装了x-pack插件则以此种方式连接集群 * 1. java客户端的方式是以tcp协议在9300端口上进行通信 * 2. http客户端的方式是以http协议在9200端口上进行通信 */ Settings settings = Settings.builder() .put(&quot;xpack.security.user&quot;, &quot;elastic:utan100&quot;) .put(&quot;cluster.name&quot;, &quot;utan-es&quot;) .build(); client = new PreBuiltXPackTransportClient(settings) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;192.168.1.10&quot;), 9300));// final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();// credentialsProvider.setCredentials(AuthScope.ANY,// new UsernamePasswordCredentials(&quot;elastic&quot;, &quot;utan100&quot;)); System.out.println(&quot;ElasticsearchXPackClient 启动成功&quot;); &#125; @Test public void testClientConnection() throws Exception &#123; System.out.println(&quot;--------------------------&quot;); &#125; @After public void tearDown() throws Exception &#123; if (client != null) &#123; client.close(); &#125; &#125; protected void println(SearchResponse searchResponse) &#123; Utils.println(searchResponse); &#125;&#125; 本实例代码已经上传到 Git ElasticsearchXPackClient.java 所有实例 已经上传到Git 更多请浏览 spring-boot-starter-es 开源项目 如何有任何问题请关注微信公众号给我留言","categories":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}],"tags":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/tags/es/"},{"name":"大数据","slug":"bdaga","permalink":"http://quanke.name/tags/bdaga/"},{"name":"Java","slug":"Java","permalink":"http://quanke.name/tags/Java/"},{"name":"API","slug":"API","permalink":"http://quanke.name/tags/API/"}],"keywords":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}]},{"title":"Elasticsearch 5.6 Java API 中文手册 ","slug":"es/Elasticsearch-5-6-Java-API-中文手册","date":"2017-11-08T09:21:00.000Z","updated":"2018-02-02T15:25:26.000Z","comments":true,"path":"posts/21227/","link":"","permalink":"http://quanke.name/posts/21227/","excerpt":"","text":"本手册由 全科 翻译，并且整理成电子书，支持PDF,ePub,Mobi格式，方便大家下载阅读。 不只是官方文档的翻译，还包含使用实例，包含我们使用踩过的坑 阅读地址：https://es.quanke.name 下载地址：https://www.gitbook.com/book/quanke/elasticsearch-java github地址：https://github.com/quanke/elasticsearch-java 编辑：http://quanke.name 编辑整理辛苦，还望大神们点一下star ，抚平我虚荣的心","categories":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}],"tags":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/tags/es/"},{"name":"大数据","slug":"bdaga","permalink":"http://quanke.name/tags/bdaga/"},{"name":"Java","slug":"Java","permalink":"http://quanke.name/tags/Java/"},{"name":"API","slug":"API","permalink":"http://quanke.name/tags/API/"}],"keywords":[{"name":"Elasticsearch","slug":"es","permalink":"http://quanke.name/categories/es/"}]},{"title":"使用PM2运行node.js服务","slug":"nodejs/使用PM2运行node-js服务","date":"2017-11-06T08:20:00.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/19415/","link":"","permalink":"http://quanke.name/posts/19415/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 GitHub 地址： https://github.com/Unitech/pm2 官网： http://pm2.keymetrics.io/ 为什么需要使用PM2因为node.js 是单进程，进程被杀死后整个服务就跪了，所以需要进程管理工具，但是pm2 远远不止这些。 介绍PM2 是一个带有负载均衡功能的 Node 应用的进程管理器。 当你要把你的独立代码利用全部的服务器上的所有 CPU，并保证进程永远都活着，0 秒的重载， PM2 是完美的。 特性 内建负载均衡（使用Node cluster 集群模块） 后台运行 0秒停机重载(维护升级的时候不需要停机). 具有Ubuntu和CentOS 的启动脚本 停止不稳定的进程（避免无限循环） 控制台检测 提供 HTTP API 远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 ) 安装 首先确保有node.js 的环境 npm install -g pm2 运行pm2 start app.js --name my-api # 命名进程 其他运行方式：pm2 start app.js -i max # 根据有效CPU数目启动最大进程数目pm2 start app.js -i 3 # 启动3个进程pm2 start app.js -x #用fork模式启动 app.js 而不是使用 clusterpm2 start app.js -x -- -a 23 # 用fork模式启动 app.js 并且传递参数 (-a 23)pm2 start app.js --name serverone # 启动一个进程并把它命名为 serveronepm2 stop serverone # 停止 serverone 进程pm2 start app.json # 启动进程, 在 app.json里设置选项pm2 start app.js -i max -- -a 23 #在--之后给 app.js 传递参数pm2 start app.js -i max -e err.log -o out.log # 启动 并 生成一个配置文件，你也可以执行用其他语言编写的app ( fork 模式):pm2 start my-bash-script.sh -x --interpreter bashpm2 start my-python-script.py -x --interpreter python npm 运行pm2 start npm -- start 动一个进程并把它命名为 testpm2 start npm --name test -- start 使用npm install pm2 -g # 命令行安装 pm2 pm2 start app.js -i 4 #后台运行pm2，启动4个app.js # 也可以把&apos;max&apos; 参数传递给 start # 正确的进程数目依赖于Cpu的核心数目pm2 start app.js --name my-api # 命名进程pm2 list # 显示所有进程状态pm2 monit # 监视所有进程pm2 logs # 显示所有进程日志pm2 stop all # 停止所有进程pm2 restart all # 重启所有进程pm2 reload all # 0秒停机重载进程 (用于 NETWORKED 进程)pm2 stop 0 # 停止指定的进程pm2 restart 0 # 重启指定的进程pm2 startup # 产生 init 脚本 保持进程活着pm2 web # 运行健壮的 computer API endpoint (http://localhost:9615)pm2 delete 0 # 杀死指定的进程pm2 delete all # 杀死全部进程 参考 https://www.douban.com/note/314200231/ https://stackoverflow.com/questions/31579509/can-pm2-run-an-npm-start-script","categories":[{"name":"node.js","slug":"node","permalink":"http://quanke.name/categories/node/"}],"tags":[{"name":"PM2","slug":"PM2","permalink":"http://quanke.name/tags/PM2/"},{"name":"node.js 运行","slug":"node-js-运行","permalink":"http://quanke.name/tags/node-js-运行/"}],"keywords":[{"name":"node.js","slug":"node","permalink":"http://quanke.name/categories/node/"}]},{"title":"swagger-edit写接口文档神器的部署和使用","slug":"tools/swagger-edit部署和使用","date":"2017-11-06T08:18:00.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/41016/","link":"","permalink":"http://quanke.name/posts/41016/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 介绍swagger 是一套开源的API设计工具，包括Swagger UI，Swagger Editor等。 其中Swagger Editor是个WEB小程序，它可以让你用YAML来定义你的接口规范，并实时验证和现实成接口文档。 我们主要使用Swagger Editor 编写接口文档，在线 Swagger Editor 也是可以使用的，但是访问速度在国内有点慢，所以为了效率，自己在服务器搭建一套服务 下载直接git clone 最新代码： git clone https://github.com/swagger-api/swagger-editor.git 安装 首先确保有node.js 的环境 cd swagger-editonpm install 安装 PM2 ,如果不会PM2，请查看 《使用PM2运行node.js服务》 运行使用PM2运行 pm2 start npm -- start 使用访问： http://192.168.2.52:3001/ 参考： http://blog.csdn.net/wangmeng951011/article/details/67640375","categories":[{"name":"使用","slug":"use","permalink":"http://quanke.name/categories/use/"}],"tags":[{"name":"接口文档","slug":"api","permalink":"http://quanke.name/tags/api/"},{"name":"swagger-api","slug":"swagger-api","permalink":"http://quanke.name/tags/swagger-api/"},{"name":"swagger-edit","slug":"swagger-edit","permalink":"http://quanke.name/tags/swagger-edit/"}],"keywords":[{"name":"使用","slug":"use","permalink":"http://quanke.name/categories/use/"}]},{"title":"elasticsearch5xx使用logstash同步mysql","slug":"es/elasticsearch5xx使用logstash同步mysql","date":"2017-11-06T07:53:00.000Z","updated":"2018-02-02T15:26:03.000Z","comments":true,"path":"posts/108/","link":"","permalink":"http://quanke.name/posts/108/","excerpt":"","text":"安装下载logstash下载地址：https://www.elastic.co/downloads/logstash 当时我下载的是5.6.3版本 https://artifacts.elastic.co/downloads/logstash/logstash-5.6.3.tar.gz 解压：tar -zxvf logstash-5.6.3.tar.gz 进入安装目录 运行： bin/logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos; 等待几秒钟 出现 The stdin plugin is now waiting for input: 然后输入 hello world 得到类似的结果2017-10-30T02:49:59.005Z test-env hello world 安装logstash-input-jdbc插件1.安装 ruby 和 rubygems（注意：需要 ruby 的版本在 1.8.7 以上） yum install -y ruby rubygems 检查 ruby 版本： ruby -v ruby 1.8.7 (2013-06-27 patchlevel 374) [x86_64-linux] 替换国内的镜像 gem sources --remove http://rubygems.org/gem sources -a http://gems.ruby-china.org/ 验证是否成功 gem sources -l *** CURRENT SOURCES ***http://rubygems.org/http://gems.ruby-china.org/ 修改Gemfile的数据源地址 vim Gemfile 修改 source 的值 为： &quot;https://gems.ruby-china.org/&quot; vim Gemfile.jruby-1.9.lock 找到 remote 修改它的值为：https://gems.ruby-china.org/ 开始安装: ./bin/logstash-plugin install --no-verify logstash-input-jdbc Installing logstash-input-jdbcInstallation successful 使用配置语法最基本的配置文件定义，必须包含input 和 output。如果需要对数据进操作，则需要加上filter段 配置 java mysql 连接驱动 mysql-connector-java-5.1.42-bin.jar https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz input &#123; stdin &#123; &#125; jdbc &#123; jdbc_connection_string =&gt; &quot;jdbc:mysql://dbs1:3306/db2_utan_cs&quot; jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; &quot;123456&quot; jdbc_driver_library =&gt; &quot;/data/arrow/logstash/mysql-connector-java-5.1.42-bin.jar&quot; jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; statement =&gt; &quot;SELECT * FROM crawler_data WHERE id &gt; (SELECT MAX(t1.id) FROM db2_utan_cs.crawler_data AS t1)-70000 AND updatetime &gt; :sql_last_value&quot; use_column_value =&gt; true tracking_column =&gt; &quot;updatetime&quot; schedule =&gt; &quot;* * * * *&quot; type =&gt; &quot;baby_crawler&quot; &#125;&#125;filter &#123; mutate &#123; remove_field =&gt; [ &quot;@timestamp&quot;, &quot;@version&quot;, &quot;id&quot; ] &#125;&#125; output &#123; elasticsearch &#123; hosts =&gt; &quot;192.168.1.21:9201&quot; index =&gt; &quot;baby_crawler_b&quot; document_id =&gt; &quot;%&#123;uniquekey&#125;&quot; &#125; stdout &#123; codec =&gt; json_lines &#125;&#125; 启动方式# 通过手动指定配置文件启动 /bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf # 以daemon方式运行，则在指令后面加一个 &amp; 符号 /bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf &amp; # 如果是通过rpm包安装的logstash则可以使用自带的脚本启动 /etc/init.d/logstash start # 通过这种方式启动，logstash会自动加载 /etc/logstash/conf.d/ 下的配置文件 参考http://tchuairen.blog.51cto.com/3848118/1840596/","categories":[{"name":"大数据","slug":"bdata","permalink":"http://quanke.name/categories/bdata/"}],"tags":[{"name":"logstash","slug":"logstash","permalink":"http://quanke.name/tags/logstash/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://quanke.name/tags/elasticsearch/"},{"name":"mysql","slug":"mysql","permalink":"http://quanke.name/tags/mysql/"}],"keywords":[{"name":"大数据","slug":"bdata","permalink":"http://quanke.name/categories/bdata/"}]},{"title":"elasticsearch5xx使用logstash同步mysql","slug":"es/elasticsearch5xx使用logstash同步mysql副本","date":"2017-11-06T07:53:00.000Z","updated":"2018-02-02T15:25:56.000Z","comments":true,"path":"posts/108/","link":"","permalink":"http://quanke.name/posts/108/","excerpt":"","text":"安装下载logstash下载地址：https://www.elastic.co/downloads/logstash 当时我下载的是5.6.3版本 https://artifacts.elastic.co/downloads/logstash/logstash-5.6.3.tar.gz 解压：tar -zxvf logstash-5.6.3.tar.gz 进入安装目录 运行： bin/logstash -e &apos;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos; 等待几秒钟 出现 The stdin plugin is now waiting for input: 然后输入 hello world 得到类似的结果2017-10-30T02:49:59.005Z test-env hello world 安装logstash-input-jdbc插件1.安装 ruby 和 rubygems（注意：需要 ruby 的版本在 1.8.7 以上） yum install -y ruby rubygems 检查 ruby 版本： ruby -v ruby 1.8.7 (2013-06-27 patchlevel 374) [x86_64-linux] 替换国内的镜像 gem sources --remove http://rubygems.org/gem sources -a http://gems.ruby-china.org/ 验证是否成功 gem sources -l *** CURRENT SOURCES ***http://rubygems.org/http://gems.ruby-china.org/ 修改Gemfile的数据源地址 vim Gemfile 修改 source 的值 为： &quot;https://gems.ruby-china.org/&quot; vim Gemfile.jruby-1.9.lock 找到 remote 修改它的值为：https://gems.ruby-china.org/ 开始安装: ./bin/logstash-plugin install --no-verify logstash-input-jdbc Installing logstash-input-jdbcInstallation successful 使用配置语法最基本的配置文件定义，必须包含input 和 output。如果需要对数据进操作，则需要加上filter段 配置 java mysql 连接驱动 mysql-connector-java-5.1.42-bin.jar https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz input &#123; stdin &#123; &#125; jdbc &#123; jdbc_connection_string =&gt; &quot;jdbc:mysql://dbs1:3306/db2_utan_cs&quot; jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; &quot;123456&quot; jdbc_driver_library =&gt; &quot;/data/arrow/logstash/mysql-connector-java-5.1.42-bin.jar&quot; jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; statement =&gt; &quot;SELECT * FROM crawler_data WHERE id &gt; (SELECT MAX(t1.id) FROM db2_utan_cs.crawler_data AS t1)-70000 AND updatetime &gt; :sql_last_value&quot; use_column_value =&gt; true tracking_column =&gt; &quot;updatetime&quot; schedule =&gt; &quot;* * * * *&quot; type =&gt; &quot;baby_crawler&quot; &#125;&#125;filter &#123; mutate &#123; remove_field =&gt; [ &quot;@timestamp&quot;, &quot;@version&quot;, &quot;id&quot; ] &#125;&#125; output &#123; elasticsearch &#123; hosts =&gt; &quot;192.168.1.21:9201&quot; index =&gt; &quot;baby_crawler_b&quot; document_id =&gt; &quot;%&#123;uniquekey&#125;&quot; &#125; stdout &#123; codec =&gt; json_lines &#125;&#125; 启动方式# 通过手动指定配置文件启动 /bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf # 以daemon方式运行，则在指令后面加一个 &amp; 符号 /bin/logstash -f /etc/logstash/conf.d/nginx_logstash.conf &amp; # 如果是通过rpm包安装的logstash则可以使用自带的脚本启动 /etc/init.d/logstash start # 通过这种方式启动，logstash会自动加载 /etc/logstash/conf.d/ 下的配置文件 参考http://tchuairen.blog.51cto.com/3848118/1840596/","categories":[{"name":"大数据","slug":"bdata","permalink":"http://quanke.name/categories/bdata/"}],"tags":[{"name":"logstash","slug":"logstash","permalink":"http://quanke.name/tags/logstash/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://quanke.name/tags/elasticsearch/"},{"name":"mysql","slug":"mysql","permalink":"http://quanke.name/tags/mysql/"}],"keywords":[{"name":"大数据","slug":"bdata","permalink":"http://quanke.name/categories/bdata/"}]},{"title":"已有Android工程 集成React Native 的那些事","slug":"android/已有Android工程-集成React-Native-的那些事","date":"2017-02-28T15:03:00.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/27127/","link":"","permalink":"http://quanke.name/posts/27127/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 2017年2月27日，天气晴，我永远记得这天，我心潮澎湃，因为终于把优谈TOP 集成了React Native，从去年开始，公司陆陆续续的集成和学习React Native，通过demo的形式，写了不少组件和API，也能和后端调通，也多次，多个人尝试把优谈TOP集成React Native，但是每次都是失败的，因为缺少经验，不能直接通过错误判断原因，只能通过Google查找各种资料，慢慢解决，下面记录了我们，优谈TOP 原生 集成React Native 的那些事。也许也是你的那些事？ 常规思路：通过百度搜索 已有Android工程集成ReactNative 出现一大堆教程，大部分教程都是通过在原来的基础上增加React Native的支持，比如这个：《Android之原生项目集成React Native》 ，这也是官方推荐的集成方式，我也推荐这个，只是我这样，一直报错，有一个启动 MainaAtivity的错，一直过不去，所以我就换一种思路。。。 在React Native基础上增加原生开始通过官方文档安装和初始化React Native项目。 创建和运行React Native 项目react-native init UtanTopcd UtanTopreact-native run-android 如果没有错,再继续。如果有错，说明你环境都没有安装好，哈哈。请参考环境安装文档 恭喜你，第一步搞定了。接下来，巨坑的地方要来了。 把原生的 build.gradle 文件先集成进去这一步比较简单，就是把gradle相关文件复制替换就可以了，你想的好简单哈。。。 我建议： 首先把原项目的gradle相关文件复制到新建的React Native项目，不要破坏原来的React Native项目的配置。 如果原生项目里有Module，先不要把Module导入，为了保险，把最简单的导入。 修改Root 目录下的build.gradleallprojects &#123; repositories &#123; mavenLocal() jcenter() maven &#123; url &quot;http://192.168.1.205:8081/repository/utancenter/&quot; &#125; maven &#123; // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm url &quot;$rootDir/../node_modules/react-native/android&quot; &#125; &#125;&#125; 如果有其他maven仓库直接这么写就可以了。 配置app目录下的build.gradlebuildTypes &#123;// release &#123;// // 不显示Log// buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot;//// minifyEnabled enableProguardInReleaseBuilds// zipAlignEnabled true// shrinkResources true// proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-project.txt&apos;// signingConfig signingConfigs.release//// applicationVariants.all &#123; variant -&gt;// variant.outputs.each &#123; output -&gt;// def outputFile = output.outputFile// if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123;//// //if (&quot;woman&quot;.equals(WOMAN))&#123;// // def fileName = &quot;WomanTop_v$&#123;defaultConfig.versionName&#125;_$&#123;variant.productFlavors[0].name&#125;.apk&quot;// //output.outputFile = new File(outputFile.parent+File.separator+&quot;v&quot;+defaultConfig.versionName, fileName)// //&#125; else &#123;// def fileName = &quot;UtanTop_v$&#123;defaultConfig.versionName&#125;_$&#123;variant.productFlavors[0].name&#125;.apk&quot;// output.outputFile = new File(outputFile.parent + File.separator + &quot;v&quot; + defaultConfig.versionName, fileName)// //&#125;////// &#125;// &#125;// &#125;// &#125; release &#123; minifyEnabled enableProguardInReleaseBuilds proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot; &#125; &#125; 贴这个的意思就是先把打渠道包的去掉，使用React Native生成的配置，之后打渠道包在说，记得把下面几段也要先注释掉。 // // 多渠道打包// productFlavors &#123;// T1 &#123;&#125;// T2 &#123;&#125;// T3 &#123;&#125;//// &#125;//// productFlavors.all &#123; flavor -&gt;// flavor.manifestPlaceholders = [CHANNEL_VALUE: name]// &#125; 如果集成友盟的多渠道包，还需要在AndroidManifest.xml中注释掉。 &lt;meta-data android:name=&quot;UMENG_APPKEY&quot; android:value=&quot;$&#123;UMENG_APPKEY&#125;&quot; /&gt; 在这个时候我们还没集成源码，再执行： react-native run-android 如果编译通过，恭喜你，如果没有过那是正常的，因为还有一个坑。 我的报错信息是 * What went wrong:Execution failed for task &apos;:app:packageAllDebugClassesForMultiDex&apos;.&gt; java.util.zip.ZipException: duplicate entry: bolts/AggregateException.class 是因为导入了重复的条目。 可能是在某些某些gradle版本才有吧。。。 我的解决方法： compile(&apos;com.facebook.fresco:fresco:0.10.0&apos;) &#123; exclude group: &apos;com.parse.bolts&apos;, module: &apos;bolts-android&apos;&#125;compile (&apos;com.facebook.fresco:animated-gif:0.10.0&apos;)&#123; exclude group: &apos;com.parse.bolts&apos;, module: &apos;bolts-android&apos;&#125; 这时候再执行： react-native run-android 现在问题应该不大了，按道理可以运行起来了，反正我的运行起来了，但是还没有加入源码。。。 现在就把java res libs assets 目录下的文件和 AndroidManifest.xml 复制到React Native项目中。把MainApplication 集成你原生项目的Application 一般项目都会自定一个Application public class MainApplication extends UtanToutiaoApp implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override public boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage() ); &#125; &#125;; @Override public ReactNativeHost getReactNativeHost() &#123; return mReactNativeHost; &#125; @Override public void onCreate() &#123; super.onCreate(); SoLoader.init(this, /* native exopackage */ false); &#125;&#125; 注意：不要把MainActivity MainApplication ,文件覆盖了。 再执行： react-native run-android 应该可以成功了，如果默认启动的是MainActivity，那展示的就是React Native 界面，如果默认不是MainActivity，那就通过下面的方式启动。 Intent i = new Intent(context, MainReactActivity.class); context.startActivity(i); 到这里我反正就ok了，不知道你ok了没？ 如果不OK ，请留言，一起探讨。。 还有我在学习和使用React Native 之后也会贴出来供大伙参考。。请关注 quanke","categories":[{"name":"React Native","slug":"rn","permalink":"http://quanke.name/categories/rn/"}],"tags":[{"name":"React Native","slug":"rn","permalink":"http://quanke.name/tags/rn/"},{"name":"React","slug":"React","permalink":"http://quanke.name/tags/React/"}],"keywords":[{"name":"React Native","slug":"rn","permalink":"http://quanke.name/categories/rn/"}]},{"title":"Android Gradle 相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包","slug":"android/Android-Gradle-相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包","date":"2017-02-22T16:07:42.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/55306/","link":"","permalink":"http://quanke.name/posts/55306/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 Android Gradle 相同应用多包名打包，实现测试发布包分离，不同服务器地址以生成不同安装包简介：公司的新需求：同一份代码打出另一个包名的apk，即包名不同、名称不同的两个apk。因为市场是识别包名的，所有可以相同的代码可以发布多个APP，以便于测试什么样的名字被用户接受（本人不太认同这种观点，这里只谈技术），可以在同一个手机同时安装测试包和发布包（大部分测试的接口地址与发布的接口地址是不一样的，还有一些公司还有开发的接口），方便测试 我经过多方渠道发现大致有一下三种方法： 通过ant打多包名应用 建立多个与“main”同级的文件夹，修改清单文件及build.gradle以达到打多包名效果 通过修改build.gradle文件的applicationId达到打多包名的效果，原理与第二种方法但比较简单 因为是新手，对ant并不太了解，原理也不太清楚，为了赶时间所以直接选择了第二种与第三种方法，经过测试发现第三种方法要更加简单的多，所以最后直接使用了第三种方法，以下为详解。 因为要修改的是build.gradle文件而该文件一经修改就要重新编译，用过史丢丢的童鞋应该都清楚等待编译完成是是件多么蛋疼的事情所以建议大家一次性修改完成以便节约开发时间。 上面已经说过该方法主要是通过修改build.gradle文件的applicationId达到打多包名的效果的，下面便粘出本人代码供大家参考。 productFlavors &#123; app_one &#123; applicationId &quot;com.example.app1&quot; manifestPlaceholders = [ app_name:&quot;测试-1&quot; ] &#125; app_two &#123; applicationId &quot;com.example.app2&quot; manifestPlaceholders = [ app_name:&quot;测试-2&quot; ] &#125; app_three &#123; applicationId &quot;com.example.app3&quot; manifestPlaceholders = [ app_name:&quot;测试-3&quot; ] &#125; &#125; 是不是感觉这个方法很眼熟？没错就是多渠道打包的地方，通过添加这段代码后需要用到gradle面板进行打包，得到app_one 通过查看包名发现它的包名为 com.example.app1 显示的名称也为 测试-1，app_two 与 app_three 效果等同，至此已经完成多包名打包，且通过同一份代码打出了不同包名、不同名称的三个应用，而需求也达到了。 可能有的朋友会问如果还需要其他的渠道包怎么办，如果有10的渠道而又要打包两个不同的应用那岂不是要写20个类似于app_one的东西，那不是要很麻烦？没错我正好也碰到了这种情况，经过多次研究测试发现并没有那么麻烦，只需设定一个默认的包名、应用名即可，废话不多说，直接贴代码。 defaultConfig &#123; if (PACKAGE == &quot;one&quot;) &#123; applicationId &quot;com.example.app1&quot; manifestPlaceholders = [ app_name:&quot;测试-1&quot; ] &#125; else &#123; applicationId &quot;com.example.app2&quot; manifestPlaceholders = [ app_name:&quot;测试-2&quot; ] &#125; minSdkVersion 14 targetSdkVersion 23 versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125; productFlavors &#123; app_one &#123;&#125; app_two &#123;&#125; app_three &#123;&#125; &#125; 嗯，就是这样，在defaultConfig里面设置一个默认的包名与应用名就可以了。 好了，到了这一步我们就要用到另一个神奇的文件了 看看你的工程根目录下得这个东西，没错就是它，这里我设置了一个字段“PACKAGE”，即告诉Studio我想要什么包，到这里相信大家也就明白我写的判断的目的了。 PACKAGE=one 只要通过修改这一字段为“one”，然后通过打包后就可以得到三个“测试-1”的app_one、app_two、app_three的apk文件了，同理将其修改为其他字段即可打出其他包名、应用名的应用了。但是转到本人公司项目后发现这种方法竟然失灵了，即修改 properties 文件内的字段后得不到我想要的包，经过探索发现可能是与项目工程的大小有关，改完重启后就可以了。当然还有另一个最重要的地方 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.morepackagenametest&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;$&#123;app_name&#125;&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 不同服务器地址以生成不同安装包方法类似，我这里不细说，有问题请留言 就是这里了，即之前定义的名字赋给应用了，在这里大家要注意一下在该项目的其他 model 内的清单文件里最好不要写 android：label 这句了，否则会报错的，至于是什么错一眼就可以看到了，当然如果报错了有两个方法： 删掉其他 model 内清单文件下application的 label 属性 通过在 application 下添加 tools:replace=&quot;android:label&quot; 属性解决 好了，打完收工。期待大神的批评指导。 欢迎关注http://quanke.name/ 转载请注明出处，谢谢 此文同事编写，此后会增加不同服务器地址以生成不同安装包的demo 原文：http://blog.csdn.net/qq_33673284/article/details/52875696 最后附上资源下载地址 Android 多包名打包应用 供各位参考","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://quanke.name/tags/Gradle/"},{"name":"Android多渠道打包","slug":"android-pg","permalink":"http://quanke.name/tags/android-pg/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"一个老司机工程师整理的自动化测试资料","slug":"test/一个老司机工程师整理的自动化测试资料","date":"2017-02-22T16:05:15.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/16982/","link":"","permalink":"http://quanke.name/posts/16982/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 Python教程 http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000 Appium：http://appium.io/slate/en/master/# Appium 中文 Appium API 文档https://testerhome.com/topics/3144 Appium移动自动化测试（虫师写的系列，质量高）http://www.cnblogs.com/fnng/p/4540731.html Robot Framework +Appium的简单教程及实例http://blog.csdn.net/xyh421/article/details/52119872 Python + Appium+ IOS自动化测试http://blog.csdn.net/temanm/article/details/49641133 Saucelabs+Java+TestNG+Appium+Maven+Git+Jenkins+ReportNG for Android 自动化测试http://blog.csdn.net/wanglin_lin/article/details/51931728 Selenium 2 Selenium 2 入门http://www.ibm.com/developerworks/cn/web/wa-selenium2/ Robot Framework自动化测试 Robot Framework自动化测试（一）—第一个脚本http://www.cnblogs.com/fnng/p/3871712.html Robot Framework自动化测试 —视频与教程免费分享（里面有 PDF 质量非常高）http://www.cnblogs.com/fnng/p/4333977.html Jenkins+robotframework+svn持续集成环境配置http://lijunwei1228ok.blog.163.com/blog/static/97383797201407113453672/ 这个是一个程序员学习自动化测试的一个过程和资料，之后会有一些原创内容，欢迎关注 如果你想零基础开始 从入门到精通 学习软件测试，建议花几块钱买视频教程 https://item.taobao.com/item.htm?id=544901106180","categories":[{"name":"自动化测试","slug":"autotest","permalink":"http://quanke.name/categories/autotest/"}],"tags":[{"name":"自动化测试","slug":"autotest","permalink":"http://quanke.name/tags/autotest/"},{"name":"软件测试","slug":"test","permalink":"http://quanke.name/tags/test/"}],"keywords":[{"name":"自动化测试","slug":"autotest","permalink":"http://quanke.name/categories/autotest/"}]},{"title":"APP版本管理SDK项目实战-准备篇","slug":"preject/APP版本管理SDK项目实战-准备篇","date":"2016-10-26T12:42:19.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/47009/","link":"","permalink":"http://quanke.name/posts/47009/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 因为友盟APP版本管理服务关闭（这是官方通知：http://bbs.umeng.com/thread-14590-1-1.html ），我计划做一个类似友盟的APP版本管理的功能，开放SDK，方便大家使用，我会把开发过程的思路分享给大家。 项目简介：版本管理项目我觉得对于所有的APP都是需要的，前期希望能做到和友盟一样。支持自动更新、手动更新、静默更新、强制更新、断点续传、忽略版本，服务端开放RESTFul的API，支持WEB管理页面，文件存储对接七牛，之后会支持各种存储 整个项目会涉及到API设计、移动端SDK开发、服务端开发、服务器选型、我打算全部自己一个人搞定 API我打算采用RESTFul架构，使用swagger在线调试API，分别用POST、PUT、GET、DELETE方法对资源做CURD操作。使用RESTFul的难点在于如何定义好各种资源的表述，即URI的定义。 SDK开发则打算第一版只用原生实现，优先Android SDK开发，之后再开发IOS SDK。 服务端开发准备使用最经典的SSM，数据库使用最最最经典的MySQL。 WEB管理后台使用Bootstrap响应式后台管理系统meadmin模板 服务器先自己本地开发，之后考虑阿里云或者其他。 功能需求整理：SDK: 自动更新 手动更新 静默更新 强制更新 断点续传 忽略版本 服务端： web管理 七牛存储 多个APP管理 渠道包支持 统计 写在最后：因为是SDK，管理使用模板，所以没有原型设计，功能确定好，就可以设计API了。","categories":[{"name":"项目实战","slug":"project","permalink":"http://quanke.name/categories/project/"}],"tags":[{"name":"SDK","slug":"SDK","permalink":"http://quanke.name/tags/SDK/"},{"name":"Android","slug":"Android","permalink":"http://quanke.name/tags/Android/"},{"name":"JavaEE","slug":"JavaEE","permalink":"http://quanke.name/tags/JavaEE/"},{"name":"IOS","slug":"IOS","permalink":"http://quanke.name/tags/IOS/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://quanke.name/tags/Spring-Boot/"}],"keywords":[{"name":"项目实战","slug":"project","permalink":"http://quanke.name/categories/project/"}]},{"title":"Android DownloadManager ERROR_UNKNOWN 在API 17 巨坑完美解决","slug":"android/Android-DownloadManager-ERROR-UNKNOWN-在API-17-巨坑完美解决","date":"2016-10-26T12:36:20.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/42104/","link":"","permalink":"http://quanke.name/posts/42104/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 现在做了一个下载，为了兼容性直接使用Android Sdk 自带的 DownloadManager 开发，在其他手机上都是OK，只有在有一台vivo上不行。 我尝试使用vivo系统浏览器去下载这个链接，也是OK的，这个排除了网络问题和系统下载的bug的问题。 尝试去找错误给我返回一个ERROR_UNKNOWN,完全SB了，此路不通。 尝试换一个链接去下载，居然也是OK的，所以确定了是链接的问题，链接有什么问题？我对比了一下，除了下载失败链接里包含了中括号[],其他也没有什么不一样的，所以我尝试着使用%5B、%5D 替换 [],居然好了。这也太奇葩了吧。。。 url = url.replace(&quot;[&quot;,&quot;%5B&quot;).replace(&quot;]&quot;,&quot;%5D&quot;); 之后我去Google了一下，搞明白了，原来Android系统在18之前有这么一个问题，之后修复了。 最终解决： if(Build.VERSION.SDK_INT&lt;=Build.VERSION_CODES.JELLY_BEAN_MR2)&#123; uri = uri.replace(&quot;[&quot;,&quot;%5B&quot;).replace(&quot;]&quot;,&quot;%5D&quot;); &#125; 参考： http://stackoverflow.com/questions/37976748/downloadmanager-fails-with-error-unknown-on-api-17","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://quanke.name/tags/android/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android Studio Service AIDL 详解","slug":"android/Android-Studio-Service-AIDL-详解","date":"2016-07-22T15:35:30.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/52572/","link":"","permalink":"http://quanke.name/posts/52572/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 公司产品之前IM这块存在很多问题，消息到达率低，加上协议上有些问题，丢消息频繁，所以需要重构IM，AIDL不能解决以上问题。好吧！那AIDL可以解决什么问题？什么是AIDL？ 什么是AIDL？AIDL是 Android Interface definition language的缩写，它是一种Android内部进程通信接口的描述语言，通过它我们可以定义进程间的通信接口 AIDL可以解决什么问题？ 可以实现多个应用程序共享同一个Service的功能，比如：IM服务可以提供给多个APP使用，先在推送基本都是采取这种方案 可以跨进程调用服务里的方法 Android Studio AIDL 实战大部分文章介绍都是在eclipse下介绍的，现在 Android Studio 作为开发工具比较普及了，所以我在Android Studio 下介绍（其实区别不大）。 言归正传，我们需要使用Android Studio实现一个远程Service，并且建立AIDL进行通信。 搭建了简单的Service框架1.继承Service package name.quanke.aidldemo;import android.app.Service;import android.content.Intent;import android.os.IBinder;/** * * Created by http://quanke.name on 16/7/23. */public class PushService extends Service &#123; public PushService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return new LibHandler(); &#125; @Override public boolean onUnbind(Intent intent) &#123; return super.onUnbind(intent); &#125;&#125; 2.在AndroidManifest.xml里注册 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;name.quanke.aidldemo&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:name=&quot;.App&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=&quot;.PushService&quot; android:enabled=&quot;true&quot; android:process=&quot;:push&quot; android:exported=&quot;true&quot;&gt; &lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; 建立AIDL1.创建AIDL文件夹 2.创建AIDL文件 3.编写AIDL文件// IHandler.aidlpackage name.quanke.aidldemo;// Declare any non-default types here with import statementsinterface IHandler &#123; void connect();&#125; 4.AIDL文件 生成接口 生成后的样子 5.编写客户端 ServiceConnectionpackage name.quanke.aidldemo;import android.app.Application;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;/** * Created by quanke on 16/7/23. */public class PushManager &#123; private static final String TAG = &quot;PushManager.class&quot;; private IHandler iHandler; private static PushManager ourInstance = new PushManager(); public static PushManager getInstance() &#123; return ourInstance; &#125; private PushManager() &#123; &#125; public void init(Application app)&#123; Intent binderIntent = new Intent(app,PushService.class); app.bindService(binderIntent, serviceConnection, Context.BIND_AUTO_CREATE); &#125; public void connect()&#123; try &#123; //通过AIDL远程调用 Log.d(TAG,&quot;++start Remote++&quot;); iHandler.connect(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; iHandler = IHandler.Stub.asInterface(service); //连接成功调动 &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; //断开连接调用 &#125; &#125;;&#125; 6.编写服务端实现connect方法package name.quanke.aidldemo;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;/** * * Created by quanke on 16/7/23. */public class LibHandler extends IHandler.Stub&#123; @Override public void connect() throws RemoteException &#123; Log.d(&quot;&quot;,&quot;connect()&quot;); &#125; @Override public IBinder asBinder() &#123; return null; &#125;&#125; 以上实现了简单的连接，接下来我们实现传递自定义类型 传递自定义的类型AIDL默认支持的类型包括Java基本类型（int、long、boolean等），和（String、List、Map、CharSequence），如果要传递自定义的类型需要实现android.os.Parcelable接口。自己写了一个实体类public class Message implements Parcelable。 package name.quanke.aidldemo.model;import android.os.Parcel;import android.os.Parcelable;/** * * Created by quanke on 16/7/23. */public class Message implements Parcelable &#123; private long id; private String content; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; @Override public String toString() &#123; return &quot;Message&#123;&quot; + &quot;id=&quot; + id + &quot;, content=&apos;&quot; + content + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeLong(this.id); dest.writeString(this.content); &#125; public Message() &#123; &#125; protected Message(Parcel in) &#123; this.id = in.readLong(); this.content = in.readString(); &#125; public static final Creator&lt;Message&gt; CREATOR = new Creator&lt;Message&gt;() &#123; @Override public Message createFromParcel(Parcel source) &#123; return new Message(source); &#125; @Override public Message[] newArray(int size) &#123; return new Message[size]; &#125; &#125;;&#125; 修改IHandler // IHandler.aidlpackage name.quanke.aidldemo;// Declare any non-default types here with import statementsimport name.quanke.aidldemo.model.Message;interface IHandler &#123; void connect(); void sendMessage(Message message);&#125; 编译项目，报错 /Users/quanke/Dev/android/src/AIDLDemo/app/src/main/aidl/name/quanke/aidldemo/IHandler.aidlError:(6) couldn&apos;t find import for class name.quanke.aidldemo.model.MessageError:Execution failed for task &apos;:app:compileDebugAidl&apos;.&gt; java.lang.RuntimeException: com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command &apos;/Users/quanke/Dev/android/tools/android-sdks/build-tools/23.0.3/aidl&apos;&apos; finished with non-zero exit value 1Information:BUILD FAILED 因为自定义类型不仅要定义实现android.os.Parcelable接口的类，还得为该实现类定义一个aidl文件，如下： // IHandler.aidlpackage name.quanke.aidldemo.model;// Declare any non-default types here with import statementsimport name.quanke.aidldemo.model.Message;parcelable Message ; 切记 自定类型aidl文件名字、路径需要和自定义类名字、路径保持一致， 编译项目，还是报错 parameter 1: &apos;Message message&apos; can be an out parameter, so you must declare it as in, out or inout. AIDL不是 Java。它是真的很接近，但它不是 Java。 Java 参数没有方向的概念，AIDL 参数有方向，参数可以从客户端传到服务端，再返回来。 如果sendMessage方法的message参数是纯粹的输入参数–这意味着是从客户端到服务器的数据，你需要在AIDL声明： void sendMessage(in Message message); 如果sendMessage方法的message参数是纯粹的输出-这意味着它的数据是通过从服务器到客户端，使用： void sendMessage(out Message message); 如果sendMessage方法的message参数是输入也是输出-客户端的值在服务可能会修改，使用： void sendMessage(inout Message message); 总结Android Studio Service AIDL 详解 就到这里，现在应该可以使用AIDL实现想要的功能了，实现简答的AIDL很简单，主要是在自定义类型的时候，有几个坑注意就好。 源码地址： https://github.com/quanke/AIDLDemo.git 有什么问题欢迎留言。 如果喜欢请关注我，赞我，来抚平我虚荣的心","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://quanke.name/tags/android/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"完美解决 Android 6 java.lang.AbstractMethodError","slug":"error/完美解决-Android-6-java-lang-AbstractMethodError","date":"2016-07-19T13:55:13.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/60800/","link":"","permalink":"http://quanke.name/posts/60800/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 在Android Marshmallow (6.0)中有一个异常，异常信息中居然没有和APP包相关的东西，感觉这是Android SDK的一个坑 java.lang.AbstractMethodError: abstract method “int android.text.ParcelableSpan.getSpanTypeIdInternal()” Google一下，还真有人也遇到了同样的问题，看了半天也没有解决方案,只是解释了，为什么会有这个问题，大概就是在 Android 6.0 之后 ParcelableSpan 接口的 getSpanTypeIdInternal 和 writeToParcelInternal 方法是 @hide 标记了，多次提醒我们要看Google的文档，但是怎么解决呢？找另外的方法吧，此处不通。。。 既然不能实现ParcelableSpan接口了，那就换一种方式实现吧。 我换成继承android.text.style.UnderlineSpan类，居然可以了 package com.utan.app.utantop;import android.os.Parcel;import android.text.style.UnderlineSpan;/** * * Created by quanke.name on 2016/7/16. * App Url:utantop.com */public class UtanUnderlineSpan extends UnderlineSpan &#123; public UtanUnderlineSpan() &#123; super(); &#125; public UtanUnderlineSpan(Parcel src) &#123; super(src); &#125;&#125; https://medium.com/@numan1617/android-framework-classes-choose-wisely-2f8300f6c255#.3669g6u0m","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://quanke.name/tags/android/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"完美解决 java.lang.NoClassDefFoundError  R R 巨坑","slug":"error/完美解决-java-lang-NoClassDefFoundError-R-R-巨坑","date":"2016-07-19T13:53:59.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/57394/","link":"","permalink":"http://quanke.name/posts/57394/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 此坑有点大，害我同事弄了一周没有搞定 开始的时候是报另外一个错误，也是NoClassDefFoundError异常，但这个是因为包冲突的问题,删除掉一些包就好了。但是这个问题没有这么简单。 首先描述一下我们的场景吧： 我们做了一个优谈TOP APP，主要的逻辑代码是在一个单独的android studio module 实现的，这个主要是为了可以导入到公司其他APP里面，就是把优谈TOP当成sdk，嵌入到公司其他APP里，我们使用优谈TOP单独运行的时候没有一点问题，导入到另外要一个APP的时候，问题就出现了。 百度，Google搜了以大堆资料，都没有解决，最后在stackoverflow找到了一种方案。还真可以 stackoverflow 连接 http://stackoverflow.com/questions/32110859/fatal-exception-java-lang-noclassdeffounderror-android-support-v7-appcompat-r 看了这个才知道，这是Dex超出方法数的限制问题，Dex达到极限时，会创建多个Dex文件，android Lollipop 没有处理，需要在应用中处理 。 第一步：在 build.gradle 中增加(非 root build.gradle ) dependencies &#123; compile &apos;com.android.support:multidex:1.0.0&apos;&#125;defaultConfig &#123; multiDexEnabled true&#125; 第二步：在AndroidManifest.xml增加 &lt;application ... android:name=&quot;android.support.multidex.MultiDexApplication&quot;&gt; ...&lt;/application&gt; 如果需要自己实现 Application,需要重写attachBaseContext方法 import android.support.multidex.MultiDexApplication;import android.support.multidex.MultiDex;public class MyApplication extends MultiDexApplication &#123; // ...... @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); &#125;&#125; 或者 import android.support.multidex.MultiDex;public class MyApplication extends Application &#123; // ...... @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); &#125;&#125; 参考：https://developer.android.com/tools/building/multidex.html#mdex-gradle 这里记录一下没有解决我的问题的方案，也许你有用： http://stackoverflow.com/questions/32110859/fatal-exception-java-lang-noclassdeffounderror-android-support-v7-appcompat-r?noredirect=1&amp;lq=1 http://stackoverflow.com/questions/27614538/crash-java-lang-noclassdeffounderror-android-support-v7-appcompat-rlayout http://stackoverflow.com/questions/9870995/android-java-lang-noclassdeffounderror","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://quanke.name/tags/android/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android fastjson和Realm的完美结合，有坑","slug":"android/Android-fastjson和Realm的完美结合，有坑","date":"2016-07-19T13:52:11.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/22728/","link":"","permalink":"http://quanke.name/posts/22728/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 源码地址：https://github.com/quanke/FastjsonRealm Realm的安装和fastjson的安装这里就不详细说了。详细的文档在这里 https://realm.io/docs/java/ ，最好看英文文档，中文文档，不是最新的，而且看起来别扭。 现在Realm Java 的最新版本是 1.1.0，fastjson Android的版本是1.1.52 安装Realm Java在项目中（最外层的build.gradle文件）build.gradle中增加buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &quot;io.realm:realm-gradle-plugin:1.1.0&quot; &#125;&#125; 在应用中(一般是名为app模型)build.gradle增加apply plugin: &apos;realm-android&apos; 安装fastjson在应用中(一般是名为app模型)build.gradle增加compile &apos;com.alibaba:fastjson:1.1.52.android&apos; 现在我们写一个模型/** * * Created by quanke(http://quanke.name) on 2016/7/18. */public class User extends RealmObject implements Serializable&#123; public User() &#123; &#125; private String name; private int age; @Ignore private int sessionId; // Standard getters &amp; setters generated by your IDE… public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getSessionId() &#123; return sessionId; &#125; public void setSessionId(int sessionId) &#123; this.sessionId = sessionId; &#125;&#125; 把User对象通过fastjson转为String/** * Created by quanke(http://quanke.name) on 2016/7/18. */public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); User user = new User(); user.setAge(2); user.setName(&quot;http://quanke.name&quot;); String userStr = JSON.toJSONString(user); Log.d(&quot;userStr:&quot;,userStr); User userObj = JSON.parseObject(userStr,User.class); Log.d(&quot;userObj:&quot;,userObj+&quot;&quot;); &#125;&#125; 这个时候，我以为可以完美的运行了，但是运行的时候，报异常了。 java.lang.NoClassDefFoundError: rx.Observableat libcore.reflect.InternalNames.getClass(InternalNames.java:55)... 怎么解决？这里有两种方法。。 第一种：直接使用 RxJava第二种，不想使用 RxJava，那就创建一个 Observable 空文件package rx;public class Observable &#123; // Dummy class required for Jackson-Databind support if // RxJava is not a project dependency.&#125; 其实解决方案是官方提供的，只是里面的例子是Jackson而我用的是国产fastjson Realm 的详细使用这里就不说了。。。有很多小伙伴分享了，但我还是建议看官方文档 https://realm.io/docs/java/","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://quanke.name/tags/android/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Thinking in Java (Java 编程思想) PDF ePub Mobi格式电子书","slug":"java/Thinking-in-Java-Java-编程思想-PDF-ePub-Mobi格式电子书","date":"2016-05-08T08:01:19.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/25790/","link":"","permalink":"http://quanke.name/posts/25790/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 本书来自网络，http://quanke.name 整理成电子书，支持PDF,ePub,Mobi格式，方便大家下载阅读。 阅读地址：https://www.gitbook.com/read/book/quanke/think-in-java 下载地址：https://www.gitbook.com/book/quanke/think-in-java/ github地址：https://github.com/quanke/think-in-java 编辑：http://quanke.name 第13章没有编辑，觉得没有意义，Java的GUI先在应用少，有时间在编辑好。。。 编辑整理辛苦，还望大神们点一下star ，抚平我虚荣的心","categories":[{"name":"Java","slug":"Java","permalink":"http://quanke.name/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://quanke.name/tags/Java/"},{"name":"Java 编程思想","slug":"th-java","permalink":"http://quanke.name/tags/th-java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://quanke.name/categories/Java/"}]},{"title":"打造简单灵活的支持所有View的Android 空页面及错误页面","slug":"android/打造简单灵活的支持所有View的Android-空页面及错误页面","date":"2016-05-05T16:18:24.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/7329/","link":"","permalink":"http://quanke.name/posts/7329/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 当页面加载数据失败，数据为空，或者数据加载中需要可以操作其他地方，我们应该怎么办？ 体验良好的APP都会做相应的处理。 比如网络异常，会显示一个网络异常页面，提示用户去检查网络； 数据为空时，出现一个温馨的空页面，引导用户去创建数据等； 当数据在加载中时，我想按返回按钮，想切换tab，想做更多的事情时，弹出一个loading就不是那么友好了，直接在页面的内容显示区域显示加载中，问题就解决了。 这些方法各大app都在使用，但是怎么发开？每一个页面都写一个空页、面错误页面和loading页面吗？那也太恶心了吧。 下面我们一起打造简单灵活的支持所有View的Android 空页面及错误页面： 开始之前先看效果： 继承LinearLayout public class EmptyLayout extends LinearLayout&#123;public EmptyLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125;&#125; 我们需要实现三种不同的页面，所以需要定义三种类型： /** * The empty state */ public final static int TYPE_EMPTY = 1; /** * The loading state */ public final static int TYPE_LOADING = 2; /** * The error state */ public final static int TYPE_ERROR = 3; 定义操作方法： /** * 展示错误信息 * @param resId 图片资源id * @param text */ public void showError(int resId,String text)/** * 展示空信息 * @param resId 图片资源id * @param text */ public void showEmpty(int resId,String text)/** * 展示加载中 * @param resId 图片资源id * @param text */ public void showLoading(int resId,String text)/** *隐藏EmptyLayout */ public void hide() 获得EmptyLayout的子view，方便隐藏或者展示子view（这里的子view 一般用户展示本来的内容） /** * 获得EmptyLayout的子view */ private void getChildViews()&#123; int childCount = getChildCount(); Log.d(&quot;EmptyLayout&quot;,&quot;ChildCount:&quot;+childCount); View view; for (int i=0;i&lt;childCount;i++)&#123; view = getChildAt(i); if (isEmptyView(view))&#123; continue; &#125; childViews.add(view); &#125; &#125; 判断view 对象是否是EmptyView ： /** * 判断view 对象是否是EmptyView * @param view * @return */ private boolean isEmptyView(View view)&#123; if ((view == null||mEmptyRelativeLayout == view||view == mLoadingView||view == mEmptyView||view == mErrorView))&#123; return true; &#125; return false; &#125; 当数据为空时调用: public void showEmpty()&#123; getChildViews(); //获得除EmptyView的其他子view hideChildView(); //把子view隐藏了 this.mEmptyType = TYPE_EMPTY; changeEmptyType(); &#125; 其他方法和这个类似，思路很简单，大家可以试试 使用很简单 在布局文件里增加： &lt;name.quanke.app.libs.emptylayout.EmptyLayout android:id=&quot;@+id/emptyLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/textHello&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; /&gt;&lt;/name.quanke.app.libs.emptylayout.EmptyLayout&gt; 代码里增加: findViewById(R.id.btnLoading).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; emptyLayout.showLoading(); &#125; &#125;); findViewById(R.id.btnEmpty).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; emptyLayout.showEmpty(); &#125; &#125;); findViewById(R.id.btnError).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; emptyLayout.showError(); &#125; &#125;); findViewById(R.id.btnData).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; emptyLayout.hide(); &#125; &#125;); 好了，使用起来就这么简单。。。支持所有的view 源码放在github上：https://github.com/quanke/AndroidEmptyLayout 欢迎讨论","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://quanke.name/tags/android/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Vert.x 3 Core手册 for Java 中文版","slug":"vertx/Vert-x-3-Core手册-for-Java-中文版","date":"2016-05-03T23:58:21.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/700/","link":"","permalink":"http://quanke.name/posts/700/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585- 转载请注明出处，谢谢 阅读地址：http://vertx.quanke.name/ 下载地址：https://www.gitbook.com/book/quanke/vert-x-core-manual-for-java 本书源码地址：https://github.com/quanke/vert-x-core-manual-for-java","categories":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}],"tags":[{"name":"Vert.x3","slug":"Vert-x3","permalink":"http://quanke.name/tags/Vert-x3/"},{"name":"Vertx","slug":"Vertx","permalink":"http://quanke.name/tags/Vertx/"}],"keywords":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}]},{"title":"设计模式Java版,Gitbook开源电子书，含源码","slug":"java/设计模式Java版-Gitbook开源电子书，含源码","date":"2016-05-03T23:56:26.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/15671/","link":"","permalink":"http://quanke.name/posts/15671/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 Sunny在CSDN技术博客中陆续发表了100多篇与设计模式学习相关的文章，涵盖了七个面向对象设计原则和24个设计模式（23个GoF设计模式 + 简单工厂模式），为了方便大家学习，http://quanke.name 现将所有文章的进行了整理，方便大家下载阅读，希望能给各位带来帮助！ 阅读地址：https://quanke.gitbooks.io/design-pattern-java/content/ 下载地址：https://www.gitbook.com/book/quanke/design-pattern-java/ 源码下载地址：http://www.chinasa.info/download/DP-Code.rar 课件下载地址：http://www.chinasa.info/download/DP-Slides.rar 作者：刘伟 http://blog.csdn.net/lovelion 本书编辑：http://quanke.name 刘伟(Sunny)，中南大学计算机应用技术博士，国家认证系统分析师（2005年），国家认证系统架构设计师（2009年，全国第四名），高级程序员，数据库系统工程师，MCSE，MCDBA，CASI专业顾问与企业内训讲师。具有十多年软件开发、项目管理及教育培训经验，曾在NIIT（印度国家信息技术学院）担任高级讲师，主持和参与30多个软件项目的开发工作，并给国内多家公司提供软件开发、软件设计等培训服务，现主要致力于软件工程、数据挖掘等领域的教学、推广和研究工作。技术专长：软件架构、设计模式、UML、OOAD、数据挖掘等。已出版设计模式书籍四本：《设计模式》（清华大学出版社，2011年）、《设计模式实训教程》（清华大学出版社，2012年）、《设计模式的艺术——软件开发人员内功修炼之道》（清华大学出版社，2013年）、《C#设计模式》（清华大学出版社，2013年）。架构师之家www.chinasa.info站长。E-mail:weiliu_china@126.com微博地址：http://weibo.com/csusunny 更多干货，请关注：http://quanke.name","categories":[{"name":"设计模式","slug":"gof","permalink":"http://quanke.name/categories/gof/"}],"tags":[{"name":"设计模式","slug":"gof","permalink":"http://quanke.name/tags/gof/"},{"name":"JAVA","slug":"JAVA","permalink":"http://quanke.name/tags/JAVA/"}],"keywords":[{"name":"设计模式","slug":"gof","permalink":"http://quanke.name/categories/gof/"}]},{"title":"Web服务器处理HTTP压缩之gzip、deflate压缩","slug":"web/Web服务器处理HTTP压缩之gzip、deflate压缩","date":"2016-05-01T07:55:53.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/52945/","link":"","permalink":"http://quanke.name/posts/52945/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 一、什么是gzipgzip是一种数据格式，默认且目前仅使用deflate算法压缩data部分； Gzip是一种流行的文件压缩算法，现在的应用十分广泛，尤其是在Linux平台。当应用Gzip压缩到一个纯文本文件时，效果是非常明显的，大约可以减少70％以上的文件大小。这取决于文件中的内容。 利用Apache中的Gzip模块，我们可以使用Gzip压缩算法来对Apache服务器发布的网页内容进行压缩后再传输到客户端浏览器。这样经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。 网页加载速度加快的好处不言而喻，除了节省流量，改善用户的浏览体验外，另一个潜在的好处是Gzip与搜索引擎的抓取工具有着更好的关系。例如 Google就可以通过直接读取gzip文件来比普通手工抓取更快地检索网页。在Google网站管理员工具（Google Webmaster Tools）中你可以看到，sitemap.xml.gz 是直接作为Sitemap被提交的。 而这些好处并不仅仅限于静态内容，PHP动态页面和其他动态生成的内容均可以通过使用Apache压缩模块压缩，加上其他的性能调整机制和相应的服务器端 缓存规则，这可以大大提高网站的性能。因此，对于部署在Linux服务器上的PHP程序，在服务器支持的情况下，我们建议你开启使用Gzip Web压缩。 PS：详情参考：http://baike.baidu.com/item/gzip?fr=aladdin 二、什么是deflateDEFLATE是同时使用了LZ77算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。 它最初是由Phil Katz为他的PKZIP归档工具第二版所定义的，后来定义在RFC 1951规范中。 人们普遍认为DEFLATE不受任何专利所制约，并且在LZW（GIF文件格式使用）相关的专利失效之前，这种格式除了在ZIP文件格式中得到应用之外也在gzip压缩文件以及PNG图像文件中得到了应用。 DEFLATE压缩与解压的源代码可以在自由、通用的压缩库zlib上找到。 更高压缩率的DEFLATE是7-zip所实现的。AdvanceCOMP也使用这种实现，它可以对gzip、PNG、MNG以及ZIP文件进行压缩从而得到比zlib更小的文件大小。在Ken Silverman的KZIP与PNGOUT中使用了一种更加高效同时要求更多用户输入的DEFLATE程序。 deflate是一种压缩算法,是huffman编码的一种加强。 deflate与gzip解压的代码几乎相同，可以合成一块代码。 三、web服务器处理http压缩的过程 Web服务器接收到浏览器的HTTP请求后，检查浏览器是否支持HTTP压缩（Accept-Encoding 信息）； 如果浏览器支持HTTP压缩，Web服务器检查请求文件的后缀名； 如果请求文件是HTML、CSS等静态文件，Web服务器到压缩缓冲目录中检查是否已经存在请求文件的最新压缩文件； 如果请求文件的压缩文件不存在，Web服务器向浏览器返回未压缩的请求文件，并在压缩缓冲目录中存放请求文件的压缩文件； 如果请求文件的最新压缩文件已经存在，则直接返回请求文件的压缩文件； 如果请求文件是动态文件，Web服务器动态压缩内容并返回浏览器，压缩内容不存放到压缩缓存目录中。 下面是两个演示图：未使用Gzip： 开启使用Gzip后： 四、gzip与deflate区别deflate使用inflateInit()，而gzip使用inflateInit2()进行初始化，比 inflateInit()多一个参数: -MAX_WBITS，表示处理raw deflate数据。因为gzip数据中的zlib压缩数据块没有zlib header的两个字节。使用inflateInit2时要求zlib库忽略zlib header。在zlib手册中要求windowBits为8..15，但是实际上其它范围的数据有特殊作用，见zlib.h中的注释，如负数表示raw deflate。 Apache的deflate变种可能也没有zlib header，需要添加假头后处理。即MS的错误deflate (raw deflate).zlib头第1字节一般是0x78, 第2字节与第一字节合起来的双字节应能被31整除，详见rfc1950。例如Firefox的zlib假头为0x7801，python zlib.compress()结果头部为0x789c。 deflate 是最基础的算法，gzip 在 deflate 的 raw data 前增加了 10 个字节的 gzheader，尾部添加了 8 个字节的校验字节（可选 crc32 和 adler32） 和长度标识字节。 安装它们的Apache Web服务器版本的差异。Apache 1.x系列没有内建网页压缩技术，所以才去用额外的第三方mod_gzip 模块来执行压缩。而Apache 2.x官方在开发的时候，就把网页压缩考虑进去，内建了mod_deflate 这个模块，用以取代mod_gzip。虽然两者都是使用的Gzip压缩算法，它们的运作原理是类似的。 压缩质量。mod_deflate 压缩速度略快而mod_gzip 的压缩比略高。一般默认情况下，mod_gzip 会比mod_deflate 多出4%~6％的压缩量。 对服务器资源的占用。 一般来说mod_gzip 对服务器CPU的占用要高一些。mod_deflate 是专门为确保服务器的性能而使用的一个压缩模块，mod_deflate 需要较少的资源来压缩文件。这意味着在高流量的服务器，使用mod_deflate 可能会比mod_gzip 加载速度更快。即在服务器性能足够的情况下，使用mod_gzip，虽然会耗费服务器性能，但是值得（压缩更快更好）；在服务器性能不足的情况下，使用mod_deflate 确保性能。 从Apache 2.0.45开始，mod_deflate 可使用DeflateCompressionLevel 指令来设置压缩级别。该指令的值可为1（压缩速度最快，最低的压缩质量）至9（最慢的压缩速度，压缩率最高）之间的整数，其默认值为6（压缩速度和压缩质 量较为平衡的值）。这个简单的变化更是使得mod_deflate 可以轻松媲美mod_gzip 的压缩。 五、开启mod_gzip、mod_deflateApache上利用Gzip压缩算法进行压缩的模块有两种：mod_gzip 和mod_deflate。 要使用Gzip Web压缩，请首先确定你的服务器开启了对这两个组件之一的支持。在Linux服务器上，现在已经有越来越多的空间商开放了对它们的支持，有的甚至是同时 支持这两个模块的。例如目前Godaddy、Bluehost及DreamHosts等空间商的服务器都已同时支持mod_gzip 和mod_deflate。 通过查看HTTP头，我们可以快速判断使用的客户端浏览器是否支持接受gzip压缩。若发送的HTTP头中出现以下信息，则表明你的浏览器支持接受相应的gzip压缩： Accept-Encoding: gzip 支持mod_gzipAccept-Encoding: deflate 支持mod_deflate Accept-Encoding: gzip,deflate 同时支持mod_gzip 和mod_deflate mod_deflate 是apache自带的模块,当然是在apache 2后支持的,以前1的时候是mod_gzip,启用mod_deflate可以很好的为节省网页大小,只不过是占用服务器的资源和内存.用户看到页面的速度会大大加快。在apache2.0以上（包括apache2.0）的版中gzip压缩使用的是mod_deflate模块 查看apache的安装模式 apachectl -l 发现 mod_so.c，ok可以动态加模块，不用重新编译。 安装mod_deflate 找到原有的apache安装包安装mod_deflate cd httpd-2.0.59/modules/filters/usr/local/apache2/bin/apxs -i -c -a mod_deflate.c PS：apxs命令参数说明： -i 此选项表示需要执行安装操作，以安装一个或多个动态共享对象到服务器的modules目录中。 -a 此选项自动增加一个LoadModule行到httpd.conf文件中，以激活此模块，或者，如果此行已经存在，则启用之。 -A 与 -a 选项类似，但是它增加的LoadModule命令有一个井号前缀(#)，即此模块已经准备就绪但尚未启用。 -c 此选项表示需要执行编译操作。它首先会编译C源程序(.c)files为对应的目标代码文件(.o)，然后连接这些目标代码和files中其余的目标代码文件(.o和.a)，以生成动态共享对象dsofile 。如果没有指定 -o 选项，则此输出文件名由files中的第一个文件名推测得到，也就是默认为mod_name.so 。 3、修改Apache的http.conf文件，去除mod_deflate.so前面的注释 LoadModule deflate_module modules/mod_deflate.so 4、在根目录中新建.htaccess文件，定制压缩规则 #GZIP压缩模块配置&lt;ifmodule mod_deflate.c&gt;#启用对特定MIME类型内容的压缩SetOutputFilter DEFLATESetEnvIfNoCase Request_URI .(?:gif|jpe?g|png|exe|t?gz|zip|bz2|sit|rar|pdf|mov|avi|mp3|mp4|rm)$ no-gzip dont-vary #设置不对压缩的文件AddOutputFilterByType DEFLATE text/html text/css text/plain text/xml application/x-httpd-php application/x-javascript #设置对压缩的文件&lt;/ifmodule&gt; 5、对指定的文件配置缓存的生存时间，去除mod_headers.so模块前面的注释 LoadModule headers_module modules/mod_headers.so 6、在根目录中新建.htaccess文件，定制压缩规则 #文件缓存时间配置&lt;FilesMatch &quot;.(flv|gif|jpg|jpeg|png|ico|swf|js|css)$&quot;&gt;Header set Cache-Control &quot;max-age=2592000&quot;&lt;/FilesMatch&gt; 里面的文件MIME类型可以根据自己情况添加，至于PDF 、图片、音乐文档之类的这些本身都已经高度压缩格式，重复压缩的作用不大，反而可能会因为增加CPU的处理时间及浏览器的渲染问题而降低性能。所以就没必要再通过Gzip压缩。通过以上设置后再查看返回的HTTP头，出现以下信息则表明返回的数据已经过压缩。即网站程序所配置的Gzip压缩已生效。 Content-Encoding: gzip 注：不管使用mod_gzip 还是mod_deflate，此处返回的信息都一样。因为它们都是实现的gzip压缩方式。 遇到的问题以及解决: 1： apach2 安装mod_deflate后restart,直接 load /opt/apache/modules/mod_deflate.so into server: /opt/apache/modules/mod_deflate.so: undefined symbol: deflate 异常的痛苦 什么ldd mod_deflate.so后再export LIB_LIBRARY_PATH呀，都试了N次，google也go了N天 终于在google上go出来一篇文章，终于解决，方法如下： vi /usr/local/apache2/bin/apr-config 修改LDFLAGS=” “ 为 LDFLAGS=”-lz” 然后再apxs -ica mod_deflate.c 就OK了. 2：apach2 安装mod_deflate后restart,直接 module deflate_module is built-in and can&apos;t be loaded ... 这说明该模块已经安装，不必再LoadModule deflate_module启用它。 只需做配置 阅读原文","categories":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}],"tags":[{"name":"Vert.x3","slug":"Vert-x3","permalink":"http://quanke.name/tags/Vert-x3/"},{"name":"Vertx","slug":"Vertx","permalink":"http://quanke.name/tags/Vertx/"}],"keywords":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}]},{"title":"使用Gitbook写开源书籍，过一把作家瘾","slug":"tools/使用Gitbook写开源书籍，过一把作家瘾","date":"2016-04-25T01:16:28.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/45299/","link":"","permalink":"http://quanke.name/posts/45299/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 初级（适合没有编程基础的童鞋看）使用GitBook Editor 写开源书籍这个是gitbook官方出的编辑器，使用简单 首先下载GitBook Editor 下载地址：https://www.gitbook.com/editor 支持Mac、Linux、Windows 安装Windows 下载gitbook-win.zip； 解压； 打开GitBook.exe安装； Mac 下载 gitbook-mac.dmg安装即可 Linux 下载 gitbook-linux32.tar.gz 使用tar -xvzf gitbook-linux32.tar.gz解压 运行脚本 cd GitBook &amp;&amp; ./install.sh安装 使用安装完成之后，如果有github账号直接，登录，但是用github登录之后也需要设置gitbook的邮箱和密码，等会儿要用到，没有账号的直接注册就好； 登录后，可以直接在gitbook上创建书籍，建议在gitbook网站上创建书籍，然后通过GitBook Editor clone 下来； clone 下来之后 可以直接写书了，先在感觉是不是特别简单？别急，为了更爽的写作还需要继续看看下面。 怎么和github同步？ 如果没有github账号，先注册，之后绑定github账号 https://www.gitbook.com/@quanke/settings#social（把连接中的quanke修改为自己的用户名） 如果绑定了了github账号，需要设置权限，https://www.gitbook.com/@quanke/settings#github（把连接中的quanke修改为自己的用户名）， Reconnect GitHub Account 选择 With access to public repositories 当授权好了之后，我们来到书的设置（ Settings ）页面，点击设置github https://www.gitbook.com/book/quanke/vert-x-core-manual-for-java/settings/github（把quanke替换成你的用户名，把vert-x-core-manual-for-java替换成书名） 如果原来这本书是github里写的，直接填入github的地址就好，如果账号都是新建的，什么都没有，那就点击Export to GitHub （注意填入gitbook的用户名密码不是github的） 如果上面的步骤没问题，点击 Add webhook 就OK了，给github增加了一个钩子，也就是说当你的github更新的时候，会告诉gitbook 还有一步很关键,在你的GitBook Editor中，打开我们刚才clone下来的书，点击菜单里的 Book -&gt; Repository Settings ，把这个设置成为刚才导到github的地址，之后就可以在GitBook Editor写作了。。有什么不懂的，直接可以留言问我 进阶（适合有编程基础的童鞋看）gitbook 安装 安装npm从网站 https://nodejs.org/#download 下载node.js源代码（点击绿色的INSTALL），解压 ./configuremakemake install 成功执行后，npm就被安装好了。 gitbook 安装 npm install -g gitbook-cli gitbook -V 查看gitbook是否安装成功。 gitbook 使用 根据目录生成图书结构 1.1 README.md 与 SUMMARY编写 README.md 这个文件相当于一本Gitbook的简介。 $ mkdir test_gitbook$ touch README.md SUMMARY.md 这个文件是一本书的目录结构，使用Markdown语法，如我们这本书的SUMMARY.md： $ touch SUMMARY.md$ vim SUMMARY.md 输入 * [简介](README.md)* [第一章](chapter1/README.md) - [第一节](chapter1/section1.md) - [第二节](chapter1/section2.md)* [第二章](chapter2/README.md) - [第一节](chapter2/section1.md) - [第二节](chapter2/section2.md)* [结束](end/README.md) 1.2 生成图书结构 当这个目录文件创建好之后，我们可以使用Gitbook的命令行工具将这个目录结构生成相应的目录及文件： $ gitbook init$ tree . #查看建立的目录和文件 .├── chapter1│ ├── README.md│ ├── section1.md│ └── section2.md├── chapter2│ ├── README.md│ ├── section1.md│ └── section2.md├── end│ └── README.md├── README.md└── SUMMARY.md 我们可以看到，gitbook给我们生成了与SUMMARY.md所对应的目录及文件。 每个目录中，都有一个README.md文件，相当于一章的说明。 生成图书 2.1 输出为静态网站 你有两种方式输出一个静态网站： 2.1.1 本地预览时自动生成 当你在自己的电脑上编辑好图书之后，你可以使用Gitbook的命令行进行本地预览： $ gitbook serve . 然后浏览器中输入 http://localhost:4000 就可以预览生成的以网页形式组织的书籍。 这里你会发现，你在你的图书项目的目录中多了一个名为_book的文件目录，而这个目录中的文件，即是生成的静态网站内容。 使用build参数生成到指定目录与直接预览生成的静态网站文件不一样的是，使用这个命令，你可以将内容输入到你所想要的目录中去： $ mkdir /tmp/gitbook$ gitbook build --output=/tmp/gitbook 2.2 输出PDF 输入为PDF文件，需要先使用NPM安装上gitbook pdf：$ sudo npm install gitbook-pdf -g 我在执行上面这条命令的时候出现了下面的错误： ***************************************************Downloading http://cdn.bitbucket.org/ariya/phantomjs/downloads/phantomjs-1.9.7-linux-i686.tar.bz2Saving to /usr/local/lib/node_modules/gitbook-pdf/node_modules/phantomjs/phantomjs/phantomjs-1.9.7-linux-i686.tar.bz2Error: connect ETIMEDOUT at exports._errnoException (util.js:746:11) at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1010:19)npm ERR! Linux 3.2.0-4-686-paenpm ERR! argv &quot;/usr/local/bin/node&quot; &quot;/usr/local/bin/npm&quot; &quot;install&quot; &quot;gitbook-pdf&quot; &quot;-g&quot;npm ERR! node v0.12.7npm ERR! npm v2.11.3npm ERR! code ELIFECYCLEnpm ERR! phantomjs@1.9.7-5 install: `node install.js`npm ERR! Exit status 1npm ERR! npm ERR! Failed at the phantomjs@1.9.7-5 install script &apos;node install.js&apos;.npm ERR! This is most likely a problem with the phantomjs package,npm ERR! not with npm itself.npm ERR! Tell the author that this fails on your system:npm ERR! node install.jsnpm ERR! You can get their info via:npm ERR! npm owner ls phantomjsnpm ERR! There is likely additional logging output above.npm ERR! Please include the following file with any support request:npm ERR! /home/wangxq/repository/phantomjs/npm-debug.log*************************************************** 由错误报告内容的第一行可以知道，发生错误的原因是下载phantomjs发生了错误，因此我们需要手动下载和安装。 解决方法：[1] $ git clone git://github.com/ariya/phantomjs.git$ sudo apt-get install build-essential g++ flex bison gperf ruby perl \\ libsqlite3-dev libfontconfig1-dev libicu-dev libfreetype6 libssl-dev \\ libpng-dev libjpeg-dev python libx11-dev libxext-dev #安装编译需要的工具和依赖$ cd phantomjs$ git checkout 1.9.7 #注意：这里的1.9.7是phantom的版本号，可以由错误报告的第一行找出 $ ./build.sh --jobs 4$ sudo cp bin/phantomjs /bin/$ sudo npm install gitbook-pdf -g #重新进行安装 然后，使用下面的命令，要PDF文件，首先安装依赖库： $ sudo apt-get install calibre $ gitbook -v 2.1.0 pdf . 发生错误： *****************************************************info: start conversion to pdf ....ERRORError: Command failed: /bin/sh -c ebook-convert /tmp/tmp-29384ctltwbk/SUMMARY.html /tmp/tmp-29384ctltwbk/index.pdf --title=&quot;&quot; --comments=&quot;这本书是gitbook的一个例子&quot; --language=&quot;en&quot; --book-producer=&quot;GitBook&quot; --publisher=&quot;GitBook&quot; --chapter=&quot;descendant-or-self::*[contains(concat(&apos; &apos;, normalize-space(@class), &apos; &apos;), &apos; book-chapter &apos;)]&quot; --chapter-mark=&quot;pagebreak&quot; --page-breaks-before=&quot;/&quot; --level1-toc=&quot;descendant-or-self::*[contains(concat(&apos; &apos;, normalize-space(@class), &apos; &apos;), &apos; book-chapter-1 &apos;)]&quot; --level2-toc=&quot;descendant-or-self::*[contains(concat(&apos; &apos;, normalize-space(@class), &apos; &apos;), &apos; book-chapter-2 &apos;)]&quot; --level3-toc=&quot;descendant-or-self::*[contains(concat(&apos; &apos;, normalize-space(@class), &apos; &apos;), &apos; book-chapter-3 &apos;)]&quot; --no-chapters-in-toc --max-levels=&quot;1&quot; --breadth-first --margin-left=&quot;62&quot; --margin-right=&quot;62&quot; --margin-top=&quot;56&quot; --margin-bottom=&quot;56&quot; --pdf-default-font-size=&quot;12&quot; --pdf-mono-font-size=&quot;12&quot; --paper-size=&quot;a4&quot; --pdf-header-template=&quot;&lt;p class=&apos;header&apos;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&quot; --pdf-footer-template=&quot;&lt;p class=&apos;footer&apos;&gt;&lt;span&gt;_SECTION_&lt;/span&gt; &lt;span style=&apos;float:right;&apos;&gt;_PAGENUM_&lt;/span&gt;&lt;/p&gt;&quot;Usage: ebook-convert input_file output_file [options]Convert an ebook from one format to another.input_file is the input and output_file is the output. Both must be specified as the first two arguments to the command.The output ebook format is guessed from the file extension of output_file. output_file can also be of the special format .EXT where EXT is the output file extension. In this case, the name of the output file is derived the name of the input file. Note that the filenames must not start with a hyphen. Finally, if output_file has no extension, then it is treated as a directory and an &quot;open ebook&quot; (OEB) consisting of HTML files is written to that directory. These files are the files that would normally have been passed to the output plugin.After specifying the input and output file you can customize the conversion by specifying various options. The available options depend on the input and output file types. To get help on them specify the input and output file and then use the -h option.For full documentation of the conversion system seehttp://manual.calibre-ebook.com/conversion.htmlWhenever you pass arguments to ebook-convert that have spaces in them, enclose the arguments in quotation marks.ebook-convert: error: no such option: --pdf-default-font-size***************************************************** 解决方法[2] $ sudo -v &amp;&amp; wget -nv -O- https://raw.githubusercontent.com/kovidgoyal/calibre/master/setup/linux-installer.py | sudo python -c &quot;import sys; main=lambda:sys.stderr.write(&apos;Download failed\\n&apos;); exec(sys.stdin.read()); main()&quot;$ gitbook -v 2.1.0 pdf . # 重新执行命令生成pdf，目标文件为book.pdf 问题如果输入gitbook init命令，出现Installing version 2.1.0，需要耐性等待安装。","categories":[{"name":"使用","slug":"use","permalink":"http://quanke.name/categories/use/"}],"tags":[{"name":"gitbook","slug":"gitbook","permalink":"http://quanke.name/tags/gitbook/"}],"keywords":[{"name":"使用","slug":"use","permalink":"http://quanke.name/categories/use/"}]},{"title":"Android ObjectAnimator 无限循环播放，实现上下左右浮动效果","slug":"android/Android-ObjectAnimator-无限循环播放，实现上下左右浮动效果","date":"2016-04-23T11:04:41.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/12981/","link":"","permalink":"http://quanke.name/posts/12981/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 Android Property Animation 动画有很多大神写过，都非常好，这里只通过ObjectAnimator /ValueAnimator实现上下左右浮动效果。 很简单看代码就好 private void floatAnim(View view,int delay)&#123; List&lt;Animator&gt; animators = new ArrayList&lt;&gt;(); ObjectAnimator translationXAnim = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, -6.0f,6.0f,-6.0f); translationXAnim.setDuration(1500); translationXAnim.setRepeatCount(ValueAnimator.INFINITE);//无限循环 translationXAnim.setRepeatMode(ValueAnimator.INFINITE);// translationXAnim.start(); animators.add(translationXAnim); ObjectAnimator translationYAnim = ObjectAnimator.ofFloat(view, &quot;translationY&quot;, -3.0f,3.0f,-3.0f); translationYAnim.setDuration(1000); translationYAnim.setRepeatCount(ValueAnimator.INFINITE); translationYAnim.setRepeatMode(ValueAnimator.INFINITE); translationYAnim.start(); animators.add(translationYAnim); AnimatorSet btnSexAnimatorSet = new AnimatorSet(); btnSexAnimatorSet.playTogether(animators); btnSexAnimatorSet.setStartDelay(delay); btnSexAnimatorSet.start();&#125; 开始设置setRepeatMode(ValueAnimator.INFINITE);方法没有效果，只有设置setRepeatCount(ValueAnimator.INFINITE)才可以。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://quanke.name/tags/android/"},{"name":"android动画","slug":"android-a","permalink":"http://quanke.name/tags/android-a/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"10多年码代码经验腾讯管理谈职业规划","slug":"pmp/10多年码代码经验腾讯管理谈职业规划","date":"2016-04-23T10:56:22.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/60761/","link":"","permalink":"http://quanke.name/posts/60761/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 此人是我眼中的大神，曾经任职EA高级技术，腾讯技术管理，在级别提升后因为厌恶政治斗争，毅然离开腾讯开始创业。 cto眼中的牛人是什么？ 有多种解决方案； 有架构思维； 一专多通； 有预判能力； 思维不单一； 基础扎实； 有一些高阶技能； 技术人员分工： 前端： 多看别人的效果，别人做出来的模仿做出来，学习新技术，前端技术更新快，需要超级顺速的更新自己的技术 后端 （分为逻辑和服务） 逻辑 像php,生命周期相对短，变化快，更加需要学习新技术。 服务 生命周期长，复用要求更加高，多考虑架构的问题 运维 对于运营来说预判能力很重要 测试 一个强势的部门，如果不能强制那就不要做测试 铁塔模型和故宫模型对于中高级技术来说，有两条技术路可以走，第一条路是成为一个技术的专家，第二条路是成为解决方案的专家，第一条路就试我们所说的铁塔模型，技术很深，优点就是，立马能有回报，前期容易实现，最后能成为行业专家，很厉害，缺点就是容易倒，受环境影响大，需要有眼光和机缘，比如以前的塞班工程师牛逼哄哄的，但是塞班幕落的时候塞班工程师就抓狂了，第二种就是故宫模型，这种模型开始的时候看不到成效，不能立即变现，但是到后面会起来，可以在自己的故宫里建立各种东西，包括铁塔，不太受环境的影响。当然也可以组合成长，先一门技术能独当一面，其他技术也学习，这就是我们所说的一专多通，这就要看自己的选择了。 程序员高手养成： 第一：ide炉火纯青； 第二：优先考虑有哪些解决方案，不轻易说我不能实现。； 第三：熟悉新技术，比如java,可能现在用不到，但需要的时候能用好； 第四：一定要形成自己的技术体系，心目中熟悉各种架构，提炼出自己的架构。 职业阶梯1.代表初级 初级表现为，能实现一些基本的功能，毕业实习期一般为初级，一般一年左右 2.代表中级 中级表现为，功能基本都能实现，有一点点的分装思维，工作效率一般。 3.代表高级 高级表现为，有分装思想，考虑复用，能写出高质量，可复用，可扩展的代码，会一些一些基本的工具提高工作效率，精通一门语言 4.代表大牛 在开始的时候就有表达 5.行业精英 推动行业进步，有一定知名度 对于我们来说，每个人应该都要有成为行业精英的理想，但是我们生下来都是初级的，不论我们现在处于哪一位阶梯，都没有关系，这不一定是你自己的原因，有可能是没有遇到贵人，有可能是在为上上一个阶梯做准备，但是今天我们知道了，希望我们的人不要一直停留在自己阶梯。 从初级开始，我们每次成长都特别有成就感，比如，写了一个“Hello word”，可以被浏览器渲染出来，再写一个表单，能提交处理信息等，都是一个很有成就感的时候，这时候我们就处于阶梯的平面上，但是我们走着走着，就发现，自己很无力，比如我想做一个类似utan.com这样的网站，就要学习更多的东西，比如数据库设计、数据库管理、后端处理，服务器部署等（当然utan应该是多人合作的产物），这时候感觉自己很难提高了，遇到各种问题，踩各种坑，加班、痛苦随之而来，其实这都是正常的，这都是爬到上一个阶梯的必经之路，当爬的次数多了，就会想用石头垫在脚下，爬到上一个阶梯，当然自身的能力也会成长，就这样上中级，高级，但是要成为 牛人（4），就没有那么简单了，因为可能会遇到各种阻力，或者太滑上不去，要通过我们的智慧上去，比如，如果太滑可以借助防滑手套等等，这个自己体会。 还有一个层级都是行业精英，不是每个人都能成为行业精英的，要机缘，要看以前的路是否扎实，要看以前的选择是否符合发展等一系列因素都会影响我们成为行业精英。 反PMP项目管理就是一群技术不好的人，又不想放弃技术，就选择做PM，是以前在项目过程中产出的畸形产物，真正的高手是不需要PM的，我们倡导敏捷。 最后是提问环节。像Android或者iOS开发这种不确定性的技术有必要转型吗？不一定转型，但是绝不要只关注一个技术，比如做android只做android，做iOS的值关注ios，那就悲剧了，要去学习HTML5等，不知道未来会是怎么样？开放的心态去学习新的东西是正道。 怎么掌握新技术？有时候行业出现了很多优秀的技术，我们都是知道技术的成长最快的过程是在项目中成长，但是公司没有采取此技术，我们怎么办？ 先对技术有一个基本的了解，很清楚，新技术的优缺点，小规模的尝试性的在公司项目中用，最好是内部系统。 来自内部培训，地铁用上手机形成此文，欢迎拍砖。","categories":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}],"tags":[{"name":"职业规划","slug":"career-planning","permalink":"http://quanke.name/tags/career-planning/"}],"keywords":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}]},{"title":"Vert.x 3.x版本callback hell的解决","slug":"vertx/Vert-x-3-x版本callback-hell的解决","date":"2016-04-09T11:15:01.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/11284/","link":"","permalink":"http://quanke.name/posts/11284/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 Vert.x乃神器也，管玩管住还包饭，异步处理，很多人头疼的callback hell（回调地狱），也就是金字塔，不知不觉就走入了金字塔的陷阱里，一般callback都发生在异步处理期间，而异步处理，除了少数数据量极大的cpu intense的代码块以外（这部分主要通过降低算法时间复杂度来优化），绝大多数都集中在io上，将一个io操作包装成一个异步程序块来执行，是比较常见的优化方式，vert.x的io集中在以下几个部分。 第一，eventbus.send()方法。 第二，jdbcclient.getconnection以及connection.update/query等方法。 第三，httpclient.get/post等方法，其中前两个都可以通过vert.x自带的Future来对付。 首先我们要实例化一个future对象： Future&lt;MyResult&gt; future = Future.future(); 然后future有几个方法值得注意，其中一个是setHandler方法，这个方法就是设置后续处理的函数，另外一个，与之相对应的是completer()方法，这个方法返回的就是setHandler方法set的handler函数，通俗点说，就是getHandler()方法，在callback位置调用该方法，就可以在callback的时候执行handler方法/函数，比如原本是： vertx.eventBus().send(CommerceVerticle.class.getName(),myAsyncResult -&gt; &#123;...&#125;); 经过改写之后，就变成了： vertx.eventBus().send(CommerceVerticle.class.getName(),future.completer());future.setHandler(myAsyncResult -&gt; &#123;...&#125;); 这样通过拆分原来的内嵌lambda/匿名函数来达到扁平化的效果。callback hell一个典型特征就是金字塔，也就是经过多层回调/callback函数嵌套之后，程序会变成： ar -&gt; &#123; ar1 -&gt; &#123; ar2 -&gt; &#123; ... &#125; &#125;&#125;; 这种方式，或者fp里面常见的(+ 1 (+ 1 (+ 1 1)));如果强行format的话，就会变成一个多层多次缩进的，向右凸起的金字塔，极为丑陋，但是如果不这么做，又无法保证顺序，所以为了保证顺序的同时，我们要扁平化该金字塔，那么如何保证顺序呢？用compose方法，比如： Future fut1 = Future.future();Future fut2 = Future.future();fut1.compose(asyncMyResult -&gt; &#123; ... fut2.complete(); ...&#125;, fut2);fut2.setHandler(asyncMyResult2 -&gt; &#123; ...&#125;); 那么当fut1被触发之后，如果成功，则执行compose方法里面的第一个参数，也就是那个回调函数/handler，如果失败，则直接传递给compose方法的第二个参数，也就是fut2，依次类推，便可以很轻松地组装出你想要的扁平化链条，使得多层缩进的噩梦不再。利用这种方式，可以扁平化处理vertx.eventBus()，jdbcClient.getConnection()等包含有异步callback的代码块。至于Vert.x自带的httpclient，这个稍微有些特殊，因为执行get/post等方法的时候，response handler并不能囊括全部情况，尤其是常见的超时/timeout，属于exception范畴，也就是说，要想囊括全部返回情况，至少需要response的body handler，同时也需要一个exception handler，最后还要调用end方法才能将全部常见的情况全部覆盖住，代码如下： client1.get(port, ip, url, response -&gt; &#123; response.bodyHandler(respBody -&gt; &#123; //这里处理正常返回 &#125;);&#125;).exceptionHandler(exception -&gt; &#123; //这里处理超时&#125;).end(); 如果要在这里面用future的话，需要显式处理标识成功future.complete(...)或者失败future.fail(...)另外，常见的httpClient.getNow();等方法相当于： client1.get(port, ip, url, response -&gt; &#123; response.bodyHandler(respBody -&gt; &#123; //这里处理正常返回 &#125;);&#125;).end(); 也就是没有exception handler的普通get/post等方法＋end方法，所以如果用getNow等方法发送请求，会无法捕捉处理timeout超时异常。 通过这篇文章想必对Vertx如何避免callback hell有所了解。 参考此文编辑 非常感谢。","categories":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}],"tags":[{"name":"Vert.x3","slug":"Vert-x3","permalink":"http://quanke.name/tags/Vert-x3/"},{"name":"Vertx","slug":"Vertx","permalink":"http://quanke.name/tags/Vertx/"}],"keywords":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}]},{"title":"Vert-x配置项VertxOptions的使用","slug":"vertx/Vert-x配置项VertxOptions的使用","date":"2016-04-03T22:59:52.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/38014/","link":"","permalink":"http://quanke.name/posts/38014/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 今天清明节，一大早被孩子吵醒，起来撸一篇关于VertxOptions的文章，此文章诞生于洗手间，读此文章可能会闻到臭臭的味道。下面正式开始： 在发布Vert.x实例时，需要传入一个VertxOptions来实现针对Vert.x的配置项的管理，代码如下： VertxOptions options = new VertxOptions();options.setWorkerPoolSize(40)//举个栗子，设置支持的Worker线程的最大数量Vertx vertx = Vertx.vertx(options); 配置项的API说明： setEventLoopPoolSize 设置Vert.x实例中使用的Event Loop线程的数量，默认值为：2 * Runtime.getRuntime().availableProcessors()（可用的处理器个数）； setWorkerPoolSize 设置Vert.x实例中支持的Worker线程的最大数量，默认值为20； setInternalBlockingPoolSize 设置内部阻塞线程池最大线程数，这个参数主要被Vert.x的一些内部操作使用，默认值为20； setClustered 是否开启Vert.x的Cluster集群模式，默认值为false； setClusterHost 【Cluster集群模式有效】设置集群运行的默认hostname，默认值为localhost； setClusterPort 【Cluster集群模式有效】设置集群运行的端口号，可自定义固定端口号，默认值为0（随机分配）； setClusterPingInterval 【Cluster集群模式有效】使用ping命令检测Cluster的时间间隔，默认20000，单位毫秒ms，即20秒； setClusterPingReplyInterval 【Cluster集群模式有效】集群响应ping命令的时间间隔，默认20000，单位毫秒ms，即20秒； setBlockedThreadCheckInterval 阻塞线程检查的时间间隔，默认1000，单位ms，即1秒； setMaxEventLoopExecuteTime Event Loop的最大执行时间，默认2l 1000 1000000，单位ns，即2秒； setMaxWorkerExecuteTime Worker线程的最大执行时间，默认60l 1000 1000000，单位ns，即60秒； setHAEnabled 是否支持HA架构，默认值false；（*：如果Vert.x启用了HA模式，其中一个Vert.x实例运行出现了异常或者死掉，那么这个Vert.x实例中运行的Verticle会执行重发布Redeploy的过程将运行在该实例中的Verticle实例重新发布到其他正常运行的Vert.x实例中【Verticle Fail-Over】。） setHAGroup 【HA模式有效】支持了HA模式过后，可根据不同的组名将Vert.x进行逻辑分组，此方法设置当前Vert.x的逻辑组名，默认DEFAULT； setQuorumSize 【HA模式有效】支持了HA模式过后，此方法设置冲裁节点的数量，默认值1；（*：这个值一旦设置过后，如果要发布Verticle组件，则需要运行环境中的节点数量达到这个值才可执行发布，比如quorum的值设置成3，如果仅仅运行了两个Vert.x实例，那么这种情况下Verticle不会被发布，必须要运行至少三个Vert.x实例，才会执行发布Deploy流程，Undeploy流程类似） setWarningExceptionTime 如果线程阻塞时间超过了这个阀值，那么就会打印警告的堆栈信息，默认为5l 1000 1000000，单位ns，即5秒； 之后还有大招，请关注http://quanke.name/ ，马化腾群：231419585 此文参考： http://dwz.cn/32dhMF 感谢戒子猪","categories":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}],"tags":[{"name":"Vert.x3","slug":"Vert-x3","permalink":"http://quanke.name/tags/Vert-x3/"},{"name":"Vertx","slug":"Vertx","permalink":"http://quanke.name/tags/Vertx/"}],"keywords":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}]},{"title":"[Vert.x Core手册 for Java]-了解Vert.x","slug":"vertx/Vert-x-Core手册-for-Java-了解Vert-x","date":"2016-01-20T12:39:49.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/3468/","link":"","permalink":"http://quanke.name/posts/3468/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 源码在github上 Vert.x Core提供的功能： 编写TCP客户端和服务器 编写 HTTP 客户端和服务器包括 Websocket 支持 事件总线(Event bus) 共享的数据-本地的map和分布式的map 定时和延时运行 部署和非部署 Verticles Sockets DNS 客户端 文件系统 高可用性 集群 Vert.x核心功能是相当简单的 — — 你不会找到数据库访问、 授权或高级别 web 功能等，这些东西你可以在哪里找到？在这里-，Vert.x ext(扩展)。 Vert.x core 非常小，非常轻量级。只是使用你想要的部分。也是完全可嵌入在您现有的应用程序 — — 不强迫你使用特殊方式架构您的应用程序，这样你可以方向使用 Vert.x。 您可以使用任何 Vert.x 支持的其他语言的核心。这有点小酷-我们不强迫你使用 Java API ，JavaScript 或者 Ruby等都没问题 — — 毕竟，不同的语言有不同的习惯和语法，迫使Ruby 开发人员使用 Java 的语法，这会很奇怪 (举个例子)。相反，我们自动生成以 Java Api 为核心，等效、地道的每种语言。 从现在起我们会使用 core 指 Vert.x core。 如果你使用 Maven 或 Gradle，需要增加以下依赖才能使用Vert.x Core API: Maven (在你的pom.xml中): &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-core&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; Gradle (在您的build.gradle文件): compile io.vertx:vertx-core:3.2.0 下面让我们来讨论 core 的不同概念和功能。 从Vert.x开始注意：这大部分是Java特有的-需要语言特有的调用方法 如果没有获得Vertx对象，Vert.x做不了什么。 Vertx对象是 Vert.x 的控制中心，几乎可以做所有事，包括创建客户端和服务器，获取引用到事件总线（event bus）、 设置计时器等。 所以怎么获得Vertx实例? 如果已经嵌入了 Vert.x，然后只需创建一个实例，如下所示: Vertx vertx = Vertx.vertx(); 如果使用 Verticles 注意:大多数应用程序只需要一个单一的 Vert.x 实例，但如果你需要，可以创建多个 Vert.x 实例，例如，事件总线或不同的服务器和客户端之间的隔离。 创建一个指定选项的Vertx 对象创建一个 Vertx 对象时，如果默认值不是正确的选择，你还可以指定选项: Vertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40)); VertxOptions对象有许多设置，可以配置集群、 高可用性、 池的大小等。所有设置细节在Javadoc 中有描述。 创建群集 Vert.x 对象如果您正在创建clustered（群集） Vert.x (更多集群相关的请参阅事件总线（ event bus）)，然后通常会使用异步方式创建 Vertx 对象。 这是因为不同的 Vert.x 实例在群集中组合在一起，通常需要一些时间 (也许几秒钟) 的。在这段时间，我们不想阻止调用线程，所以我们把结果以异步方式给你。 你是傻瓜吗?你可能注意到，在前面使用fluent API（fluent API：流API，更易使用的API，也称傻瓜式API）的例子。 fluent API 是支持链式调用的。例如: request.response().putHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;).write(&quot;some text&quot;).end(); 整个 Vert.x Api都是这种模式，，所以要去适应它。 可以链式编写代码，当然你也可以按自己的喜欢，写上这样的代码： HttpServerResponse response = request.response();response.putHeader(&quot;Content-Type&quot;, &quot;text/plain&quot;);response.write(&quot;some text&quot;);response.end(); 不要call（调用、打电话）我们，我们会call给你。Vert.x Api 是很大程度上由事件驱动的。这意味着，当事情发生在你感兴趣的Vert.x，Vert.x 会通过回调方式向您发送events。 一些示例events: 计时器激活 socket收到数据 从磁盘读取数据 发生了异常 HTTP 服务器收到请求 通过向 Vert.x Api 提供处理程序来处理事件。例如要接收一个计时器事件每一秒你会做: vertx.setPeriodic(1000, id -&gt; &#123; // This handler will get called every second System.out.println(&quot;timer fired!&quot;);&#125;); 或接收到 HTTP 请求: server.requestHandler(request -&gt; &#123; // This handler will be called every time an HTTP request is received at the server request.response().end(&quot;hello world!&quot;);&#125;); 一段时间后当 Vert.x 有一个事件，它将传递到您的处理程序 Vert.x 将它异步调用. 这将引导我们进入Vert.x 中的一些重要概念: 不要阻塞我!除了极少数例外 (一些文件系统操作的“同步”结束)，没有一个 Vert.x Api 阻塞调用线程。 如果可以立即提供的结果，它将立即返回，你通常会提供一个handle来接收过一段时间的事件。 由于Vert.x API没有任何阻塞的线程，这意味着你可以使用Vert.x来处理只是使用小数目线程的大量并发。 常规阻塞API使用线程可能会阻塞： 从socket读取数据 向磁盘写入数据 向收件人发送一条消息，等待答复。 … 在所有上述情况下，当您的线程正在等待结果时它不能做别的-这是实际上是浪费。 这意味着，如果你需要大量的并发使用阻塞 APIs，然后你需要大量的线程，以防止您的应用程序停止工作。 线程在他们所需要的内存（例如栈）和上下文切换方面有开销。 对于许多现代应用程序所需要的并发水平，阻塞的方法不能按比例缩放。 Reactor和多Reactor之前提到Vert.x API是事件驱动 - 当他们都可用时，Vert.x传递事件给处理程序。 在大多数情况下Vertx要求使用一种称为event loop线程的处理程序。 如无有 Vert.x 或您的应用程序块中，event loop可以欢快地运行将事件传递给不同的处理程序提供事件陆续到达。 因为没有阻塞，event loop可以在短时间内提供大量的事件。例如一个单一的event loop可以非常迅速地处理成千上万的 HTTP 请求。 我们把这个叫做反应器模式（Reactor Pattern）. 你可能会有之前听说过-例如 Node.js 实现此模式。 标准的Reactor所有事件都运行在单一事件循环线程。 单个线程的麻烦是在任何一个时间它只能运行在单一的核心上(例如 Node.js 应用，如果想要实现多线程你要做很多事 。 而Vert.x 不同。不是单事件循环，每个 Vertx 实例都维护若干个事件循环。默认情况下，我们选择数量基于在机器上可用的内核数，但可以自己设置。 与 Node.js 不同是Vertx进程是可配置的，与 Node.js 不同 我们称这种模式多反应器（Multi-Reactor）模式，以区别于单线程的反应器模式。 注意：即使 Vertx 实例维护多个事件循环，任何特定的处理程序将永远不会被同时执行，在大多数情况下 (除了 worker verticles) 将始终使用完全相同的事件循环调用。 黄金法则 — 不要阻塞事件循环我们已经知道 Vert.x Api 是非阻塞，并且不会堵塞事件循环。如果你堵塞事件循环，那事件循环将不能做别的事，因为它被阻塞了。如果所有的event loop被阻塞了，应用程序将完全停止！ 所以不要这样做!你已经被警告。 阻塞的例子包括: Thread.sleep() 等待锁 等待互斥体或监视器 (例如同步段) 做一个长时间的数据库操作和等待返回 做复杂的计算，需要很长的时间。 死循环。 如果有上述情况停止了事件循环（event loop），需要相当长的时间，你应经立即去下一步，并等待进一步的指示。 这个时间具体多长？ 具体多长时间?它取决于应用程序需要的并发量。 如果你有一个单一的事件循环，并且你想要处理每秒 10000 的 http 请求，然后很明显，每个请求不能超过 0.1 ms 要处理，所以你不能阻塞比这更多的时间。 这道数学题并不是困难，作为练习留给读者。 如果您的应用程序不响应，可能你阻塞的事件循环的地方。为了帮助您诊断此类问题，如果它检测到一段时间后事件循环还没有恢复，Vert.x会自动记录警告。如果你在日志中看到这样的警告，那么你就应该去检查应用。 Thread vertx-eventloop-thread-3 has been blocked for 20458 ms Vert.x 还将提供堆栈跟踪来确定阻塞发生的位置。 如果你想关闭这些警告或更改设置，你可以在创建Vertx对象之前，使用VertxOptions配置。 运行阻塞代码在完美的世界，将没有战争或饥饿，所有 Api 将使用异步写，阳光明媚，绿色的草地有跳来跳去的兔子和手牵手的小羊羔。 但是，现实世界并不是这样。(你看过新闻最近吗?) 事实是，大多数库，特别是在JVM的生态,Y有许多是同步API，许多的方法有可能阻塞。一个很好的例子是JDBC API - 这是本质上的同步，不管如何努力尝试，Vert.x 不能撒上魔法使之同步。 我们不打算在一夜之间把一切改写成异步，所以我们需要给你提供一个方法，一个Vert.x应用中安全地使用“传统”的阻塞API的方法。 如前所述，直接在事件循环里调用阻塞操作，会妨碍它做任何其他有用的工作。所以你怎么能这样呢? 它是通过调用executeBlocking指定要执行的阻塞的代码和在执行阻塞的代码时调用返回异步结果处理程序。 通过调用executeblocking，执行阻塞代码，当阻塞代码执行完成后通过异步回调的方式返回 vertx.executeBlocking(future -&gt; &#123; // Call some blocking API that takes a significant amount of time to return String result = someAPI.blockingMethod(&quot;hello&quot;); future.complete(result);&#125;, res -&gt; &#123; System.out.println(&quot;The result is: &quot; + res.result());&#125;); 默认情况下，如果 executeBlocking 从相同的上下文 (例如同一垂直实例) 调用几次不同的 executeBlocking 则以串行方式执行 (即一个接一个)。 默认情况下，如果executeBlocking在同一环境（例如同一个verticle实例）多次调用，那么不同的executeBlocking将串行执行（即一个接一个）。 如果不关系执行顺序，调用executeBlocking时可以制定ordered参数为false。在这种情况下 executeBlocking 会与worker pool并行执行。 运行阻塞的代码替代方法是使用worker verticle worker verticle始终在worker池中的线程执行。 查看原文","categories":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}],"tags":[{"name":"Vert.x3","slug":"Vert-x3","permalink":"http://quanke.name/tags/Vert-x3/"},{"name":"Vertx","slug":"Vertx","permalink":"http://quanke.name/tags/Vertx/"},{"name":"Vert.x Core手册 for Java","slug":"vertx-for-java","permalink":"http://quanke.name/tags/vertx-for-java/"}],"keywords":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}]},{"title":"Vert.x 通过异步的方式使用JDBC连接SQL","slug":"vertx/Vert-x-通过异步的方式使用JDBC连接SQL","date":"2016-01-16T09:45:54.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/26137/","link":"","permalink":"http://quanke.name/posts/26137/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 在这篇文章中，我们将会看到怎样在vert.x应用中使用HSQL，当然也可以使用任意JDBC，以及使用vertx-jdbc-client提供的异步的API，这篇文章的代码在github上。 异步？vert.x一个很重要的特点就是它的异步性。使用异步的API，不需要等结果返回，当有结果返回时，vert.x会主动通知。为了说明这个，我们来看一个简单的例子。 我们假设有个add方法。一般来说，会像int r = add(1, 1)这样来使用它。这是一个同步的API，所以你必须等到返回结果。异步的API会是这样：add(1, 1, r -&gt; { /*do something with the result*/})。在这个版本中，你传入了一个Handler，当结果计算出来时才被调用。这个方法不返回任何东西，实现如下： public void add(int a, int b, Handler&lt;Integer&gt; resultHandler) &#123; int r = a + b; resultHandler.handle(r);&#125; 为了避免混淆概念，异步API并不是多线程。像我们在add例子里看到的，并没有涉及多线程。 异步JDBC看了一些基本的异步的API，现在了解下vertx-jdbc-client。这个组件能够让我们通过JDBC driver与数据库交互。这些交互都是异步的，以前这样： String sql = &quot;SELECT * FROM Products&quot;;ResultSet rs = stmt.executeQuery(sql); 现在要这样： connection.query(&quot;SELECT * FROM Products&quot;, result -&gt; &#123; // do something with the result&#125;); 这个模型更高效，当结果出来后vert.x通知，避免了等待结果。 增加maven依赖在pom.xml文件中增加两个 Maven dependencies &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-jdbc-client&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hsqldb&lt;/groupId&gt; &lt;artifactId&gt;hsqldb&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt;&lt;/dependency&gt; 第一个依赖提供了vertx-jdbc-client，第二个提供了HSQL JDBC的驱动。如果你想使用另外一个数据库，修改这个依赖，同时你还需要修改JDBC url和JDBC driver名。 初始化JDBC client创建JDBC 客户端（client）： 在MyFirstVerticle类中，声明一个新变量JDBCClient jdbc，并且在start方法中添加： jdbc = JDBCClient.createShared(vertx, config(), &quot;My-Whisky-Collection&quot;); 创建了一个JDBC client实例，使用verticle的配置文件配置JDBC client。这个配置文件需要提供下面的配置才能让JDBC client正常工作： url－JDBC url，例如：jdbc:hsqldb:mem:db?shutdown=true _driver class－JDBC的驱动，例如：org.hsqldb.jdbcDriver 有了client，接下来需要连接数据库。连接数据库是通过使用jdbc.getConnection来实现的，jdbc.getConnection需要传入一个Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt;参数。我们深入的了解下这个类型。首先，这是一个Handler，因此当结果准备好时它就会被调用。这个结果是AsyncResult&lt;SQLConnection&gt;的一个实例。AsyncResult是vert.x提供的一个结构，使用它能够知道连接数据库的操作是成功或失败了。如果成功了，它就会提供一个结果，这里结果是一个SQLConnection的实例。 当你接收一个AsyncResult的实例时，代码通常是： if (ar.failed()) &#123; System.err.println(&quot;The operation has failed...: &quot; + ar.cause().getMessage());&#125; else &#123; // Use the result: result = ar.result(); &#125; 需要获取到SQLConnection，然后启动rest的应用。因为变成了异步的，这需要改变启动应用的方式。因此，如果将启动序列划分成多块： startBackend( (connection) -&gt; createSomeData(connection, (nothing) -&gt; startWebApp( (http) -&gt; completeStartup(http, fut) ), fut ), fut); startBackend- 获取SQLConnection对象，然后调用下一步 createSomeData- 初始化数据库并插入数据。当完成后，调用下一步 startWebApp- 启动web应用 completeStartup- 最后完成启动 fut由vert.x传入，通知已经启动或者启动过程中遇到的问题。 startBackend方法： private void startBackend(Handler&lt;AsyncResult&lt;SQLConnection&gt;&gt; next, Future&lt;Void&gt; fut) &#123; jdbc.getConnection(ar -&gt; &#123; if (ar.failed()) &#123; fut.fail(ar.cause()); &#125; else &#123; next.handle(Future.succeededFuture(ar.result())); &#125; &#125;); &#125; 这个方法获取了一个SQLConnection对象，检查操作是否完成。如果成功，会调用下一步。失败了，就会报告一个错误。其他的方法遵循同样的模式： 检查上一步操作是否成功 处理业务逻辑 调用下一步 SQL客户端已经准备好了，现在写SQL。从createSomeData方法开始，这个方法也是启动顺序中的一部分： private void createSomeData(AsyncResult&lt;SQLConnection&gt; result, Handler&lt;AsyncResult&lt;Void&gt;&gt; next, Future&lt;Void&gt; fut) &#123; if (result.failed()) &#123; fut.fail(result.cause()); &#125; else &#123; SQLConnection connection = result.result(); connection.execute( &quot;CREATE TABLE IF NOT EXISTS Whisky (id INTEGER IDENTITY, name varchar(100), &quot; + &quot;origin varchar(100))&quot;, ar -&gt; &#123; if (ar.failed()) &#123; fut.fail(ar.cause()); connection.close(); return; &#125; connection.query(&quot;SELECT * FROM Whisky&quot;, select -&gt; &#123; if (select.failed()) &#123; fut.fail(ar.cause()); connection.close(); return; &#125; if (select.result().getNumRows() == 0) &#123; insert( new Whisky(&quot;Bowmore 15 Years Laimrig&quot;, &quot;Scotland, Islay&quot;), connection, (v) -&gt; insert(new Whisky(&quot;Talisker 57° North&quot;, &quot;Scotland, Island&quot;), connection, (r) -&gt; &#123; next.handle(Future.&lt;Void&gt;succeededFuture()); connection.close(); &#125;)); &#125; else &#123; next.handle(Future.&lt;Void&gt;succeededFuture()); connection.close(); &#125; &#125;); &#125;); &#125; &#125; 这个方法检查SQLConnection是否可用，然后执行一些SQL语句。首先，如果表不存在就创建表。看看下面代码： connection.execute( SQL statement, handler called when the statement has been executed) handler接收AsyncResult&lt;Void&gt;，例如：只有是通知而已，没有实际返回的结果。 关闭连接操作完成后，别忘了关闭SQL链接。这个连接会被放入连接池并且可以被重复利用。 在这个handler的代码里，检查了statement是否正确的执行了，如果正确，我们接下来检查表是否含有数据，如果没有，将会使用insert方法插入数据： private void insert(Whisky whisky, SQLConnection connection, Handler&lt;AsyncResult&lt;Whisky&gt;&gt; next) &#123; String sql = &quot;INSERT INTO Whisky (name, origin) VALUES ?, ?&quot;; connection.updateWithParams(sql, new JsonArray().add(whisky.getName()).add(whisky.getOrigin()), (ar) -&gt; &#123; if (ar.failed()) &#123; next.handle(Future.failedFuture(ar.cause())); return; &#125; UpdateResult result = ar.result(); // Build a new whisky instance with the generated id. Whisky w = new Whisky(result.getKeys().getInteger(0), whisky.getName(), whisky.getOrigin()); next.handle(Future.succeededFuture(w)); &#125;);&#125; 这个方法使用带有INSERT（插入）statement（声明）的upateWithParams方法，且传入了值。这个方法避免了SQL注入。一旦statement执行了（当数据库没有此条数据就会创建），就创建一个新的Whisky对象，自动生成ID。 带有数据库（SQL）的REST上面的方法都是启动顺序的一部分。但是，关于调用REST API的方法又是怎么样的呢？以getAll方法为例。这个方法被web应用前端调用，并检索存储的所有的产品： private void getAll(RoutingContext routingContext) &#123; jdbc.getConnection(ar -&gt; &#123; SQLConnection connection = ar.result(); connection.query(&quot;SELECT * FROM Whisky&quot;, result -&gt; &#123; List&lt;Whisky&gt; whiskies = result.result().getRows().stream().map(Whisky::new).collect(Collectors.toList()); routingContext.response() .putHeader(&quot;content-type&quot;, &quot;application/json; charset=utf-8&quot;) .end(Json.encodePrettily(whiskies)); connection.close(); // Close the connection &#125;); &#125;); &#125; 这个方法获得了一个SQLConnection对象，然后发出一个查询。一旦获取到查询结果，它会像之前的方法一样写HTTP response。getOne、deleteOne、updateOne和addOne方法都是一样的。注意，在response之后，需要要关闭SQL连接。 看下传入到query方法的handler提供的结果。获取了一个包含了查询结果的ResultSet。每一行都是一个JsonObject，因此，如果你有一个数据对象使用JsonObject作为唯一的参数，那么创建这个对象很简单。 测试需要小小的更新下测试程序，增加配置JDBCClient。在MyFirstVerticleTest类中，将setUp方法中创建的DeploymentOption对象修改成： DeploymentOptions options = new DeploymentOptions() .setConfig(new JsonObject() .put(&quot;http.port&quot;, port) .put(&quot;url&quot;, &quot;jdbc:hsqldb:mem:test?shutdown=true&quot;) .put(&quot;driver_class&quot;, &quot;org.hsqldb.jdbcDriver&quot;) ); 除了http.port，还配置了JDBC url和JDBC驱动。测试时，使用的是一个内存数据库。在src/test/resources/my-it-config.json文件中也要做同样的修改。 &#123; &quot;http.port&quot;: $&#123;http.port&#125;, &quot;url&quot;: &quot;jdbc:hsqldb:mem:it-test?shutdown=true&quot;, &quot;driver_class&quot;: &quot;org.hsqldb.jdbcDriver&quot;&#125; src/main/conf/my-application-conf.json文件也同样需要修改，这不是为了测试，而是为了运行这个应用： &#123; &quot;http.port&quot; : 8082, &quot;url&quot;: &quot;jdbc:hsqldb:file:db/whiskies&quot;, &quot;driver_class&quot;: &quot;org.hsqldb.jdbcDriver&quot;&#125; 这里这个JDBC url和上一个文件的有点不一样，因为需要将数据库存储到硬盘中。 展示时间！开始构建程序： mvn clean package 没有修改API（没有更改发布的java文件和REST接口），测试应该是可以顺利的运行的。 启动应用： java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar -conf src/main/conf/my-application-conf.json 访问http://localhost:8082/assets/index.html，然后，你可以看到这个应用使用的是数据库了。这一次，就算重启应用，这些数据仍然在，因为存储产品被持久化到硬盘里了。 总结这篇文章中，知道了怎么在vert.x里使用JDBC数据库，并没有很多复杂的东西。开始可能会被这个异步的开发模型惊讶到，但是，一旦你开始使用了，你就很难再回去了。 下一次，我们将看到这个应用怎么使用mongoDB来替换HSQL。 Stay tuned, and happy coding !","categories":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}],"tags":[{"name":"Vert.x3","slug":"Vert-x3","permalink":"http://quanke.name/tags/Vert-x3/"},{"name":"Vertx","slug":"Vertx","permalink":"http://quanke.name/tags/Vertx/"}],"keywords":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}]},{"title":"怎样写一个安全的Vert.x Web apps","slug":"vertx/怎样写一个安全的Vert-x-Web-apps","date":"2016-01-16T08:36:32.000Z","updated":"2018-02-02T14:53:35.000Z","comments":true,"path":"posts/43843/","link":"","permalink":"http://quanke.name/posts/43843/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 此文只是对vert.x Web应用程序的入门指导（大神请绕道）。 这绝不是对Web应用程序安全性的全面指导，如OWASP。 标准规则和惯例适用于vert.x应用程序。 不要用root身份运行DEVOPS团队成员会经常说，只给必要的运行权限，不要多给。有些新手试图以root用户在80或443端口下运行，虽然这样简单，但也为坏蛋打开一扇门。 让我们看看下面的代码： public class App extends AbstractVerticle &#123; @Override public void start() &#123; Router router = Router.router(vertx); router.route().handler(StaticHandler.create(&quot;&quot;)); vertx.createHttpServer().requestHandler(router::accept).listen(80); &#125;&#125; 当与开始CWD设置为/ (java -Dvertx.cwd=/ ...)你就创建了一个简单的文件服务器，给所有服务器存储。 现在，假设你要启动这个程序，会打印如下错误： Aug 26, 2015 2:02:18 PM io.vertx.core.http.impl.HttpServerImplSEVERE: java.net.SocketException: Permission denied 如果你现在使用root运行的，浏览器输入http://localhost/etc/shadow，恭喜你，你的服务器logins 和 passwords 暴露了 ！ 有几种方法，可以root用户运行，使用iptables请求转发到更高的端口，使用authbind，配置代理服务器ngnix等… Sessions许多应用程序要处理在某些时候用户会话。 会话Cookie应该有SECURE和HTTPOnly设置的标志，只发送HTTPS（在使用HTTPS？），也没有脚本访问cookie的客户端： Router router = Router.router(vertx); router.route().handler(CookieHandler.create()); router.route().handler(SessionHandler .create(LocalSessionStore.create(vertx)) .setCookieHttpOnlyFlag(true) .setCookieSecureFlag(true) ); router.route().handler(routingContext -&gt; &#123; Session session = routingContext.session(); Integer cnt = session.get(&quot;hitcount&quot;); cnt = (cnt == null ? 0 : cnt) + 1; session.put(&quot;hitcount&quot;, cnt); routingContext.response().end(&quot;Hitcount: &quot; + cnt); &#125;); vertx.createHttpServer().requestHandler(router::accept).listen(8080); 在这种情况下，检查浏览器，应该看到： 你的浏览器的脚本有读取的能力，可以嗅探劫持或篡改您的会话。 Security Headers有很多的安全headers有助于提高安全性，只需几行代码。 没有必要在这里解释，因为网上有很好的文章说的做得可能会比我更好。 怎么实现： public class App extends AbstractVerticle &#123; @Override public void start() &#123; Router router = Router.router(vertx); router.route().handler(ctx -&gt; &#123; ctx.response() // do not allow proxies to cache the data .putHeader(&quot;Cache-Control&quot;, &quot;no-store, no-cache&quot;) // prevents Internet Explorer from MIME - sniffing a // response away from the declared content-type .putHeader(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;) // Strict HTTPS (for about ~6Months) .putHeader(&quot;Strict-Transport-Security&quot;, &quot;max-age=&quot; + 15768000) // IE8+ do not allow opening of attachments in the context of this resource .putHeader(&quot;X-Download-Options&quot;, &quot;noopen&quot;) // enable XSS for IE .putHeader(&quot;X-XSS-Protection&quot;, &quot;1; mode=block&quot;) // deny frames .putHeader(&quot;X-FRAME-OPTIONS&quot;, &quot;DENY&quot;); &#125;); vertx.createHttpServer().requestHandler(router::accept).listen(8080); &#125;&#125; 保护跨站请求伪造（CSRF）Vert.x web在handler里提供了CSRF保护。下面代码增加CSRF保护： public class App extends AbstractVerticle &#123; @Override public void start() &#123; Router router = Router.router(vertx); router.route().handler(CookieHandler.create()); router.route().handler(SessionHandler .create(LocalSessionStore.create(vertx)) .setCookieHttpOnlyFlag(true) .setCookieSecureFlag(true) ); router.route().handler(CSRFHandler.create(&quot;not a good secret&quot;)); router.route().handler(ctx -&gt; &#123; ... &#125;); 该处理器(handler)增加了一个CSRF令牌(token)。 为了改变cookie（XSRF-TOKEN），设置了一个独一无二的token，即预计返回一个（X-XSRF-TOKEN）header。 限制上传上传处理一定要定义一个上限，否则你会很容易受到DDoS攻击。 例如，看看下面的代码： public class App extends AbstractVerticle &#123; @Override public void start() &#123; Router router = Router.router(vertx); router.route().handler(BodyHandler.create()); router.route().handler(ctx -&gt; &#123; ... 现在，“好心人”可以随机生成一个1GB的垃圾文件： dd if=/dev/urandom of=ddos bs=1G count=1 然后把它上传到你的服务器： curl --data-binary &quot;@ddos&quot; -H &quot;Content-Type: application/octet-stream&quot; -X POST http://localhost:8080/ 您的应用程序将愉快地处理，上面两步不断重复，它会耗尽磁盘空间或内存。 为了减轻这些类型的攻击，始终指定的最大允许上传的大小： public class App extends AbstractVerticle &#123; private static final int KB = 1024; private static final int MB = 1024 * KB; @Override public void start() &#123; Router router = Router.router(vertx); router.route().handler(BodyHandler.create().setBodyLimit(50 * MB)); 最后虽然只有几点，也应该记住。 当程序要用于生产，你还要注意更多： OWASP Top Ten Project Preventing SQL Injection in Java Testing for NoSQL injection","categories":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}],"tags":[{"name":"Vert.x3","slug":"Vert-x3","permalink":"http://quanke.name/tags/Vert-x3/"},{"name":"Vertx","slug":"Vertx","permalink":"http://quanke.name/tags/Vertx/"}],"keywords":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}]},{"title":"LiveOak 系列不再更新","slug":"liveoak/LiveOak-系列不再更新","date":"2016-01-16T01:26:09.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/60311/","link":"","permalink":"http://quanke.name/posts/60311/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 因为官方放弃此项目，LiveOak系列也不再更新。","categories":[{"name":"MBaaS-LiveOak系列","slug":"MBaaS-LiveOak系列","permalink":"http://quanke.name/categories/MBaaS-LiveOak系列/"}],"tags":[{"name":"MBaaS","slug":"MBaaS","permalink":"http://quanke.name/tags/MBaaS/"}],"keywords":[{"name":"MBaaS-LiveOak系列","slug":"MBaaS-LiveOak系列","permalink":"http://quanke.name/categories/MBaaS-LiveOak系列/"}]},{"title":"Vert.x 实现REST","slug":"vertx/Vert-x-实现REST","date":"2016-01-15T13:19:45.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/36108/","link":"","permalink":"http://quanke.name/posts/36108/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 回顾在第一篇文章中开发了一个非常简单的Vert.x 3应用程序，还包括怎么测试、打包和执行。在第二篇文章中对端口进行了可变配置。 这篇文章中，开发一个CRUD（增删改查）应用，发布一个HTML页面，通过REST API与后台进行交互。RESTfull形式的API不简单，这篇文章中就不涉及了。 接下来，能看到： Vert.x Web - 使用Vert.x创建Web应用的框架 怎么发布静态资源 怎么开发REST API 这篇文章开发的代码放在GitHub上，是从第二篇文章的代码基础上进行的。 开始Vert.x Web如果你看了前面的文章，使用Vert.x Core来处理复杂的HTTP应用还是很麻烦的，所以就有了Vert.x Web，它可以使Vert.x开发一个web应用更加简单，而且不会改变Vert.x的思想。 更新pom.xml文件，添加下面的依赖： &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-web&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 这就是使用Vert.x Web的唯一前提。 还记得在上一篇文章中，当请求http://localhost:8080时，返回一个Hello World消息，使用Vert.x Web完成同样的事情，打开name.quanke.study.vertx.first.MyFirstVerticle.java 类，修改start方法： @Overridepublic void start(Future&lt;Void&gt; fut) &#123; // Create a router object. Router router = Router.router(vertx); // Bind &quot;/&quot; to our hello message - so we are still compatible. router.route(&quot;/&quot;).handler(routingContext -&gt; &#123; HttpServerResponse response = routingContext.response(); response .putHeader(&quot;content-type&quot;, &quot;text/html&quot;) .end(&quot;&lt;h1&gt;Hello from my first Vert.x 3 application&lt;/h1&gt;&quot;); &#125;); // Create the HTTP server and pass the &quot;accept&quot; method to the request handler. vertx .createHttpServer() .requestHandler(router::accept) .listen( // Retrieve the port from the configuration, // default to 8080. config().getInteger(&quot;http.port&quot;, 8080), result -&gt; &#123; if (result.succeeded()) &#123; fut.complete(); &#125; else &#123; fut.fail(result.cause()); &#125; &#125; );&#125; 在开始start方法里创建了一个Router对象。router是Vert.x Web的基础，负责分发HTTP请求到handler（处理器），在Vert.x Web中还有两个很重要的概念。 Routes-定义请求的分发 Handlers-这是实际处理请求并且返回结果的地方。Handlers可以被链接起来使用。 如果明白了这3个概念（Router、Routes、Handlers），就明白了Vert.x Web的所有了。 仔细看看下面这段代码： router.route(&quot;/&quot;).handler(routingContext -&gt; &#123; HttpServerResponse response = routingContext.response(); response .putHeader(&quot;content-type&quot;, &quot;text/html&quot;) .end(&quot;&lt;h1&gt;Hello from my first Vert.x 3 application&lt;/h1&gt;&quot;);&#125;); 将访问”/“（http://localhost:8080/）的请求“路由”到指定的handler。Handlers接收RoutingContext对象。这个handler的方法和我们之前的代码很像，他们操作的是同一个HttpServerResponse类型的对象。 让我们来看看剩下的代码： vertx .createHttpServer() .requestHandler(router::accept) .listen( // Retrieve the port from the configuration, // default to 8080. config().getInteger(&quot;http.port&quot;, 8080), result -&gt; &#123; if (result.succeeded()) &#123; fut.complete(); &#125; else &#123; fut.fail(result.cause()); &#125; &#125; );&#125; 除了改变了request handler，基本和之前的代码一样。传router::accept给handler。你可能对这个符号不太熟悉。它表示引用一个方法（这里是引用router的accept方法）。换句话说，当接收到一个请求的时候，告诉vert.x从router里调用accept方法。 让我们来看下它是怎么工作的： mvn clean packagejava -jar target/my-first-app-1.0-SNAPSHOT-fat.jar 浏览器打开http://localhost:8080，你会看到Hello的消息。 发布静态资源现在有了第一个使用Vert.x Web开发的应用。先在写增加一个index.html页面（静态资源）。 这个HTML页面将会是我们应用的入口。在src/main/resources/assets目录下，index.html文件在github上。此文不涉及这个文件的细节。 基本上，就是一个简单的CRUD的UI界面，actions是由通过AJAX调用的REST API执行的。 创建完了页面后，编辑name.quanke.study.vertx.first.MyFirstVerticle类，并修改start方法： @Overridepublic void start(Future&lt;Void&gt; fut) &#123; Router router = Router.router(vertx); router.route(&quot;/&quot;).handler(routingContext -&gt; &#123; HttpServerResponse response = routingContext.response(); response .putHeader(&quot;content-type&quot;, &quot;text/html&quot;) .end(&quot;&lt;h1&gt;Hello from my first Vert.x 3 application&lt;/h1&gt;&quot;); &#125;); // Serve static resources from the /assets directory // 将访问“/assets/*”的请求route到“assets”目录下的资源 router.route(&quot;/assets/*&quot;).handler(StaticHandler.create(&quot;assets&quot;)); vertx .createHttpServer() .requestHandler(router::accept) .listen( // Retrieve the port from the configuration, // default to 8080. config().getInteger(&quot;http.port&quot;, 8080), result -&gt; &#123; if (result.succeeded()) &#123; fut.complete(); &#125; else &#123; fut.fail(result.cause()); &#125; &#125; );&#125; 就这段代码和前面的不同： router.route(&quot;/assets/*&quot;).handler(StaticHandler.create(&quot;assets&quot;)); 这一行是什么意思？挺简单的。将访问“/assets/*”的请求route到“assets”目录下的资源。现在可以通过http://localhost:8080/assets/index.html来访问index.html了。 测试之前，我们花一些时间来看一下handler的创建。所有的处理请求动作在Vert.x Web里都实现成handler。而创建一个handler需要调用create方法。 编译、运行： mvn clean packagejava -jar target/my-first-app-1.0-SNAPSHOT-fat.jar 浏览器，输入http://localhost:8080/assets/index.html。 现在这个table是空的。那是因为我们还没有实现REST的API。现在让我们来开始吧。 使用Vert.x Web实现REST APIVert.x Web实现REST API很简单。看下面： GET /api/whiskies =&gt; 获取所有的威士忌（getAll） GET /api/whiskies/:id =&gt; 获取指定id的威士忌（getOne） POST /api/whiskies =&gt;添加一瓶威士忌（addOne） PUT /api/whiskies/:id =&gt; 编辑一瓶威士忌(updateOne) DELETE /api/whiskies/id =&gt; 删除一瓶威士忌(deleteOne) 我们需要一些数据。。。在实现REST API之前，需要创建Whisky的数据模型。使用下面的内容创建src/main/java/quanke/name/study/vertx/first/Whisky.java： package name.quanke.study.vertx.first;import java.util.concurrent.atomic.AtomicInteger;public class Whisky &#123; private static final AtomicInteger COUNTER = new AtomicInteger(); private final int id; private String name; private String origin; public Whisky(String name, String origin) &#123; this.id = COUNTER.getAndIncrement(); this.name = name; this.origin = origin; &#125; public Whisky() &#123; this.id = COUNTER.getAndIncrement(); &#125; public String getName() &#123; return name; &#125; public String getOrigin() &#123; return origin; &#125; public int getId() &#123; return id; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setOrigin(String origin) &#123; this.origin = origin; &#125;&#125; 这是一个很简单的bean类。因为Vert.x依赖Jackson来处理JSON格式,Jackson能够自动序列化和反序列化bean类，让代码变得更简单，所以选择这样的格式。 现在，创建几瓶威士忌。在MyFirstVerticle类中，添加下面的代码： // Store our product// 存储产品private Map&lt;Integer, Whisky&gt; products = new LinkedHashMap&lt;&gt;();// Create some product// 创建一些产品private void createSomeData() &#123; Whisky bowmore = new Whisky(&quot;Bowmore 15 Years Laimrig&quot;, &quot;Scotland, Islay&quot;); products.put(bowmore.getId(), bowmore); Whisky talisker = new Whisky(&quot;Talisker 57° North&quot;, &quot;Scotland, Island&quot;); products.put(talisker.getId(), talisker);&#125; 然后，在start方法里，调用createSomeData方法： @Overridepublic void start(Future&lt;Void&gt; fut) &#123; createSomeData(); // Create a router object. Router router = Router.router(vertx); // Rest of the method&#125; 在这里并没有一个后台数据库。仅使用一个map，将数据存储在内存中。添加后端数据库的介绍我准备放在另一篇文章中讲。 获得产品（威士忌）GET /api/whiskies，JSON数组中返回产品列表。 在start方法里，添加下面这行（static handler）： router.get(&quot;/api/whiskies&quot;).handler(this::getAll); 告诉router调用getAll方法来处理&quot;/api/whiskies&quot;的GET请求。代码可以写在handler里，但是为了让代码更加清晰，另外创建一个方法： private void getAll(RoutingContext routingContext) &#123; routingContext.response() .putHeader(&quot;content-type&quot;, &quot;application/json; charset=utf-8&quot;) .end(Json.encodePrettily(products.values()));&#125; 每一个handler（比如：请看上面的代码）都会接受一个RoutingContext参数。通过设置content-type和一些内容来填充response。因为内容可能会碰到特殊的字符，所以强制使用UTF-8的格式。创建内容的时候，并不需要自己去处理JSON格式的字符串。Vert.x有处理Json的API。使用Json.encodePrettily(products.values())处理JSON字符串。本应使用Json.encodePrettily(products)，但是为了让JavaScript代码更简单，我们仅返回威士忌（产品）的数据集合，并没有返回包含Id=&gt;Bottle的键值对。 打包运行： mvn clean packagejava -jar target/my-first-app-1.0-SNAPSHOT-fat.jar 浏览器访问http://localhost:8080/assets/index.html，然后你将会看到下面这个页面。 很好奇，想看一下REST API到底返回了什么。打开浏览器，访问http://localhost:8080/api/whiskies。你会看到下面这样的信息： [ &#123; &quot;id&quot; : 0, &quot;name&quot; : &quot;Bowmore 15 Years Laimrig&quot;, &quot;origin&quot; : &quot;Scotland, Islay&quot;&#125;, &#123; &quot;id&quot; : 1, &quot;name&quot; : &quot;Talisker 57° North&quot;, &quot;origin&quot; : &quot;Scotland, Island&quot;&#125; ] 创建一个产品能获取到威士忌（产品）了，现在需要创建一个产品。不像之前的REST API，这一次，需要读取request的body。因为性能的原因，它应该被显式地启用。不要怕，这也仅仅是一个handler而已。 在start方法中，添加下面的内容到getAll的后面： router.route(&quot;/api/whiskies*&quot;).handler(BodyHandler.create());router.post(&quot;/api/whiskies&quot;).handler(this::addOne); 第一行允许&quot;/api/whiskies&quot;下的所有route读取请求的body。通过使用router.route().handler(BodyHandler.create())，能让它在全局生效。 第二行将对/api/whiskies的POST请求映射到addOne方法。让我们来创建这个方法： private void addOne(RoutingContext routingContext) &#123; final Whisky whisky = Json.decodeValue(routingContext.getBodyAsString(), Whisky.class); products.put(whisky.getId(), whisky); routingContext.response() .setStatusCode(201) .putHeader(&quot;content-type&quot;, &quot;application/json; charset=utf-8&quot;) .end(Json.encodePrettily(whisky));&#125; 开始从请求的body中取出Whisky对象。只是将body读成一个字符串并将它传入到Json.decodeValue方法里。Whisky这个对象一旦创建好，将被添加到后台的map中，并以JSON的格式返回。 重新编译并且运行： mvn clean packagejava -jar target/my-first-app-1.0-SNAPSHOT-fat.jar 刷新HTML页面，点击Add a new bottle按钮。输入数据，如：“quanke” 作为名字， “quanke.name” 作为产地 ，就OK了。 状态码 201 ？CREATED和在REST API中创建一个entity时，response的状态码为201。。默认的vert.x web设置一个200的状态码代表OK。 删除一个产品在start方法里，添加： router.delete(&quot;/api/whiskies/:id&quot;).handler(this::deleteOne); 在URL里，参数为：:id。在处理一个相匹配的请求的时候，Vert.x提取路径中与这个参数对应的一段，能够在handler中获得。例如，/api/whiskies/0将id映射为0。 看一下在handler方法中这个参数是怎样被使用的。创建一个deleteOne方法。 private void deleteOne(RoutingContext routingContext) &#123; String id = routingContext.request().getParam(&quot;id&quot;); if (id == null) &#123; routingContext.response().setStatusCode(400).end(); &#125; else &#123; Integer idAsInteger = Integer.valueOf(id); products.remove(idAsInteger); &#125; routingContext.response().setStatusCode(204).end();&#125; 状态码 204 ？状态码为204 - NO CONTENT。HTTP delete动作通常都是无返回内容的。 其他方法实现getOne和updateOne很简单，和上面的差不多，此文不再详细介绍。源码在github上 总结此文介绍了如何用Vert.x web轻松的实现一个REST API，如何访问静态资源。比以前的文章复杂些，但仍然还是很简单。","categories":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}],"tags":[{"name":"Vert.x3","slug":"Vert-x3","permalink":"http://quanke.name/tags/Vert-x3/"},{"name":"Vertx","slug":"Vertx","permalink":"http://quanke.name/tags/Vertx/"}],"keywords":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}]},{"title":"Vert.x 应用的配置","slug":"vertx/Vert-x-应用的配置","date":"2016-01-14T23:40:12.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/54943/","link":"","permalink":"http://quanke.name/posts/54943/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 在上篇文章中，开发了一个简单的Vert.x应用，介绍了怎么测试，打包和执行，这仅仅是一个开始，在这篇文章中，我们通过配置来提高应用。 还记得，在上一个应用中有HTTP server，监听8080端口，应答一个“Hello”的消息，上篇文章的代码在这里，本篇文章的代码在github 为什么需要配置？这个问题非常好。这个应用是正常工作的，但是如果当你部署在8080端口已经被占领了的机器上，如果要部署在这个机器上，我们就需要到代码里修改应用程序和测试里的端口了，这不能忍受，很幸运的是Vert.x配置一下就可以了。 Vert.x使用的是JSON格式配置的，所以很简单，可以使用API传给verticle或者命令行，我们来看一看。 不使用 ‘8080’ 端口第一步是修改name/quanke/study/vertx/first/MyFirstVerticle.java类，从配置里读取端口，而不8080绑定，默认是8080端口： public void start(Future&lt;Void&gt; fut) &#123; vertx .createHttpServer() .requestHandler(r -&gt; &#123; r.response().end(&quot;Hello from my first &quot; + &quot;Vert.x 3 application&quot;); &#125;) .listen( // Retrieve the port from the configuration, //从配置里检索端口 // default to 8080. //默认8080 config().getInteger(&quot;http.port&quot;, 8080), result -&gt; &#123; if (result.succeeded()) &#123; fut.complete(); &#125; else &#123; fut.fail(result.cause()); &#125; &#125; );&#125; 与上一版本的区别仅仅是listen里面的第一个参数8080换成config().getInteger(&quot;http.port&quot;, 8080)。这里，我们的代码会请求这个配置并检查http.port属性是否配置了。如果没有，将会默认使用8080端口。配置信息是从JsonObject中返回的。 默认还是使用8080，所以打包运行和以前一样： mvn clean packagejava -jar target/my-first-app-1.0-SNAPSHOT-fat.jar 使用API的方式配置 - 在测试中随机生成端口号在测试代码中，我们把端口修改成8081，部署（deploying）verticle的代码如下： vertx.deployVerticle(MyFirstVerticle.class.getName(), context.asyncAssertSuccess()); 传入部署（deploying）选项： port = 8081;DeploymentOptions options = new DeploymentOptions() .setConfig(new JsonObject().put(&quot;http.port&quot;, port));vertx.deployVerticle(MyFirstVerticle.class.getName(), options, context.asyncAssertSuccess()); post在全局变量里面声明的private Integer port; DeploymentOptions对象可以定义多个参数。将JsonObject注入到verticle的config()方法中。 连接服务器的代码需要修改一下，端口要和测试里面的一样才行。 vertx.createHttpClient().getNow(port, &quot;localhost&quot;, &quot;/&quot;, response -&gt; &#123; response.handler(body -&gt; &#123; context.assertTrue(body.toString().contains(&quot;Hello&quot;)); async.complete(); &#125;);&#125;); 这个并没有完全解决问题，如果8081端口也被占用了怎么办？我们使用随机端口： ServerSocket socket = new ServerSocket(0);port = socket.getLocalPort();socket.close();DeploymentOptions options = new DeploymentOptions() .setConfig(new JsonObject().put(&quot;http.port&quot;, port) );vertx.deployVerticle(MyFirstVerticle.class.getName(), options, context.asyncAssertSuccess()); 这种方式是很简单。打开server socket获取一个随机的端口（这也是为什么将0作为参数）。检索如果端口被占用就关闭socket。需要注意的是，这个方法并不完美，如果端口在socket.close()方法之后和HTTP服务器启动之前被占用的话，会失败。然而，这种情况如果被朋友的话，说明你非常幸运，所以大多数情况下都是没有问题的。 测试一下： mvn clean test 外部配置-在另一个端口运行在生产环境中，随机端口并不是我们想要的。所以，在实际执行应用的时候，我们需要将配置写在一个外部的文件里。这个配置的文件使用json格式。 创建src/main/conf/my-application-conf.json，内容如下： &#123; &quot;http.port&quot; : 8082&#125; 通过执行下面这句命令，在启动应用的时候，加载配置文件: java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar -conf src/main/conf/my-application-conf.json 打开浏览器，然后访问 http://localhost:8082 。 编辑JSON文件，重新打包运行，端口就修改了，不需要修改源码。 这是怎么工作的？fat jar是使用Starter类来加载应用程序。当部署verticle的时候，这个类会读取-conf参数，相应的会创建一个DeploymentOptions对象。 总结在第一个应用的基础上，只增加了非常简单的代码就完成了Vertx的配置工作。下篇文章我们一起来看看通过vertx-web开发一个提供静态页面和REST API的小应用，这个更加厉害，但是也是非常简单。 Happy coding &amp; Stay tuned ! 本人英语比较烂，建议看原文","categories":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}],"tags":[{"name":"Vert.x3","slug":"Vert-x3","permalink":"http://quanke.name/tags/Vert-x3/"},{"name":"Vertx","slug":"Vertx","permalink":"http://quanke.name/tags/Vertx/"}],"keywords":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}]},{"title":"我的第一个Vert.x 3 应用","slug":"vertx/我的第一个Vert-x-3-应用","date":"2016-01-12T11:44:56.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/27296/","link":"","permalink":"http://quanke.name/posts/27296/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 如果，你听到有人说Vert.x 是牛逼的。非常好！但是你自己想要尝试的话，Ok great，那么下一个问题自然是“从哪里开始？”，这篇文章是一个很好的起点。文章展示了怎么构建一个非常简单的 vert.x 应用（这没什么大不了的），怎样测试和执行vert.x应用。 文章里提到的代码在github 。 开始首先，创建一个项目，在这篇文章中使用Apache Maven,当然你可以使用Gradle 或者其他工具，使用Maven jar archetype 创建结构，但基本上只需要一个目录。 src/main/java 目录 src/test/java 目录 pom.xml 文件 会得到一个像这样的结构 .├── pom.xml├── src│ ├── main│ │ └── java│ └── test│ └── java pom.xml 文件的内容如下： &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;name.quanke.study.vertx.first&lt;/groupId&gt; &lt;artifactId&gt;my-first-app&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-core&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 这个 pom.xml 文件非常简单： 声明了一个 vertx-core 依赖 配置了maven-compiler-plugin 插件（使用的是Java 8）. 第二点非常重要，Vert.x 只支持Java 8。 编码！OK，我们已经创建了一个pom.xml 文件，接下来正式开始编码，创建 src/main/java/name/quanke/study/vertx/first/MyFirstVerticle.java文件，内容如下： package name.quanke.study.vertx.first;import io.vertx.core.AbstractVerticle;import io.vertx.core.Future;public class MyFirstVerticle extends AbstractVerticle &#123; @Override public void start(Future&lt;Void&gt; fut) &#123; vertx .createHttpServer() .requestHandler(r -&gt; &#123; r.response().end(&quot;&lt;h1&gt;Hello from my first &quot; + &quot;Vert.x 3 application&lt;/h1&gt;&quot;); &#125;) .listen(8080, result -&gt; &#123; if (result.succeeded()) &#123; fut.complete(); &#125; else &#123; fut.fail(result.cause()); &#125; &#125;); &#125;&#125; 这个实际上不是最优秀的应用，这个类继承AbstractVerticle，在Vert.x的世界里verticle就是组件（是Vert.x的之行单元），通过继承AbstractVerticle类，获得vertx的入口。 当verticle部署后会调用start方法，我们也能实现 stop 方法，在这个方法里回收资源，start方法接收Future对象的参数，可以告诉用户是执行完成还是报出错误，Vert.x是异步执行的，运行的时候不会等到start方法执行完成，所以 Future 参数是非常重要的，可以通知是否已经执行完成。 在start方法里创建了一个HTTP 服务和一个请求处理器（handler），这个请求处理器使用lambda表达式，通过requestHandler方法，每次服务器收到请求，都会返回“Hello。。。”（也没有什么其他可以告诉你的东西了。。。），最后服务器绑定了一个8080端口，这里可能会失败（因为8080端口可能被使用了），通过lambda表达式检查是否连接成功，就想上面说的，调用fut.complete表示成功，调用 fut.fail 报告失败。 使用下面的命令尝试着编译应用（首先你要安装好了maven，此命令在pom.xml目录下执行，知道使用maven的都懂得）： mvn clean compile 如果幸运，编译应该是成功的。 应用就编写到这里，是不是很简单？ 测试应用开发完成了，但是我们从来都不是很认真的，所有我们需要测试一下，测试使用JUnit 和 vertx-unit。 打开pom.xml文件，增加两个依赖（dependencies）： &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-unit&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 创建 src/main/java/name/quanke/study/vertx/first/MyFirstVerticleTest.java 文件 package name.quanke.study.vertx.first;import io.vertx.core.Vertx;import io.vertx.ext.unit.Async;import io.vertx.ext.unit.TestContext;import io.vertx.ext.unit.junit.VertxUnitRunner;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;@RunWith(VertxUnitRunner.class)public class MyFirstVerticleTest &#123; private Vertx vertx; @Before public void setUp(TestContext context) &#123; vertx = Vertx.vertx(); vertx.deployVerticle(MyFirstVerticle.class.getName(), context.asyncAssertSuccess()); &#125; @After public void tearDown(TestContext context) &#123; vertx.close(context.asyncAssertSuccess()); &#125; @Test public void testMyApplication(TestContext context) &#123; final Async async = context.async(); vertx.createHttpClient().getNow(8080, &quot;localhost&quot;, &quot;/&quot;, response -&gt; &#123; response.handler(body -&gt; &#123; context.assertTrue(body.toString().contains(&quot;Hello&quot;)); async.complete(); &#125;); &#125;); &#125;&#125; 在这里使用JUnit测试verticle，也会使用到 vertx-unit 自定义的runner，vert.x-unit很容易测试异步的vert.x应用。 在setUp方法里，创建了一个Vertx实例，deploy了verticle ,你可能已经注意到了，这与传统JUnit的@Before不一样，它接收了一个TestContext参数，TestContext对象让我们可以控制异步的测试，例如：当我们deploy了异步verticle，多个Vertx实例相互作用时，不能检测它的正确性，deployVerticle方法的第二个参数返回一个handler：context.asyncAssertSuccess()，如果verticle的状态是失败，那这个测试就是失败的，此外会等待verticle完成启动，还记得，在verticle里，我们调用了fut.complete()方法，直到等到调用fut.complete()方法才返回状态。 tearDown方法比较简单，负责回收我们创建的vertx对象。 现在我们看一下测试应用的testMyApplication方法，给应用发出请求并且拦截一个返回，发出请求和接收答复都是异步的，我们需要一种方法来控制，setUp和tearDown方法接收一个TestContext对象，当这个测试完成的时候，通过我们这个对象创建的异步的处理器（async），通知测试框架（使用async.complete()） 像这样，一个异步处理器创建好了，我们使用getNow()方法（getNow()方法是get(...).end()的捷径），创建一个HTTP客户端和发一个HTTP请求给我们的应用，响应使用lambda处理，通过另一个lambda的handler方法接收一个response body，这个body参数是这个response body（如buffer对象），检测body是否等于“Hello”字符串，并且宣布测试完成（async.complete()）。 让我们花一个分钟的时间提一下这个断言，不像传统的使用context.assert...断言，如果断言失败，它会立即中断测试，因为Vert.x 程序各方面都是异步的,所以使用这种方式断言测试很重要。 可以使用IDE或者Maven运行测试： mvn clean test 打包总结一下，我们有了应用程序和测试，接下来，给应用打包，在这篇文章中我们把应用打 成fat jar包，一个 fat jar包是一个可以独立执行的jar文件，它包含所有的运行程序所需要的依赖，Vert.x使用这种打包的方式非常方便，仅仅只有一个文件，这使它非常容易执行。 创建一个 fat jar 便捷pom.xml文件，把下面的的代码增加到&lt;/plugins&gt;标签之前： &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;manifestEntries&gt; &lt;Main-Class&gt;io.vertx.core.Starter&lt;/Main-Class&gt; &lt;Main-Verticle&gt;name.quanke.study.vertx.first.MyFirstVerticle&lt;/Main-Verticle&gt; &lt;/manifestEntries&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;artifactSet/&gt; &lt;outputFile&gt;$&#123;project.build.directory&#125;/$&#123;project.artifactId&#125;-$&#123;project.version&#125;-fat.jar&lt;/outputFile&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 使用maven-shade-plugin 创建fat jar。在manifestEntries标签里声明我们的verticle，你也许不知道从哪里来的Starter类，实际上，它是在vertx实例化和部署verticle的时候就有创建。 这个插件的配置就是这样，我们执行： mvn clean package 应该会创建一个target/my-first-app-1.0-SNAPSHOT-fat.jar，里面嵌入了应用所有的依赖（包含vert.x自己）。 执行嗯，很高兴拥有一个 fal jar,但我们希望看到我们的应用程序的运行！正如上面所说，多亏了fat jar包装，运行vert.x应用程序是容易的： java -jar target/my-first-app-1.0-SNAPSHOT-fat.jar 然后，打开浏览器访问 http://localhost:8080。 CTRL+C停止应用运行。 总结这个Vert.x 3速成班告诉你，怎么使用Vert.x 3开发一个简单的应用，怎么测试、打包和运行，现在知道了在Vert.x 3 上任意创建令人惊奇的系统。接下来的时间看看怎么配置我们的应用。 Happy coding &amp; Stay tuned ! 本人英语比较烂，建议看原文","categories":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}],"tags":[{"name":"Vert.x3","slug":"Vert-x3","permalink":"http://quanke.name/tags/Vert-x3/"},{"name":"Vertx","slug":"Vertx","permalink":"http://quanke.name/tags/Vertx/"}],"keywords":[{"name":"Vert.x3 系列","slug":"vertx","permalink":"http://quanke.name/categories/vertx/"}]},{"title":"盗版windows7高速免费安装windows10","slug":"tools/盗版windows7高速免费安装windows10","date":"2015-08-04T02:03:13.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/1815/","link":"","permalink":"http://quanke.name/posts/1815/","excerpt":"","text":"欢迎关注http://quanke.name/ 转载请注明出处，谢谢 为了体验windows10，花了我一晚上的时间，让我放弃了健身，学习PMP，代价很大，其实安装很简单。 首先使用腾讯管家（360的也可以） 里的windows10硬件检测工具，检测电脑是否符合安装windows10的要求。如果是c盘不够，会建议你移动一些文件到其他盘，如果都通过后，一般会提示预约成功，但是我现在就想用，怎么办？直接windows7更新中心更新，如果更新成功了，那恭喜你，我的是盗版，没有提示更新错误，怎么办？ 这就是本文的重点了。 直接下载windows 10 安装（windows7的软件数据都在，不要担心） 百度盘下载链接: http://pan.baidu.com/s/1bnjnXBT 密码: 2r8r 下载完后解压，运行你应该就懂了吧，不懂留言吧 小技巧： 有时候使用百度网盘管家下载有点慢，把地址修改一下，把链接地址的disk修改为wap，其他的都不要改变，就可以使用迅雷下载了，不懂留言","categories":[{"name":"使用","slug":"use","permalink":"http://quanke.name/categories/use/"}],"tags":[{"name":"Windows10安装","slug":"windows-install","permalink":"http://quanke.name/tags/windows-install/"}],"keywords":[{"name":"使用","slug":"use","permalink":"http://quanke.name/categories/use/"}]},{"title":"MBaaS-LiveOak系列三：LiveOak官方实例-聊天","slug":"liveoak/MBaaS-LiveOak系列三：LiveOak官方实例-聊天","date":"2015-07-13T02:03:56.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/31883/","link":"","permalink":"http://quanke.name/posts/31883/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢","categories":[{"name":"MBaaS-LiveOak系列","slug":"MBaaS-LiveOak系列","permalink":"http://quanke.name/categories/MBaaS-LiveOak系列/"}],"tags":[{"name":"MBaaS","slug":"MBaaS","permalink":"http://quanke.name/tags/MBaaS/"},{"name":"LiveOak","slug":"LiveOak","permalink":"http://quanke.name/tags/LiveOak/"}],"keywords":[{"name":"MBaaS-LiveOak系列","slug":"MBaaS-LiveOak系列","permalink":"http://quanke.name/categories/MBaaS-LiveOak系列/"}]},{"title":"MBaaS-LiveOak系列二：LiveOak的安装和运行","slug":"liveoak/MBaaS-LiveOak系列二：LiveOak的安装和运行","date":"2015-07-11T08:41:49.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/44076/","link":"","permalink":"http://quanke.name/posts/44076/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 LiveOak是Java开发，所以前提是需要有Java运行环境，Java运行环境自己百度安装，不会装Java环境的看这个还是困难的，LiveOak要求的Java环境是Java 8 下面命令是查看你的Java版本 java -version 下载地址： http://liveoak.io/downloads. 首先下载解压后执行下面的命令（$LIVEOAK_HOME是LiveOak的目录）： $LIVEOAK_HOME/bin/standalone.sh -b 0.0.0.0 之后会自动下载MongoDB 最后访问 http://localhost:8080/admin ，用户名和密码是admin LiveOak支持安装在OpenShift上 LiveOak 在OpenShift 市场上的地址https://marketplace.openshift.com/apps/10363 用户名和密码都是admin 安装LiveOak 的Docker容器 首先从Docker容器 pull下来，安装 docker pull jboss/liveoak-server 启动 docker run -it -p 8080:8080 -p 9090:9090 jboss/liveoak-server 想要在docker上用好，建议系统学习docker 如果用的是Mac系统，kitematic（https://docs.docker.com/kitematic/）可以非常简单的使用docker，在kitematic里搜索LiveOak ，安装就可以使用了，非常简单 运行效果 有问题请多多指教","categories":[{"name":"MBaaS-LiveOak系列","slug":"MBaaS-LiveOak系列","permalink":"http://quanke.name/categories/MBaaS-LiveOak系列/"}],"tags":[{"name":"MBaaS","slug":"MBaaS","permalink":"http://quanke.name/tags/MBaaS/"},{"name":"LiveOak","slug":"LiveOak","permalink":"http://quanke.name/tags/LiveOak/"}],"keywords":[{"name":"MBaaS-LiveOak系列","slug":"MBaaS-LiveOak系列","permalink":"http://quanke.name/categories/MBaaS-LiveOak系列/"}]},{"title":"MBaaS-LiveOak系列一:LiveOak简介","slug":"liveoak/MBaaS-LiveOak系列一-LiveOak简介","date":"2015-07-10T15:35:21.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/55796/","link":"","permalink":"http://quanke.name/posts/55796/","excerpt":"","text":"欢迎关注http://quanke.name/ 交流群：231419585 转载请注明出处，谢谢 LiveOak 是一个来自红帽的全开源的 MBaaS 解决方案。MBaaS 通过提供关键的后端服务来加速移动应用的开发。 官网原话 The Open Source Mobile Services Platform 开源移动服务平台 现在国内的MBaaS服务商有不少，比如APPCan、Bmob、 Uncode（国内开源）、苹果的CloudKit和现在大红大紫的重新定义移动应用开发的APICloud，都属于MBaaS。 那什么是MBaaS呢？ http://mobile.51cto.com/news-464546.htm LiveOak提供什么功能？ 提供数据存储、账户管理、安全授权（SSO）、推送（但是这个推送是使用Google的，国内用户要哭，我计划写一个支持国内推送的插件，欢迎关注quanke.name）、客户端管理（比较弱）、业务逻辑使用js写，可以在线编辑业务逻辑、统计等功能，提供Android、iOS、js的SDK，很容易集成到自己的程序里，现在还是1.0版本，功能比较弱。 LiveOak是jboss系列的，支持jboss插件化开发，扩展非常简单，之后的文章里会一一讲到 LiveOak的官网 http://liveoak.io LiveOak源码地址 https://github.com/liveoak-io/liveoak/","categories":[{"name":"MBaaS-LiveOak系列","slug":"MBaaS-LiveOak系列","permalink":"http://quanke.name/categories/MBaaS-LiveOak系列/"}],"tags":[{"name":"MBaaS","slug":"MBaaS","permalink":"http://quanke.name/tags/MBaaS/"},{"name":"LiveOak","slug":"LiveOak","permalink":"http://quanke.name/tags/LiveOak/"}],"keywords":[{"name":"MBaaS-LiveOak系列","slug":"MBaaS-LiveOak系列","permalink":"http://quanke.name/categories/MBaaS-LiveOak系列/"}]},{"title":"android开发总结和注意事项","slug":"android/android-development-summary-and-matters-needing-attention","date":"2015-05-09T01:03:33.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/4539/","link":"","permalink":"http://quanke.name/posts/4539/","excerpt":"","text":"做好详细设计 功能设计 数据结构设计 统一的异常处理 统一的网络请求发送 统一的命名 所有的耗时操作不能在ui线程里处理，比如数据库操作 统一配置文件 统一定义常量 统一注释 书写方法要求 书写类要求 写通用工具 统一日志打印 需要统一处理调试模式和正式发布（） 百度key不同 日志打印不同 api地址不同 统一线程处理 集成分享平台sdk，自己实现 ui方面找出相同的地方，写出样式，写出公共布局 信息修改统一通知其他界面（把详细设计写好），主要处理返回数据，点击进入需要重新从本地加载数据 怎么做详细设计 一定要细看需求，理解需求（怎么快速理解需求） 不管是谁，完整的看完需求 找到相同点和不同点 找到关联性 找出不合逻辑的需求 储备技术 图片处理 图片滤镜 图片压缩 文件后台断点上传 群功能 怎么沟通？ 在软件开发过程中，可能需要和负责不同工作的人沟通，可以很多人会向你反馈问题，需要怎么解决 相关人员找你你沟通时，首先需要判断问题的重要性，如果自己可以解决自己解决，不能解决的，向负责人反应 你找相关人员沟通时，首先需要判断问题是谁的，一定要尽量排除自己的问题，再去找人沟通，沟通时需要想好，不要耽误别人时间 软件开发流程 写项目的时候不比写demo，写demo可能就是一个人写，写了有bug也没有关系，但是项目就不同了，项目不能出现过多bug，需要多人合作开发！ 接任务 分析任务：如果不理解和自己不能胜任，一定要和负责人说，这关系到整个项目进度 详细设计：把命名想好…… 开始编码 反复测试 提交任务 习惯 做笔记，屡逻辑 随便写的有点乱，有时间继续补充","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"资料","slug":"data","permalink":"http://quanke.name/tags/data/"},{"name":"总结","slug":"conclusion","permalink":"http://quanke.name/tags/conclusion/"},{"name":"注意","slug":"careful","permalink":"http://quanke.name/tags/careful/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"值得学习的一些开源项目和资料","slug":"other/open-souce-and-data","date":"2015-05-07T14:37:48.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/29951/","link":"","permalink":"http://quanke.name/posts/29951/","excerpt":"","text":"https://github.com/github/android github的android开源项目 https://github.com/owncloud/android 一个私有云项目，里面涉及同步相关的东西 https://github.com/aporter/coursera-android/tree/master/Examples Coursera是免费大型公开在线课程项目（https://www.coursera.org/） https://github.com/commonsguy/cw-android 一本书的源码，适合android初学者研究 https://github.com/novoda/android-demos android demo 适合新手研究 http://www.trinea.cn/ 国人整理的一些工具，可以研究研究源码 https://github.com/zxing/zxing ZXing 二维码扫描工具，现在市面上很多应用的二维码扫描功能都是从这个修改而来，需要好好研究 https://github.com/chrisbanes/photup photup 编辑机批量上传照片到facebook上，值得研究 https://github.com/codinguser/gnucash-android 四次元-新浪微博客户端 https://github.com/eluleci/FlatUI FlatUI实现主题定制，扁平化UI效果，可以轻松实现主体切换. https://github.com/ikocijan/MagicViews MagicViews实现控件使用自定义字体，只需要在xml上设置字体 http://androidkickstartr.com/ 生成android项目 https://github.com/daimajia/AndroidViewAnimations 实现了很多动画 http://easysoft.github.io/zui/ http://www.tinygroup.org 这是一个国人写的跨平台ui框架 http://www.amsoft.cn/ andbase源码： 国人写的一个框架包含很多工具类，基本的android技术都能在这里找到 https://github.com/Trinea/android-open-project Android开源项目分类汇总 ，非常全面的GitHub开源项目汇总，不需要重复发明轮子，尽情遨游在开源世界里吧 http://www.23code.com 整理了很多开源项目 google demo https://github.com/googlesamples http://yeasy.gitbooks.io/docker_practice/ docker 开源书籍 https://github.com/sd6352051/NiftyNotification 一个不错的通知ui http://coolgithubprojects.com/ github 项目排名 https://github.com/gcacace/android-signaturepad 一个签名的项目 https://github.com/bayandin/awesome-awesomeness 国外的开源书籍 https://android-arsenal.com 国外整理的开源项目 http://www.ddpush.net 推送解决方案 https://github.com/Trinea/android-open-project Android开源项目分类汇总 带进度显示的Button 项目地址：https://github.com/dmytrodanylyk/circular-progress-button https://github.com/mikepenz/Android-LollipopShowcase 一个悬浮按钮 https://github.com/traex/RippleEffect https://github.com/siriscac/RippleView点击有扩散效果的ui https://github.com/google/material-design-icons https://github.com/baoyongzhang/SwipeMenuListView 滑动删除 https://github.com/JakeWharton/DiskLruCache 大牛写的缓存框架 https://github.com/atermenji/IconicDroid 大量矢量图标，怎么放大也不变形 https://github.com/ksky521/nodePPT 网页ppt http://www.ui.cn/Material/ 免费编程书籍 http://siberiawolf.com/free_programming/index.html android周报（内容很nice）http://www.androidweekly.cn http://square.github.io/ https://github.com/r0adkll/Slidr滑动关闭 http://blog.csdn.net/qiujuer/article/details/42471119（打造极致Material Design动画风格Button） https://github.com/JakeWharton/Telecine（屏幕录制软件） https://github.com/Raizlabs/Singleton （一个非常简洁的库，可以帮助你方便将一个对象存储在磁盘。） http://blog.csdn.net/lovelion 刘伟老师的博客 https://github.com/inaka/galgo (可以把日志打印在屏幕的工具) http://www.imooc.com AndroidSigning (https://github.com/dodocat/AndroidSigning) AndroidSigning是一个可以方便你配置和管理Android签名信息的Gradle插件，使用本插件可以让所有的开发机以及持续交付设备使用完全相同的代码进行工作.避免陷入本地配置兼容性的泥淖中, 防止私密信息泄露. http://www.devtf.cn https://github.com/bboyfeiyu/android-tech-frontier https://github.com/cjwirth/awesome-ios-ui https://github.com/Aufree/trip-to-iOS/blob/master/Top-100.md http://chuansong.me/account/awesomeport 微信推送一些技术资料 https://github.com/wasabeef/richeditor-android https://fossdroid.com android开源项目 随便写的有点乱，有时间继续补充","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"资料","slug":"data","permalink":"http://quanke.name/tags/data/"},{"name":"开源","slug":"opensouce","permalink":"http://quanke.name/tags/opensouce/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"iOS 开发工程师自学计划","slug":"ios/ios-development-self-study-program","date":"2015-04-08T14:44:19.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/41208/","link":"","permalink":"http://quanke.name/posts/41208/","excerpt":"","text":"预备 1、文件管理器 Finder2、iWork 使用 Numbers,Keynote,Pages3、Safari 浏览器 Mac Os 的使用，iWork 的使用 iOS 开发基础 1、Xcode、SVN、Git2、C 语言是 iOS 开发的入门基础 语言，本部分主要介绍 C语言 的基本语法，程序结构，以 及指针的各种操作。为接下 来 Objective-C 语言的学习打下基础。 1、iOS 开发的系统环境介绍、 Xcode 集成开发环境详解、常用软件的介绍2、数据类型、常量和变量、运算符、赋值语句和表达式；分支、循环3、函数，数组（一维数组、二维数组、多维数组） ，结构体4、指针数组、数组指针，结构体指针5、指向指针的指针，宏定义、枚举，const，static Objective-C 是 iOS 与 Mac OS 开发的主要语言， 它是对 C 语言的扩展，并融入了面向对 象的特点。包含封装、继 承、多态三大特性， 本部分 主要介绍 OC 的基本语法， 新 的特性，内存管理等内容 1、面向对象 （OOP） 和面向过程、 类 （Class）和对象（Object） 、类的定义2、创建对象、self 和 super 关键字、属性以及点语法 （nonatomic， assign、 retain 、 copy，readonly、readwrite）3、便利构造器、单例（Singleton）4、堆栈、内存管理（ alloc、copy、retain ，release、autorelease， strong、weak）5、键值编码 （KVC） 、 键值监听 （KVO） 、 通知中 心 （ NSNotificationCenter ）、 通 知（NSNotification）6、类目（Category） 、延展（Extention） 、协议（protocol） iOS 的基础框架，包含了 iOS 开发的基本数据类型，在 iOSSDK 中几乎全部 NS 开头的类都 属于这个框架，我们将详细介绍开发中常用的类。 1、字符串（ NSString NSMutableString) 、数值对象(NSNumber NSValue)2 、数组（ NSArray,NSMutableArray ） 、字典(NSDictionary,NSMutableDictionary) 、 集 合(NSSet,NSMutableSet) 、快速 枚举 (for…in)NSIndexPath3 、日 期 与 时 间 (NSDate) 、 日 期 格 式(NSDataFormatter)、日历 (NSCalendar)、定时器(NSTimer)4 、文 件 管 理 (NSFileManager) 、 程 序 包(NSBundle)、缓冲区(NSData)5 、网络连接 (NSURLConnection) 、网络地址(NSURL)、网络请求 (NSURLRequest)、请求回应(NSResponse)、错误信息处理(NSError)6 、MVC 编程,简单控件一:标签(UILabel)、文本输入(UITextField)、 按钮 (UIButton)、 提示框(UIAlertView、UIActionSheet)、7、使用面向对象 OOP 方法, 实施计算机 APP应用. 要求学员应用前期学习中的大部 分知识点.8、沙箱 iOS 开发高级 UIKit 处于 Cocoa 四层结构的 最上层 CocoaTouch 层， 是 iOS开发中的控件框架， 定义了 几乎全部可视化控件， 在 iOS 开发中占据绝对地位，我们 不仅会学习各个控件的用 法，而且会讲述各个控件在 不同版本系统里的样式，教 大家如何自定义控件样式。 学完他们我们就可以做自己 个性化的界面了。1、窗口(UIWindow)、视图(UIView)、应用程序(UIApplication)2 、绘图（ drawRect ） 、 QuartzCoreDemo 、CGContextRef3 、触摸 (UITouch) 、事件 (UIEvent) 、手势(UIGestureRecognizer)、 UIResponder、 消息传递、响应者链4、 UIView 以及 CALayer 动画 （CAAnimation、CABasicAnimation、 CAKeyFrameAnimation）5、活动提示(UIActivityIndicatorView)、图像(UIImageView)6、 控件二:滚动视图(UIScrollView)、 页控制器(UIPageControl) 、 开关 (UISwitch) 、 单选(UISegmentControl)、滑块(UISlider)7、控件三:多行文本(UITextView)、网页视图(UIWebView)、滚轮 (UIPickerView)、日期滚轮 (UIDatePickerView) 、 表 格 视 图(UITableView)、 表格项(UITableViewCell)8、视图控制器(UIViewController)、导航控制器 (UINavigationController) 、 标 签 控制 器(UITabBarController) 、 表 格 控 制 器(UITableViewController) 、 相 册 控 制 器(UIImagePickerController) iphone Safari 浏览器原型 App。1、结合前期所学知识，应用 UIKit 框架详解中所学的高级 UI 控件及知识点，模拟 实现Safari 浏览器 iOS 应用特性框架是对上述两 个框架之外其他框架的统 称。主要内容为：音 频、视频的播放、照相机的 使用、加速计的应用，地图 框架的使用、短信、邮件的 应用等等，而且也会介绍当 前应用开发中使用非常广泛 的开源框架，同时还将讲解 开发者帐号的注册、真机调 试、以及程序上传。1 、音 频 播放 (AVAudioPlayer) 、 视 频 播放(MPMoviePlayerViewController) 以 及 播 放ipod 音乐2、 照相机(UIImagePickerController)以及相册的使用3 、短 信(MFMessageComposeViewController) 、 邮件(MFMailComposeViewController)的使用4、加速计(UIAccelerometer)的使用、帐号注册、真机调试、上传程序5 、地图(MKMapView) 的使用以及定位 (CoreLocation)6、数据持久化（文件读写、sqlite 数据库、 归档、NSCoding 协议） 、云存储 （iCloud）7、多线程开发（NSThread、NSLock）,操作队列(NSOperationQueue)8、网络请求（GET、POST） 、xml 解析、json解析、Socket 编程 iOS 游戏开发 2D 游戏引擎的使用, 全部课程 内容以”植物大战僵尸”为例,贯穿其中 1 、 Cocos2D HelloWorld,CCDirector( 导 演类),CCScene(场景类),CCLayer2、CCSprite(精灵类),CCAction(动作)3、CCMemu(菜单),CCLabelTTF(标签)4、CCPointParticleSystem(点粒子系统)5、练习:植物大战僵尸游戏开发 C++是目前最流行的开发语言 之一,C++基本语法,C++面象对像的特性.在 XCode 下如何 使用 C++语言编程. 1、在 Xcode 下编译 C++ 程序,C++ 类 Class,成员变量,成员函数,对象的创建2、构造函数与析构函数,new delete 关键字,内存管理3、继承,函数重载,操作符重载,拷贝构造4、模版 template 与泛型5、Objective-C 与 C++混合编程 iOS 游戏开发中使用最多的物 理引擎,以愤怒的小鸟为例学习 Box2D 开发. 1、物理世界(b2World),刚体(b2Body),精灵与刚体连接2、碰撞测试(b2ContactListener)3、刚体的连接关节(b2Joint)4、练习:愤怒的小鸟开发5、OpenGL ES 开发基础 项目实训 做一个真 实项目，可以整理成教程发到博客，然后开源 从需求分析开始，然后技术调研，工期评 估、编码、测试、优化代 码、上传程序等 项目内容会包括几点: 1.网络数据解析 2.音视频播放3.微薄分享 4.LBS 定位应用 5.SQLite 数据库 项目会用到网络、数据库、各种常用控件、 以及各种 Foundation 类。 目前有 很多项目可以选择使用，比如：互动百科（新闻类应用） 、乐视 （电影类应 用） 、 创业邦 （杂志类应用） 、尚品网 （购物类应用） 、 雅座空间 （团购类 应用） 、 找地（定位类应用） 、 我是学家（教育类应用） 、 YY 客户端 （语 音类应用） 、麦咨达（条码扫描类应用） 、 中国建行 （银行类应用） 、CuteMath（游戏类应用） 、车震摇摇乐（娱乐类应用） 、新浪微博（微博类 应用）等等 支持聊天功能的相册应用 - 微相册 实现功能 主要是照片的展示，播放照片时播放音乐，音乐照片来自互联网分享照片到各大社交平台支持开放平台登录支持滑动出菜单TableView动画下拉刷新反馈建议关于 扩展功能","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://quanke.name/tags/ios/"}],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"sublime text 2快捷键大全","slug":"tools/sublime-text-2-shortcut key","date":"2014-11-29T19:53:51.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/36179/","link":"","permalink":"http://quanke.name/posts/36179/","excerpt":"","text":"Ctrl+L 选择整行（按住-继续选择下行） Ctrl+KK 从光标处删除至行尾 Ctrl+Shift+K 删除整行 Ctrl+Shift+D 复制光标所在整行，插入在该行之前 Ctrl+J 合并行（已选择需要合并的多行时） Ctrl+KU 改为大写 Ctrl+KL 改为小写 Ctrl+D 选词 （按住-继续选择下个相同的字符串） Ctrl+M 光标移动至括号内开始或结束的位置 Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号） Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果） Ctrl+Shift+/ 注释已选择内容 Ctrl+Space 自动完成（win与系统快捷键冲突，需修改） Ctrl+Z 撤销 Ctrl+Y 恢复撤销 Ctrl+Shift+V 粘贴并自动缩进（其它兄弟写的，实测win系统自动缩进无效） Ctrl+M 光标跳至对应的括号 Alt+. 闭合当前标签 Ctrl+Shift+A 选择光标位置父标签对儿 Ctrl+Shift+[ 折叠代码 Ctrl+Shift+] 展开代码 Ctrl+KT 折叠属性 Ctrl+K0 展开所有 Ctrl+U 软撤销 Ctrl+T 词互换 Tab 缩进 Shift+Tab 去除缩进 Ctrl+Shift+UP 与上行互换 Ctrl+Shift+DOWN 与下行互换 Ctrl+K Backspace 从光标处删除至行首 Ctrl+Enter 插入行后 Ctrl+Shift Enter 插入行前 F9 行排序（按a-z）","categories":[{"name":"使用","slug":"use","permalink":"http://quanke.name/categories/use/"}],"tags":[],"keywords":[{"name":"使用","slug":"use","permalink":"http://quanke.name/categories/use/"}]},{"title":"android中textview字数过长解决方法","slug":"android/android-textview-word-too-long","date":"2014-11-02T17:28:56.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/29552/","link":"","permalink":"http://quanke.name/posts/29552/","excerpt":"","text":"为了解决textview中内容过长的话自动换行，但是调用measureText函数时发现返回值很不准确，单位也不确定，是pixel还是dip，都不准。后来想起textview中有个内容过长加省略号的属性，即ellipsize，可以解决这个问题，用法如下：在xml中[code lang=”xml”]android:ellipsize = &quot;end&quot; 省略号在结尾android:ellipsize = &quot;start&quot; 省略号在开头android:ellipsize = &quot;middle&quot; 省略号在中间android:ellipsize = &quot;marquee&quot; 跑马灯[/code]最好加一个约束android:singleline = “true” 当然也可以用代码语句[code lang=”java”]tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;END&quot;));tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;START&quot;));tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;MIDDLE&quot;));tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;MARQUEE&quot;));[/code]最好再加一个约束tv.setSingleLine(true);不仅对于textview有此属性，对于editext也有，不过它不支持marquee","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android中如何修改系统时间（应用程序获得系统权限）","slug":"android/android-change-system","date":"2014-06-21T18:10:43.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/7298/","link":"","permalink":"http://quanke.name/posts/7298/","excerpt":"","text":"在 android 的API中有提供 SystemClock.setCurrentTimeMillis()函数来修改系统时间，可惜无论你怎么调用这个函数都是没用的，无论模拟器还是真机，在logcat中总会得到”Unable to open alarm driver: Permission denied “.这个函数需要root权限或者运行与系统进程中才可以用。 本来以为就没有办法在应用程序这一层改系统时间了，后来在网上搜了好久，知道这个目的还是可以达到的。 第一个方法简单点，不过需要在Android系统源码的环境下用make来编译： 1\\. 在应用程序的AndroidManifest.xml中的manifest节点中加入android:sharedUserId=&quot;android.uid.system&quot;这个属性。 2\\. 修改Android.mk文件，加入LOCAL_CERTIFICATE := platform这一行 3\\. 使用mm命令来编译，生成的apk就有修改系统时间的权限了。 第二个方法麻烦点，不过不用开虚拟机跑到源码环境下用make来编译： 1\\. 同上，加入android:sharedUserId=&quot;android.uid.system&quot;这个属性。 2\\. 使用eclipse编译出apk文件，但是这个apk文件是不能用的。 3\\. 用压缩软件打开apk文件，删掉META-INF目录下的CERT.SF和CERT.RSA两个文件。 4\\. 使用目标系统的platform密钥来重新给apk文件签名。这步比较麻烦，首先找到密钥文件，在我的Android源码目录中的位置是&quot;build/target/product/security&quot;，下面的platform.pk8和platform.x509.pem两个文件。然后用Android提供的Signapk工具来签名，signapk的源代码是在&quot;build/tools/signapk&quot;下，用法为&quot;signapk platform.x509.pem platform.pk8 input.apk output.apk&quot;，文件名最好使用绝对路径防止找不到，也可以修改源代码直接使用。 这样最后得到的apk和第一个方法是一样的。 最后解释一下原理，首先加入android:sharedUserId=&quot;android.uid.system&quot;这个属性。通过Shared User id,拥有同一个User id的多个APK可以配置成运行在同一个进程中。那么把程序的UID配成android.uid.system，也就是要让程序运行在系统进程中，这样就有权限来修改系统时间了。 只是加入UID还不够，如果这时候安装APK的话发现无法安装，提示签名不符，原因是程序想要运行在系统进程中还要有目标系统的platform key，就是上面第二个方法提到的platform.pk8和platform.x509.pem两个文件。用这两个key签名后apk才真正可以放入系统进程中。第一个方法中加入LOCAL_CERTIFICATE := platform其实就是用这两个key来签名。 这也有一个问题，就是这样生成的程序只有在原始的Android系统或者是自己编译的系统中才可以用，因为这样的系统才可以拿到platform.pk8和platform.x509.pem两个文件。要是别家公司做的Android上连安装都安装不了。试试原始的Android中的key来签名，程序在模拟器上运行OK，不过放到G3上安装直接提示&quot;Package ... has no signatures that match those in shared user android.uid.system&quot;，这样也是保护了系统的安全。 最最后还说下，这个android:sharedUserId属性不只可以把apk放到系统进程中，也可以配置多个APK运行在一个进程中，这样可以共享数据，应该会很有用的。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"用wifi连接电脑查看logcat的方法","slug":"other/e7-94-a8wifi-e8-bf-9e-e6-8e-a5-e7-94-b5-e8-84-91-e6-9f-a5-e7-9c-8blogcat-e7-9a-84-e6-96-b9-e6-b3-95","date":"2014-02-25T00:21:20.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/32783/","link":"","permalink":"http://quanke.name/posts/32783/","excerpt":"","text":"通过wifi将Android设备连接到电脑。从SDK 的 platform-tools 目录，在命令行输入adb tcpip 5555输入：adb connect &lt;设备的IP地址&gt;:5555 ，你现在将被连接到Android设备并能像adb logcat一样发出通用的adb命令。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"数据存储方式分析","slug":"other/e6-95-b0-e6-8d-ae-e5-ad-98-e5-82-a8-e6-96-b9-e5-bc-8f-e5-88-86-e6-9e-90","date":"2013-01-25T22:56:07.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/3455/","link":"","permalink":"http://quanke.name/posts/3455/","excerpt":"","text":"游戏中总是有很多相关的数据需要存储,比如编辑器产生的关卡数据,人物,物品属性的配置等等,并且现在已经不是每人都设计一种自己数据格式的时代了.程序员们是越来越懒,大家都想着一套文件格式,一套解析,处理代码能够通吃所有的程序.以下讨论,包括优缺点,都仅仅是对于游戏数据(还仅指编辑的数据)存储而言,以下都省略此前提背景,其他领域的使用本文仅供参考,游戏领域的使用本文也仅是一家之言,当然也仅供参考.首先,看看传统的数据存储解决方案. 传统数据存储解决方案EXCEL方案最大的优点是几乎人人都会更改并且可以更改而不用进一步的学习.干这行的,别说策划,即使是文秘应该起码也会EXCEL吧?缺点,需要自己写一大堆的Excel解析代码,这点是无奈的.并且,假如不想每个Excel文件都写一套解析代码的话,你就要想好一种通用,并且扩展性良好的Excel编写格式,这也不是太容易的.即使设计的Excel格式扩展性足够好,当数据慢慢复杂的时候,你会发现,事情越来越复杂…..几乎就开始将Excel做关联数据库使用了.有的时候,通过改动一些关联性很强的Excel数据来完成某个功能,甚至比你通过代码改变来实现还要复杂…..到那个时候,你才会发现,Excel已经不敷使用.最最重要的是,Excel(起码03版的是这样)是二进制数据,SVN,mercurial等版本控制工具(偏偏这就是大家项目中所用的吧)不支持merge,这样,每次多人更改,必然导致冲突,然后,手工再去痛苦的重写吧.但是,假如你碰到像我们公司说的这种,翻译组只懂使用Excel,那么你再痛苦,也就无奈去吧.这也是Excel的优点吧……..当然,从程序的角度来看,那是最大的缺点. 数据库方案数据库方案最大的优点是扩展性异常强大,数据库方案的扩展性几乎是无限的,无论多么庞大的数据量,放在数据库中总是不会显得很多,关联表格也总是能将冗余数据降到最低,并且,如此的清晰.由于现代数据库前端做的越来越好,修改数据库中的数据也不总是需要SQL语句了.最最重要的是,当你需要的时候,你还是能用SQL语句来实现你需要的最最复杂的查询,或者批量修改某些相关的数据.当然了,没有方案是完美的,用数据库方案,的确强大,但是也有强大的代价,首先,项目中得有数据库专家,能够设计足够好的表格,及写出复杂的多重嵌套SELECT语句,项目中得有人懂得使用各自语言自己的数据库接口API,并且比较郁闷的是,各种数据库的API设计还不太一样……通用的API设计往往是以低效率为代价的….当然,这些都扯远了,扯上了原来做服务器的经验了……..假如仅仅将数据库作为普通游戏数据存储的方式,缺点还没有那么夸张,并且,我们总是可以使用mySQL,SQLLite这样的开源解决方案.在各类语言中也总是有可用的相应的API可用.除了上面那些,还有个问题,即使仅仅将数据库作为普通游戏数据存储的方式,为每个需求设计一套表,写一堆的从数据库中获取数据的代码,并且,最要要是以二进制数据发布的话,你还得写一套从数据库中读数据,然后序列化成二进制数据的代码,然后,额外的,解析二进制的代码也不可少.强大的数据库解决是以庞大的人工代码量堆积起来的. 现代数据存储解决方案因为传统解决方案有着其天生的缺点,Excel对于越来越大的游戏,越来越多的游戏数据有些吃力,而是用数据库方案对于光是保存游戏数据(仅指编辑数据,不包括网游的运行时数据)又显得太过臃肿.那我们有没有更好的方法呢?先看看我们想要什么样的方案:1.有着文本存储的方式,便于开发期调试和修改,也能直观的查看到改变和开发期的版本控制merge.2.有二进制存储方式,在发布后可以使用这样的方式,减少parse时间,并且,从文本方式切换到二进制方式是有很简单解决方案的.3.parse,序列化的代码编写要足够的简单,起码不会随着数据量的扩大而扩大到难以掌握的地步.4.多语言支持,你总能在你喜欢的语言中使用5.在数据之间建立关联,嵌套关系要足够的简单,这样才能简单的表示丰富的内容,而不是通过另外再建一套数据来表示关联(就像在Excel中需要做的那样) 有方案能满足上面所有的需求吗?可以寻找一下.因为我能力有限,这里仅举较为常用的XML,JSON,Google Protobuf为例,作为比较,也作为自己选择最佳方式的参考.(在查找资料的过程过还发现了一个名叫Thrift的解决方案,有文章 的比较指出其比Google Protobuf要强大较多,因为使用较少,我不准备尝试,在此提供此信息,仅供参考) XML方案现在游戏数据中XML方案应用的应该算是非常广泛了,几乎算是事实上的工业标准?起码我的感受是这样,甚至于,Office 2007以后的通用格式都是XML化的了.是因为网页开发的太过流行,导致大家都喜欢上了尖括号横生的标记语言了吗?我不知道.但是,XML的确有其优点.在WIKI百科上,有这么一段描述:As of 2009[update] , hundreds of XML-based languages have been developed,[5] including RSS , Atom , SOAP , and XHTML . XML-based formats have become the default for most office-productivity tools, including Microsoft Office (Office Open XML ), OpenOffice.org(OpenDocument ), and Apple ‘s iWork .[6] 看看吧,应用的还真不少.首先,上述5点需求的需求1,3,4,5是较为完美的满足的.XML是写给人看的数据存储格式,虽然喜欢尖括号的人(比如我)会反感,并且因为其流行,解析XML的库也是非常丰富,各类语言对XML的支持肯定少不了,XML对于嵌套,关联的支持也是非常好的,其自描述性,能让你看到XML就能知道,它在描述什么.XML的处理都是字符串,支持unicode, wikipedia上还提供了一个有意思的例子:version =”1.0” encoding =”UTF-8” ?&gt;&lt;烏語&gt; Китайська мова&gt;中国人写的?-_-!当然,实际中,除了字符串可能会用上中文外,一般的tag我们还是习惯用英文.另外,有一点也很重要,XML是可扩展的,添加新的XML属性完全不影响原有的解析及代码的运行,直到你真的需要这个属性,然后再添加处理代码即可.但是,XML有个致命的缺点,一堆类似HTML的标记,根本就不是设计给人来写的,(当然,好用的工具另外),在阅读的时候,很显然,废数据也过多,那么,存储,传输的时候,(假如传输的真是文本的话)同样的,信噪比太低,这点我不是太喜欢.当然,最主要的是直接写XML比较麻烦.也许有强大的工具能解决此问题,但是鉴于我们公司的制度,那可能是可望而不可及的事情. JSON 方案上述5点需求的需求1,3,4,5可以得到比XML更完美的满足.得益于简单的格式,所以解析及创建都可以做的很简单的,特别是JSONCPP这个库,在使用的时候简直就像获取到JS中的Object一样,直接通过[]操作完成索引及建立操作,使用起来感觉非常爽,并且,也有XML有的可扩展性,相对来说,比起以前使用LUA做配置而言,JSON会更加简单,当然,功能也稍微弱一些,不用逻辑处理(到脚本层次)的时候,我个人认为JSON就是最合适的数据存储格式.当然,从数据处理的速度来说,可能还需要一个从JSON到二进制的转换工具,(XML也有类似问题),然后在发布期完全使用二进制.目前有点问题的就是,JSON的格式没有XML那么规范,所以常常会容易写错,然后自己还没有感觉,JSONCPP使用了MAP的特性,也就是说,使用方便,但是当[]查找不到的时候,是默认建立了空的索引,这会带来一些混乱…..在我们的项目中,使用JSON来配置界面,为UI的灵活性提供了很大的方便,并因此节省了无数代码及编译时间,此时我想起一句LUA之父说的话,只有当配置足够灵活,人们才会使用它,的确如此,当JSON的使用如此方便的时候,使用配置,而不是代码,那是享受,而不是痛苦. 另外,XML与JSON方案还有个好处,因为他们的通用性,各个项目之间的沟通也会更加简单,与人解释XML,JSON在干什么,比与人解释自己的二进制文 件在干什么要简单的多.也因为沟通更加简单,使得在通用格式上面的那一层代码也能得到更多的复用机会.甚至,我们考虑过使用其他项目中创造的用JSON实现的关键帧动画……… Google Protobuf 方案用的不多,试用了一下,谈下感想,Google在说明文档中说Google内部使用时,所有的进程间他通行,一律要求使用Google Protobuf,也可见其自有其强大之处.使用方式上与上述两个方案有比较大的不同,XML与JSON仅仅是描述数据,单纯的数据,解析的代码还是需要自己去写(尽管JSON的解析已经非常简单了)但是Google Protobuf不同,其要我们编写的是结构描述文档,并且通过其附带的工具,直接生成C++,JAVA,Python的代码(也就是Google内部使用的3语言,与我们公司完全一致),至此,不仅解析简单了,甚至结构都有了,我们需要做的是直接调用结构的接口去完成输入输出,所有的数据的getter都通过Google规定的方式进行了命名.甚至,直接将结构打包成2进制数据然后发送了.(也就是Google在文档中所描述的进程间通信).比起XML,JSon而言,此方案最大的优势在于速度,它有很好的文本格式以及二进制格式,可以很方便的切换(原生就支持),这也是3个方案中唯一满足了需求2的方案.(事实上,完全满足上述所有需求)但是,很明显的,有个缺点,(实在是没有实际使用,仅仅是通过试用感觉的),假如结构变换的话,可能得重新使用Google提供的工具,重新生成结构,这就需要重新编译代码,这是个较大的问题……………..其他的,个人感觉,Google Protobuf是非常不错的解决方案,特别是用在需要进程间通信时(比如需要进行网络通信,连打包的代码都省了). 最后的总结是,未来的趋势应该是JSON 方案吧,Google Protobuf 方案更适合需要网络通信的情况,毕竟还需要通过工具生成代码,使用的方便性来说不如JSON.","categories":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}],"tags":[],"keywords":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}]},{"title":"Sublime Text 2 for Linux 的安装、教程及问题汇总","slug":"tools/sublime-text-2-for-linux-e7-9a-84-e5-ae-89-e8-a3-85-e3-80-81-e6-95-99-e7-a8-8b-e5-8f-8a-e9-97-ae-e9-a2-98-e6-b1-87-e6-80-bb","date":"2012-12-22T06:15:17.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/29401/","link":"","permalink":"http://quanke.name/posts/29401/","excerpt":"","text":"Sublime Text 2是一款跨平台文本编辑器，支持Windows，Linux，Mac os 自从用上了Sublime Text 2这款文本编辑器后就爱不释手了，美观、大方、简介的界面，方便的操作和丰富的扩展造就了这么一款出色的文本编辑器。 开始我只在Windows系统安装使用，因为某些原因，今天在Linux下进行安装，问题还是相当多的，还是推荐大家在官方修复这些问题之前使用Vim吧。 程序是共享软件，永久免费试用！ 如果要购买，费用为：USD $59 测试平台：系统版本号：Ubuntu 12.04 Sublime Text版本号：Version 2.0.1，Build 2217 安装：Sublime Text 2在Linux下的安装还是相当简单的： 在官方网站下载Linux版本 得到一个“.tar.bz2”格式的压缩文件 进行解压 双击文件中的“sublime_text”即可打开 中文显示：软件在Linux下是无法显示中文的，可以通过如下操作解决： 菜单栏 -&gt; Preferences -&gt; Settings – User，在配置文件中增加（前半部分原本就有，可看情况进行替换）： // Settings in here override those in “Default/Base File.sublime-settings”, and // are overridden in turn by file type specific settings. Place your settings // here, to ensure they’re preserved when upgrading. { “font_face”: “WenQuanYi Micro Hei Mono” }其中“文泉驿”是著名的开源字体 http://wenq.org/ 中文输入：设置fcitx输入法的切换键，将默认的Ctrl+Space方式设置Ctrl+Shift，但是这样效果不太好，经常中文会启动不了。 可以在其他地方输入后进行复制粘贴。 在以后的Sublime Text 2或许可以得到解决。 快捷键冲突：默认的代码提示快捷键是“Ctrl+Space”，与输入法切换冲突，导致两方均失效。 可以在菜单栏 -&gt; Preferences -&gt; Key Bindings – Default 里搜索 “insert_best_completion” 出现： { “keys”: [“tab”], “command”: “insert_best_completion”, “args”: {“default”: “\\t”, “exact”: true} },改变keys的值为需要的快捷键即可，推荐：{ “keys”: [“alt+/“], “command”: “insert_best_completion”, “args”: {“default”: “\\t”, “exact”: true} }, 特色功能： 良好的扩展功能(Package) 右边没有滚动条，取而代之的是代码缩略图 强大的快捷命令：可实时搜索相应的命令、选项、Snippet 和 Syntex， 回车即可执行 即时的文件切换 随心所欲的跳转到任意文件的任意位置 多重选择(Multi-Selection)功能允许在页面中同时存在多个光标。 支持 VIM 模式 支持宏 更新非常快 …… 小技巧： 选择文字之后，按下 Tab 和 Shift + Tab 可以控制缩进。 文件无需保存就可以直接退出程序，下次启动会自动恢复。","categories":[{"name":"Go语言","slug":"golang","permalink":"http://quanke.name/categories/golang/"}],"tags":[],"keywords":[{"name":"Go语言","slug":"golang","permalink":"http://quanke.name/categories/golang/"}]},{"title":" 你知道 facebook,sina,sohu都用的啥数据库吗？不知道的话请看本文章！（35个非主流的数据库）","slug":"other/e4-bd-a0-e7-9f-a5-e9-81-93-facebooksinasohu-e9-83-bd-e7-94-a8-e7-9a-84-e5-95-a5-e6-95-b0-e6-8d-ae-e5-ba-93-e5-90-97-ef-bc-9f-e4-b8-8d-e7-9f-a5-e9-81-93-e7-9a-84-e8-af-9d-e8-af-b7-e7-9c-8b-e6-9c-ac","date":"2012-12-10T07:38:14.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/58857/","link":"","permalink":"http://quanke.name/posts/58857/","excerpt":"","text":"# 35个非主流开源数据库 你知道吗？ 【IT168 评论】 几乎每个Web开发人员都有自己喜欢的数据库，或自己最熟悉的数据库，但最常见的无外乎以下几种：MySQLPostgreSQLMSSQLSQLiteMS Access或是更简单的XML，文本文件等。这些数据库有优秀的文档，背后有强大的社区支持，大部分流行的CMS都使用了其中之一或多个，它们都易于使用，大多数 托管服务供应商都提供了相应的产品，因此它们的使用量很多，名气也很大。但除了这些主流的数据库外，还有很多其它非主流数据库存在，其中有一些也开始受到 人们的高度重视，下面我们就一起来看看吧，注意本文只介绍开源数据库，说不定在下一个项目中，你就有尝试它们的冲动。1、 MongoDBMongoDB是一款开源，高性能，可扩展，无模式，面向文档(与JSON类似的数据模式)的数据库，它为时下 最流行的编程语言提供了驱动，如PHP，Python，Perl，Ruby，JavaScript，C++等，支持全文索引，自动分片，跨LAN或WAN 扩展，采用Key/Value方式存储数据。MongoDB服务端可运行在Linux、Windows或OS X平台，支持32位和64位应用。世界上最大的单词收录网站Wordnik就从MySQL转向了MongoDB。2、 HypertableHypertable是一款高性能分布式数据存储系统，旨在为应用程序提供最好的性能，可扩展性和可靠性，它建 立在Google的BigTable之上，主要面向大规模数据集应用，其目标是要成为世界上最好的大规模并发高性能数据库平台。百度目前也使用了 Hypertable，也是它的赞助商。3、Apache CouchDBApache CouchDB是一款面向文档的数据库，可以使用JavaScript通过MapReduce方法进行查询和索引，它提供了一个RESTful JSON API，因此可以在任何环境中通过HTTP访问，CouchDB内置了Web管理控制台，支持通过浏览器管理数据库。CouchDB使用Erlang编 写，Erlang是一种健壮的函数式编程语言，非常适合于构建并发的分布式系统，Erlang的设计非常灵活，其可伸缩性与可扩展性都非常棒。4、Neo4jNeo4j是一个嵌入式，基于磁盘的，支持完整事务的Java持久化引擎，它在图像中而不是表中存储数据。 Neo4j提供了大规模可扩展性，在一台机器上可以处理数十亿节点/关系/属性的图像，可以扩展到多台机器并行运行。相对于关系数据库来说，图形数据库善 于处理大量复杂、互连接、低结构化的数据，这些数据变化迅速，需要频繁的查询——在关系数据库中，这些查询会导致大量的表连接，因此会产生性能上的问题。 Neo4j重点解决了拥有大量连接的传统RDBMS在查询时出现的性能衰退问题。通过围绕图形进行数据建模，Neo4j会以相同的速度遍历节点与边，其遍 历速度与构成图形的数据量没有任何关系。此外，Neo4j还提供了非常快的图形算法、推荐系统和OLAP风格的分析，而这一切在目前的RDBMS系统中都 是无法实现的。 5、RiakRiak是一款非常适合于Web应用程序的数据库，它提供了去中心化的Key/Value存储，灵活的map /reduce引擎和友好的HTTP/JSON查询接口。它是一个真正的容错系统，不会出现单点故障，在Riak世界中，没有哪台机器是特殊的或属核心服务器 ，它们都是对等的。6、Oracle Berkeley DBOracle Berkeley DB是一系列开源的嵌入式数据库，使开发人员能够将一个快速、可伸缩、具有工业级别的可靠性和可用性的事务处理数据库引擎结合进他们的应用程序中。 Berkeley DB最先由伯克利加州大学为了移除受到AT&amp;T限制的程式码，从BSD 4.3到4.4时所改写的软件。Berkeley DB运行在大多数的操作系统 中，例如大多数的UNIX系统， 和windows系统，以及实时操作系统 。 7、 Apache CassandraCassandra是一款高可扩展性第二代分布式数据库，属于混合型的非关系的数据库，类似于Google的 BigTable，支持的数据结构非常松散，类似于JSON的BJSON格式，因此可以存储比较复杂的数据类型。Cassandra最初由 Facebook开发，后转变成了开源项目。Cassandra的主要特点就是它不是一个数据库，而是由一堆数据库节点共同构成的一个分布式网络服务，对 Cassandra 的一个写操作，会被复制到其他节点上去，对Cassandra的读操作，也会被路由到某个节点上面去读取。对于一个Cassandra群集来说，扩展性能 是比较简单的事情，只管在群集里面添加节点就可以了。Facebook，Digg，Twitter和Cisco等大型网站都使用了Cassandra。8、MemcachedMemcached是开源的分布式cache系统，现在很多的大型web应用程序包括 facebook，youtube，wikipedia，yahoo等等都在使用memcached来支持他们每天数亿级的页面访问。通过把cache层 与他们的web架构集成，他们的应用程序在提高了性能的同时，还大大降低了数据库的负载。Memcached处理的原子是每一个 key/value对，key会通过一个hash算法转化成hash-key，便于查找、对比以及做到尽可能的散列。同时，memcached用的是一个 二级散列，通过一张大hash表来维护。 9、FirebirdFirebird是一个关系数据库，可以运行在Linux，Windows和各种Unix平台 上，Firebird相对MySQL和PostgreSQL来说比较小，这也使其可以称得上是理想的嵌入式数据库，可用于与其它应用程序服务器 和应用程序捆绑。Firebird具有大部分成熟数据库所具有的功能， 比如支持存储过程、SQL兼容等。10、RedisRedis是一款快速的Key/Value数据库引擎，它在保持键值数据库简单快捷特点的同时，又吸收了部分关 系数据库的优点，从而使它的位置处于关系数据库和键值数据库之间。Redis不仅能保存Strings类型的数据，还能保存Lists类型(有序)和 Sets类型(无序)的数据，而且还能完成排序(SORT)等高级功能，在实现INCR，SETNX等功能的时候，保证了其操作的原子性，除此以外，还支 持主从复制等功能。Redis使用C语言编写，可以想memcached那样使用，放在传统数据库的前端，它支持许多编程语言，受到许多流行的项目使用， 如GitHub和Engine Yard，有一个用PHP编写的客户端叫做Rediska，专门来管理Redis数据库。11、 HBaseHBase是一个分布式，面向列存储的数据库引擎，也可以叫做Hadoop数据库，因为它是Hadoop的子项 目，HBase的目标是托管数十亿行，数百万列的大表，它提供了一个REST风格的Web服务器网关 ，支持XML，Protobuf和二进制数据编码选项。&nbsp;12、KeyspaceKeyspace 是一家叫做 Scalien 的创业公司开发的高可靠 key/value 存储系统，Keyspace 强调的技术点是高可靠性，有以下一些特点：Key/Value存储：一个 key/value 数据存储系统，只支持一些基本操作，如：SET(key, value) 和 GET(key) 等;分布式：多台机器(nodes) 同时存储数据和状态，彼此交换消息来保持数据一致，可视为一个完整的存储系统。为了更可靠，Keyspace 推荐使用奇数个 nodes，比如：3，5，7等;数据一致：所有机器上的数据都是同步更新的、不用担心得到不一致的结果，Keyspace 使用著名的 Paxos 分布式算法;冗余：所有机器(nodes)保存相同的数据，整个系统的存储能力取决于单台机器(node)的 能力;容错：如果有少数 nodes 出错，比如重启、当机、断网、网络丢包等各种 fault/fail 都不影响整个系统的运行;高可靠性：容错、冗余等保证了 Keyspace 的可靠性。 13、4store4store是一个容纳RDF数据的数据库存储和查询引擎，它使用ANSI C99编写，可在类Unix系统上运行，提供一个高性能，可扩展和稳定的平台。4store专门为无共享集群进行优化，最大可支持32节点集群，导入性能 最大可以达到120kT/s，它的查询性能也相当出众。14、MariaDBMariaDB是一个向后兼容的，旨在替换MySQL数据库的MySQL分支，它包括所有主要的开源存储引擎， 另外也开发了属于自己的Maria存储引擎。MariaDB是由原来 MySQL 的作者 Michael Widenius 创办的公司所开发的免费开源数据库服务器，与 MySQL 相比较，MariaDB 更强的地方在于：Maria 存储引擎PBXT 存储引擎XtraDB 存储引擎FederatedX 存储引擎更快的复制查询处理线程池更少的警告和bug运行速度更快更多的 Extensions (More index parts, new startup options etc)更好的功能测试数据表消除慢 查询日志的扩展统计支持对 Unicode 的排序15、DrizzleDrizzle是从MySQL衍生出来的一个数据库，但它的目的不是要取代MySQL，它的宗旨是构建一个“更 精练、更轻量、更快速”的MySQL版本，它的扩展性和易用性与MySQL相当，但为了提高性能和扩展性，它从原来的核心系统里移除了部分功能。 Drizzle是一种为云和网络程序进行了特别优化的数据库，它是为在现代多CPU /多核架构上实现大规模并发而设计的。 16、 HyperSQLHyperSQL是用Java编写的一款SQL关系数据库引擎，它的核心完全是多线程的，支持双向锁和 MVCC(多版本并发控制)，几乎完整支持ANSI-92 SQL，支持常见数据类型，最新版本增加了对BLOB和CLOB数据的支持，最高支持达64T的数据量。同时，HyperSQL也是一个不错的嵌入式数据 库。17、MonetDBMonetDB是一个高性能数据库引擎，主要用在数据挖掘，OLAP，GIS，XML Query，文本和多媒体检索等领域。MonetDB对DBMS的各个层都进行创新设计，如基于垂直分片的存储层，为现代CPU 优化的查询执行架构，自动和自助调整索引，运行时查询优化，以及模块化 的软件架构。MonetDB/SQL是MonetDB提供的关系数据库解决方案，MonetDB/XQuery是XML数据库解决方案，MonetDB Server是MonetDB的多模型数据库服务器。18、PerseverePersevere 是针对Javascript设计的基于REST的JSON数据库，分布式计算，持久对象映射的框架，提供独立的web服务器，主要用于设计富客户端应用， 可以用在任何框架和客户端上。Persevere Server是一个基于Java/Rhino的对象存储引擎，在交互式的客户端JavaScript环境中提供持久性的JSON数据格式。19、eXist-dbeXist-db是使用XML技术构建的数据库存储引擎，它根据XML数据模型存储XML数据，提供高效的，基 于索引的XQuery查询。eXist-db支持许多Web技术标准，使得它非常适合Web应用程序开发：XQuery 1.0 / XPath 2.0 / XSLT 1.0 (使用pache Xalan)或XSLT 2.0HTTP接口：REST，WebDAV，SOAP，XMLRPC，Atom发布协议XML数据库规范：XMLDB，Xupdate，XQuery更新扩展最新的1.4版本还增加了基于Apache Lucene的全文索引，轻量级URL重写和MVC框架，以及对XProc的支持。eXist-db与XQuery标准高度兼容(目前XQTS的得分是 99.4%)。20、GladiusGladius是用纯PHP编写的平面文件数据库引擎，它的SQL语法与SQL92的一个子集兼容，它捆绑了一 个轻量级的adoDB驱动。21、CloudStoreCloudStore(以前叫做Kosmos文件系统)是一个开源的高性能分布式文件系统，它是用C++编写 的，CloudStore可以和Hadoop以及Hypertable集成，这样就允许应用程序构建在那些系统上，而底层数据存储无缝地使用 CloudStore。CloudStore支持Linux和Solaris，主要用来存储Web日志和Web爬行数据。22、 OpenQMOpenQM是唯一一款同时有商业支持和免费的开源多值数据库，基于GPL协议发布，多值数据库对NoSQL运 动起到了推动作用，它自身也因速度快，体积小，比关系数据库便宜而很快得到了认可。名称OpenQM中的Open表示开源版本，QM表示商业闭源QM数据 库。商业版本支持Windows，Linux(RedHat，Fedora，Debian，Ubuntu)，FreeBSD，Mac OS X和Windows Mobile，其列表价格还不到其它多值产品的1/5，商业版本还包括一个GUI管理界面和终端模拟器，开源版本仅包括核心多值数据库引擎，主要是为开发 人员准备的。23、ScarletDMEScarletDME也是一个开源多值数据库，它是OpenQM的社区分支版，最初由Ladybridge开 发，这个项目创立于2008年11月28日，它既在独立开发自己的功能，也在为OpenQM贡献代码。这个项目最初的名字叫做Ladybridges GPL OpenQM，现在正式改为ScarletDME，其中的DME是Data Management Environment(数据管理环境)的首字母缩写。 24、SmallSQLSmallSQL是一个100%纯Java编写的轻量级数据库，一般用于嵌入式领域，兼容SQL 99标准，支持JDBC 3.0 API，定位于高端Java桌面SQL数据库。支持所有能运行Java的平台，可直接嵌入到应用程序中。不过它也有一些不足，如没有网络接口，必须安装 Java运行时，同一时间不能在多个应用程序之间共享数据库，没有用户管理。 25、LucidDBLucidDB是唯一一款专注于数据仓库和商务智能的开源RDBMS，它使用了列存储架构，支持位图索引，哈 希连接/聚合和页面级多版本，大部分数据库最初都注重事务处理能力，而分析功能都是后来才加上去的。相反，LucidDB中的所有组件从一开始就是为满足 灵活的需求，高性能数据集成和大规模数据查询而设计的，此外，其架构设计彻底从用户出发，操作简单，完全无需DBA。LucidDB对 硬件要求也极低，即使不搭建集群环境，在单一的Linux或Windows服务器上也能获得极好的性能。最新版本还加入了对Mac OS X和Windows 64位的支持，官方网站上的文档和教程也非常丰富，非常值得你体验一下。26、HyperGraphDBHyperGraphDB是一种通用的，可扩展的，可移植的，分布式，嵌入式和开源数据存储机制，它是一个图 形数据库，专门为人工智能和语义Web项目而设计，它也可用于任意规模的嵌入式面向对象的数据库。正如其名，HyperGraphDB是用来存储超图的， 但它也属于一般图形数据库家族，作为一个图形数据库，它不施加任何限制，相比其他图形数据库它的功能更丰富。HyperGraphDB 非常稳定，已经应用在多个生产环境，包括一个搜索引擎和Seco scripting IDE。它支持nix和Windows平台，需要Java 5+。27、InfoGridInfoGrid是一个互联网图形数据库，它提供了许多额外的组件，使得在图像基础上开发RESTful Web应用程序变得更加容易。InfoGrid是开源的，包括一系列项目：InfoGrid图形数据库项目 – InfoGrid的心脏GraphDatabase，可以独立使用，也可以附加到其它InfoGrid项目。InfoGrid图形数据 库网格项目 – 在GraphDatabase基础上增加了复制协议，因此多个分布式GraphDatabase就可以在一个非常大的图像管理环境中协作。InfoGrid存储项目 –象SQL数据库和分布式NoSQL哈希表那样，为存储技术提供一个抽象的通用接口，这样InfoGrid GraphDatabase就可以使用任何存储技术持久化数据。InfoGrid用户接口项目 – 将GraphDatabase中的内容以REST风格映射成浏览器可访问的URL。InfoGrid轻量级身份识别项目 – 实现以用户为中心的身份识别技术，如LID和OpenID。InfoGrid模型库项目 – 定义一个可复用对象模型库，作为InfoGrid应用程序的模式使用。InfoGrid Probe项目 – 实现Probe框架，它允许开发人员将任何互联网上的数据源当作一个图像对象看待。InfoGrid Utilities项目 – 收集InfoGrid使用的常见对象框架和实用代码。 28、Apache DerbyApache Derby是Apache DB的子项目，它完全用Java编写，是一个开源关系数据库，它的体积非常小，基础引擎加上JDBC驱动只有2.6MB，它支持SQL标准，它提供了一个 嵌入式JDBC驱动，因此可以嵌入到任何基于Java的应用程序中，Derby也支持常见的客户端/服务器模式，它也易于安装和使用。29、 hamsterdbHamsterdb是一个轻量级嵌入式NoSQL Key/Value存储引擎，它已经有5年历史，现在它的开发重点放在易用性，高性能，稳定性和可扩展性上。Hamsterdb支持事务(同一时间只能处 理一个事务)，支持内存 数据库，支持基于HTTP服务器的嵌入式 远程数据库，支持日志/恢复，AES加密，基于zlib的压缩，支持C++，Python，.NET和Java编程语言。30、 H2 DatabaseH2 Database是一个开源的Java数据库，它的速度很快，包括JDBC API，支持嵌入式和服务器模式，内存 数据库，提供了一个基于浏览器的控制台程 序，它的体积也非常小，只有一个大小约1MB的jar文件，它还支持ODBC驱动和全文搜索。31、EyeDBEyeDB是一款基于ODMG 3规范的面向对象数据库管理系统，为C++和Java提供了编程接口，它功能非常强大，并且成熟，稳定和安全，实际上，它起源于1992年的Genome View项目，1994年又进行了重写，广泛用于生物信息项目。32、txtSQLtxtSQL是一个面向对象的平面文件数据库管理系统，它使用PHP编写，支持对普通文本文件的操作，虽然是一 个文本数据库，但同样支持SQL的一个子集，并且执行效率非常高，txtSQL使用文件系统的方法与MySQL的表和数据库原理类似，它有一个类似于 phpMyAdmin管理界面。 33、db4odb4o是一个面向对象的开源数据库，允许Java和.NET开发人员用一行代码存储和检索任何应用程序对象， 无需预定义或维护一个独立的，僵化的数据模型，因为模型现在是由db4o根据需要自动创建和更新的。db4o成功的秘密是因为它的易用性，它原生为 Java和.NET设计，存储数据对象的方法直接在应用程序中定义，因此db4o很容易集成到应用程序中，由于只需要一行代码，因此执行效率非常高。34、Tokyo CabinetTokyo Cabinet是一个Kay/Value型数据库，每个Key和Value的长度都可以不同，Kay和Value既可以是二进制数据，也可以是字符串，无 数据表和数据类型的概念，记录是以哈希表、B+树和固定长度数组形式组织的。Tokyo Cabinet具有以下优点：空间利用率高 – 数据文件尺寸更小;执行效率高 – 更快的处理速度;并发性能好 – 在多线程环境性能更好;改善的可用性 – 简化的API;改善的可靠性 – 即使在发生灾难的情况下，数据文件也不会损坏;支持64位架构 – 支持海量的存储空间和巨型数据库文件。Tokyo Cabinet是用C语言编写的，为C，Perl，Ruby，Java和Lua提供了API。* 35、Voldemort项目Voldemort是一个分布式Key/Value存储系统，它具有以下特点：数据自动在多 个服务器之间复制;数据自动分区，因此每个服务器只包括整体数据的一个子集;服务器故障处理是透明的;支持插入式序列化，允许丰富的Key和Value类型，包括列表和元组，也可以集成常见的序列化框架，如Protocol Buffers，Thrift，Avro和Java Serialization数据项支持版本化，即使在故障情况下，数据完整性也可 以得到保障;每个节点都是独立的，无需其他节点协调，因此也没有中央节点;单节点性能优秀：根据机器配置、网络、磁 盘系统和数据复制因素的不同，每秒可以执行10-20k操作;支持地理分散式部署。LinkedIn目前就使用 Voldemort解决了高可伸缩性存储问题。不知道你是否一口气看完本文，我想你也一定会惊讶于这么多开源数据库吧，事实上，本文也 尚未完全罗列，欢迎你的补充。原文出处：http://phpcamp.net/toolbar/25-alternative-open-source-database-engines原文名：25+ Alternative &amp; Open Source Database Engines","categories":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}],"tags":[],"keywords":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}]},{"title":"eclipse 快捷键","slug":"other/eclipse-e5-bf-ab-e6-8d-b7-e9-94-ae","date":"2012-11-28T06:47:53.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/29126/","link":"","permalink":"http://quanke.name/posts/29126/","excerpt":"","text":"熟悉eclipse开发android的一些快捷键，能很大的提高效率，分享在下面：Ctrl+1 快速修复(最经典的快捷键,就不用多说了)Ctrl+D: 删除当前行Ctrl+Alt+↓ 复制当前行到下一行(复制增加)Ctrl+Alt+↑ 复制当前行到上一行(复制增加)Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)Alt+↑ 当前行和上面一行交互位置(同上)Alt+← 前一个编辑的页面Alt+→ 下一个编辑的页面(当然是针对上面那条来说了)Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后)Shift+Ctrl+Enter 在当前行插入空行(原理同上条)Ctrl+Q 定位到最后编辑的地方Ctrl+L 定位在某行 (对于程序超过100的人就有福音了)Ctrl+M 最大化当前的Edit或View (再按则反之)Ctrl+/ 注释当前行,再按则取消注释Ctrl+O 快速显示 OutLineCtrl+T 快速显示当前类的继承结构Ctrl+W 关闭当前EditerCtrl+K 参照选中的Word快速定位到下一个Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示)Ctrl+/(小键盘) 折叠当前类中的所有代码Ctrl+×(小键盘) 展开当前类中的所有代码Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替)Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作)Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了)Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查)Ctrl+Shift+F4 关闭所有打开的EditerCtrl+Shift+X 把当前选中的文本全部变味小写Ctrl+Shift+Y 把当前选中的文本全部变为小写Ctrl+Shift+F 格式化当前代码Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift开头的了)Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力)Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用)Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定)Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候)Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能)Alt+Shift+I 合并变量(可能这样说有点不妥Inline)Alt+Shift+V 移动函数和变量(不怎么常用)Alt+Shift+Z 重构的后悔药(Undo)编辑作用域 功能 快捷键全局 查找并替换 Ctrl+F文本编辑器 查找上一个 Ctrl+Shift+K文本编辑器 查找下一个 Ctrl+K全局 撤销 Ctrl+Z全局 复制 Ctrl+C全局 恢复上一个选择 Alt+Shift+↓全局 剪切 Ctrl+X全局 快速修正 Ctrl1+1全局 内容辅助 Alt+/全局 全部选中 Ctrl+A全局 删除 Delete全局 上下文信息 Alt+？Alt+Shift+?Ctrl+Shift+SpaceJava编辑器 显示工具提示描述 F2Java编辑器 选择封装元素 Alt+Shift+↑Java编辑器 选择上一个元素 Alt+Shift+←Java编辑器 选择下一个元素 Alt+Shift+→文本编辑器 增量查找 Ctrl+J文本编辑器 增量逆向查找 Ctrl+Shift+J全局 粘贴 Ctrl+V全局 重做 Ctrl+Y 查看作用域 功能 快捷键全局 放大 Ctrl+=全局 缩小 Ctrl+- 窗口作用域 功能 快捷键全局 激活编辑器 F12全局 切换编辑器 Ctrl+Shift+W全局 上一个编辑器 Ctrl+Shift+F6全局 上一个视图 Ctrl+Shift+F7全局 上一个透视图 Ctrl+Shift+F8全局 下一个编辑器 Ctrl+F6全局 下一个视图 Ctrl+F7全局 下一个透视图 Ctrl+F8文本编辑器 显示标尺上下文菜单 Ctrl+W全局 显示视图菜单 Ctrl+F10全局 显示系统菜单 Alt+- 导航作用域 功能 快捷键Java编辑器 打开结构 Ctrl+F3全局 打开类型 Ctrl+Shift+T全局 打开类型层次结构 F4全局 打开声明 F3全局 打开外部javadoc Shift+F2全局 打开资源 Ctrl+Shift+R全局 后退历史记录 Alt+←全局 前进历史记录 Alt+→全局 上一个 Ctrl+,全局 下一个 Ctrl+.Java编辑器 显示大纲 Ctrl+O全局 在层次结构中打开类型 Ctrl+Shift+H全局 转至匹配的括号 Ctrl+Shift+P全局 转至上一个编辑位置 Ctrl+QJava编辑器 转至上一个成员 Ctrl+Shift+↑Java编辑器 转至下一个成员 Ctrl+Shift+↓文本编辑器 转至行 Ctrl+L 搜索作用域 功能 快捷键全局 出现在文件中 Ctrl+Shift+U全局 打开搜索对话框 Ctrl+H全局 工作区中的声明 Ctrl+G全局 工作区中的引用 Ctrl+Shift+G 文本编辑作用域 功能 快捷键文本编辑器 改写切换 Insert文本编辑器 上滚行 Ctrl+↑文本编辑器 下滚行 Ctrl+↓ 文件作用域 功能 快捷键全局 保存 Ctrl+XCtrl+S全局 打印 Ctrl+P全局 关闭 Ctrl+F4全局 全部保存 Ctrl+Shift+S全局 全部关闭 Ctrl+Shift+F4全局 属性 Alt+Enter全局 新建 Ctrl+N 项目作用域 功能 快捷键全局 全部构建 Ctrl+B 源代码作用域 功能 快捷键Java编辑器 格式化 Ctrl+Shift+FJava编辑器 取消注释 Ctrl+\\Java编辑器 注释 Ctrl+/Java编辑器 添加导入 Ctrl+Shift+MJava编辑器 组织导入 Ctrl+Shift+OJava编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。也可以使用Ctrl+1自动修正。 运行作用域 功能 快捷键全局 单步返回 F7全局 单步跳过 F6全局 单步跳入 F5全局 单步跳入选择 Ctrl+F5全局 调试上次启动 F11全局 继续 F8全局 使用过滤器单步执行 Shift+F5全局 添加/去除断点 Ctrl+Shift+B全局 显示 Ctrl+D全局 运行上次启动 Ctrl+F11全局 运行至行 Ctrl+R全局 执行 Ctrl+U 重构作用域 功能 快捷键全局 撤销重构 Alt+Shift+Z全局 抽取方法 Alt+Shift+M全局 抽取局部变量 Alt+Shift+L全局 内联 Alt+Shift+I全局 移动 Alt+Shift+V全局 重命名 Alt+Shift+R全局 重做 Alt+Shift+Y","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":" ZXing改横屏识别为竖屏识别","slug":"other/zxing-e6-94-b9-e6-a8-aa-e5-b1-8f-e8-af-86-e5-88-ab-e4-b8-ba-e7-ab-96-e5-b1-8f-e8-af-86-e5-88-ab","date":"2012-11-28T06:47:01.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/16104/","link":"","permalink":"http://quanke.name/posts/16104/","excerpt":"","text":"Apache License 2.0 开源的 ZXing项目 ZXing的android项目东西太多了，有很多是我们不需要的，得新建另一个项目简化它。 在开始前大致介绍一下简化ZXing需要用到各个包 、类的职责。 CaptureActivity。这个是启动Activity 也就是扫描器（如果是第一安装，它还会跳转到帮助界面）。 CaptureActivityHandler 解码处理类，负责调用另外的线程进行解码。 DecodeThread 解码的线程。 com.google.zxing.client.android.camera 包，摄像头控制包。 ViewfinderView 自定义的View，就是我们看见的拍摄时中间的框框了。 解决方法： 1.在DecodeHandler.java中，修改decode方法 PlanarYUVLuminanceSource source = CameraManager.get().buildLuminanceSource(data, width, height);为 byte[] rotatedData = new byte[data.length]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) rotatedData[x height + height - y - 1] = data[x + y width]; } int tmp = width; // Here we are swapping, that’s the difference to #11 width = height; height = tmp; PlanarYUVLuminanceSource source = CameraManager.get().buildLuminanceSource(rotatedData, width, height); 2.在CameraManager.java中，注释代码： // rect.left = rect.left cameraResolution.x / screenResolution.x; // rect.right = rect.right cameraResolution.x / screenResolution.x; // rect.top = rect.top cameraResolution.y / screenResolution.y; // rect.bottom = rect.bottom cameraResolution.y / screenResolution.y;修改为 rect.left = rect.left cameraResolution.y / screenResolution.x; rect.right = rect.right cameraResolution.y / screenResolution.x; rect.top = rect.top cameraResolution.x / screenResolution.y; rect.bottom = rect.bottom cameraResolution.x / screenResolution.y; 3.在CameraConfigurationManager.java中，在setDesiredCameraParameters方法中添加一句 camera.setDisplayOrientation(90); 4.在AndroidManifest.xml中，把Activity的属性android:screenOrientation=”landscape”改为 android:screenOrientation=”portrait” 编译运行即可！ 参考： http://code.google.com/p/zxing/issues/detail?id=178#c46 代码：https://github.com/pplante/zxing-android","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Java:使用Executors创建和管理线程","slug":"java/Java使用Executors创建和管理线程","date":"2012-11-25T05:33:57.000Z","updated":"2018-02-02T15:00:03.000Z","comments":true,"path":"posts/37465/","link":"","permalink":"http://quanke.name/posts/37465/","excerpt":"","text":"1. 类 Executors此类中提供的一些方法有： 1.1 public static ExecutorService newCachedThreadPool() 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。 1.2 public static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。 1.3 public static ExecutorService newSingleThreadExecutor() 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。 这三个方法都可以配合接口ThreadFactory的实例一起使用。并且返回一个ExecutorService接口的实例。 2. 接口 ThreadFactory根据需要创建新线程的对象。使用线程工厂就无需再手工编写对 new Thread 的调用了，从而允许应用程序使用特殊的线程子类、属性等等。此接口最简单的实现就是： class SimpleThreadFactory implements ThreadFactory &#123; public Thread newThread(Runnable r) &#123; return new Thread(r); &#125; &#125; 接口ExecutorService该接口提供了管理终止的方法。4.创建标准线程池启动线程4.1 提供一个简单的实现Runnable接口的线程 MyThread.javapackage com.zj.concurrency.executors;public class MyThread implements Runnable &#123; private int count = 1, number; public MyThread(int num) &#123; number = num; System.out.println(&amp;quot;Create Thread-&amp;quot; + number); &#125; public void run() &#123; while (true) &#123; System.out.println(&amp;quot;Thread-&amp;quot; + number + &amp;quot; run &amp;quot; + count+&amp;quot; time(s)&amp;quot;); if (++count == 3) return; &#125; &#125;&#125; 这个线程会打印出相应的创建和执行信息。 4.2使用CachedThreadPool启动线程 CachedThreadPool.javapackage com.zj.concurrency.executors;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class CachedThreadPool &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); for (int i = 0; i &amp;lt; 5; i++) exec.execute(new MyThread(i)); exec.shutdown(); &#125;&#125; 结果： Create Thread-0Create Thread-1Create Thread-2Create Thread-3Thread-0 run 1 time(s)Thread-0 run 2 time(s)Thread-1 run 1 time(s)Thread-1 run 2 time(s)Thread-2 run 1 time(s)Thread-2 run 2 time(s)Create Thread-4Thread-4 run 1 time(s)Thread-4 run 2 time(s)Thread-3 run 1 time(s)Thread-3 run 2 time(s) 4.3 使用FixedThreadPool启动线程 FixedThreadPool.javapackage com.zj.concurrency.executors;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class FixedThreadPool &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newFixedThreadPool(2); for (int i = 0; i &amp;lt; 5; i++) exec.execute(new MyThread(i)); exec.shutdown(); &#125;&#125; 结果： Create Thread-0Create Thread-1Create Thread-2Create Thread-3Create Thread-4Thread-0 run 1 time(s)Thread-0 run 2 time(s)Thread-2 run 1 time(s)Thread-2 run 2 time(s)Thread-3 run 1 time(s)Thread-3 run 2 time(s)Thread-4 run 1 time(s)Thread-4 run 2 time(s)Thread-1 run 1 time(s)Thread-1 run 2 time(s) 4.4 使用SingleThreadExecutor启动线程 SingleThreadExecutor.javapackage com.zj.concurrency.executors;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class SingleThreadExecutor &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newSingleThreadExecutor(); for (int i = 0; i &amp;lt; 5; i++) exec.execute(new MyThread(i)); exec.shutdown(); &#125;&#125; 结果： Create Thread-0Create Thread-1Create Thread-2Create Thread-3Create Thread-4Thread-0 run 1 time(s)Thread-0 run 2 time(s)Thread-1 run 1 time(s)Thread-1 run 2 time(s)Thread-2 run 1 time(s)Thread-2 run 2 time(s)Thread-3 run 1 time(s)Thread-3 run 2 time(s)Thread-4 run 1 time(s)Thread-4 run 2 time(s) 5.配合ThreadFactory接口的使用 我们试图给线程加入daemon和priority的属性设置。 5.1设置后台线程属性 DaemonThreadFactory.javapackage com.zj.concurrency.executors.factory;import java.util.concurrent.ThreadFactory;public class DaemonThreadFactory implements ThreadFactory &#123; public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); t.setDaemon(true); return t; &#125;&#125; 5.2 设置优先级属性 最高优先级MaxPriorityThreadFactory.java package com.zj.concurrency.executors.factory;import java.util.concurrent.ThreadFactory;public class MaxPriorityThreadFactory implements ThreadFactory &#123; public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); t.setPriority(Thread.MAX_PRIORITY); return t; &#125;&#125; 最低优先级MinPriorityThreadFactory.java package com.zj.concurrency.executors.factory;import java.util.concurrent.ThreadFactory;public class MinPriorityThreadFactory implements ThreadFactory &#123; public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); t.setPriority(Thread.MIN_PRIORITY); return t; &#125;&#125; 5.3启动带有属性设置的线程 ExecFromFactory.javapackage com.zj.concurrency.executors;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import com.zj.concurrency.executors.factory.DaemonThreadFactory;import com.zj.concurrency.executors.factory.MaxPriorityThreadFactory;import com.zj.concurrency.executors.factory.MinPriorityThreadFactory;public class ExecFromFactory &#123; public static void main(String[] args) throws Exception &#123; ExecutorService defaultExec = Executors.newCachedThreadPool(); ExecutorService daemonExec = Executors .newCachedThreadPool(new DaemonThreadFactory()); ExecutorService maxPriorityExec = Executors .newCachedThreadPool(new MaxPriorityThreadFactory()); ExecutorService minPriorityExec = Executors .newCachedThreadPool(new MinPriorityThreadFactory()); for (int i = 0; i &amp;lt; 10; i++) daemonExec.execute(new MyThread(i)); for (int i = 10; i &amp;lt; 20; i++) if (i == 10) maxPriorityExec.execute(new MyThread(i)); else if (i == 11) minPriorityExec.execute(new MyThread(i)); else defaultExec.execute(new MyThread(i)); &#125;&#125; 结果： Create Thread-0Create Thread-1Create Thread-2Create Thread-3Thread-0 run 1 time(s)Thread-0 run 2 time(s)Thread-1 run 1 time(s)Thread-1 run 2 time(s)Thread-2 run 1 time(s)Thread-2 run 2 time(s)Create Thread-4Thread-4 run 1 time(s)Thread-4 run 2 time(s)Create Thread-5Thread-5 run 1 time(s)Thread-5 run 2 time(s)Create Thread-6Create Thread-7Thread-7 run 1 time(s)Thread-7 run 2 time(s)Create Thread-8Thread-8 run 1 time(s)Thread-8 run 2 time(s)Create Thread-9Create Thread-10Thread-10 run 1 time(s)Thread-10 run 2 time(s)Create Thread-11Thread-9 run 1 time(s)Thread-9 run 2 time(s)Thread-6 run 1 time(s)Thread-6 run 2 time(s)Thread-3 run 1 time(s)Thread-3 run 2 time(s)Create Thread-12Create Thread-13Create Thread-14Thread-12 run 1 time(s)Thread-12 run 2 time(s)Thread-13 run 1 time(s)Thread-13 run 2 time(s)Create Thread-15Thread-15 run 1 time(s)Thread-15 run 2 time(s)Create Thread-16Thread-16 run 1 time(s)Thread-16 run 2 time(s)Create Thread-17Create Thread-18Create Thread-19Thread-14 run 1 time(s)Thread-14 run 2 time(s)Thread-17 run 1 time(s)Thread-17 run 2 time(s)Thread-18 run 1 time(s)Thread-18 run 2 time(s)Thread-19 run 1 time(s)Thread-19 run 2 time(s)Thread-11 run 1 time(s)Thread-11 run 2 time(s)","categories":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}],"tags":[],"keywords":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}]},{"title":"解决Eclipse无法打开“Failed to load the JNI shared library”","slug":"other/e8-a7-a3-e5-86-b3eclipse-e6-97-a0-e6-b3-95-e6-89-93-e5-bc-80-e2-80-9cfailed-to-load-the-jni-shared-library-e2-80-9d","date":"2012-11-24T23:42:58.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/28354/","link":"","permalink":"http://quanke.name/posts/28354/","excerpt":"","text":"这是因为JDK配置错误所导致的现象。 一般说来，新购笔记本会预装64位的windows系统，而在网上下载软件时，32位会优先出现在页面中（现在来说是这个情况，但我认为未来64位会越来越普及）。 如果你是64位的系统，却安装了32位的JDK，就会导致上面的情况。 解决办法如下： 卸载掉原来安装的32位的JDK，然后安装64位的JDK到电脑中。 重新修改path 和 classpath 两个环境变量。因为在64系统当中，32位软件回安装到program files （86）文件夹，64位软件会安装到program files 文件夹，当你先前安装32JDK时，你设置的环境变量路径当中当然会包括“program files （86）”，而这时JDK已经转移到“program files”中了，修改过来即可。 注意你两次安装的JDK版本号，不一定相同，因为安装时会根据你的版本号建立JDK文件夹，如果两次的版本号不同，在环境变量里也要修改。现在，Eclipse应该可以正常使用了，快去练习Java程序吧！ 扩展阅读： 32位与64位操作系统 JDK——Java开发套件下载链接： 64位JDK下载 Oracle官方下载","categories":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}],"tags":[],"keywords":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}]},{"title":" go语言教程","slug":"golang/go-e8-af-ad-e8-a8-80-e6-95-99-e7-a8-8b","date":"2012-11-22T17:31:11.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/23178/","link":"","permalink":"http://quanke.name/posts/23178/","excerpt":"","text":"http://www.yiibai.com/go","categories":[{"name":"Go语言","slug":"golang","permalink":"http://quanke.name/categories/golang/"}],"tags":[],"keywords":[{"name":"Go语言","slug":"golang","permalink":"http://quanke.name/categories/golang/"}]},{"title":"Windows8鼠标和键盘快捷操作","slug":"other/windows8-e9-bc-a0-e6-a0-87-e5-92-8c-e9-94-ae-e7-9b-98-e5-bf-ab-e6-8d-b7-e6-93-8d-e4-bd-9c","date":"2012-11-21T19:28:13.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/53863/","link":"","permalink":"http://quanke.name/posts/53863/","excerpt":"","text":"有关在 Windows 中使用鼠标和键盘的大多数方法和技巧基本保持不变（特别是在桌面中）。 下面的一些方法介绍了如何通过鼠标和键盘快捷方式来使用 Windows 8 和 Windows RT 的新功能，以及如何在新环境中找到一些熟悉的功能。Win8之家(Win8e.com)搜集整理 操作使用鼠标使用鼠标打开超级按钮（“搜索”、“共享”、“开始”、“设备”和“设置”）。指向右上角或右下角以查看超级按钮。 （尝试移动到角落中让鼠标指针消失。） 当超级按钮出现时，沿着边缘向上或向下移动，以单击所需的超级按钮。所有超级按钮：Win键+C“搜索”按钮：Win键+Q“共享”按钮：Win键+H“开始”按钮：Win键“设备”按钮：Win键+K“设置”按钮：Win键 +I在你的电脑（应用、设置和文件）、Web 或应用中搜索。指向右上角或右下角以查看超级按钮。 （尝试移动到角落中让鼠标指针消失。） 当超级按钮出现时，沿着边缘向上或向下移动，单击“搜索”，然后输入你的搜索词。 如果要搜索设置、文件或其他应用，请单击该选项。如果已在“开始”屏幕中，则可以直接输入搜索词。如果要查看你的电脑上所有应用的列表，请右键单击“开始”屏幕，然后单击“所有应用”。在应用内搜索或查找某应用：Windows 徽标键 +Q搜索设置：Win键 +W搜索文件：Win键 +F转到“开始”屏幕。指向左下角。 当出现“开始”时，单击左下角。指向右上角或右下角以查看超级按钮。 （尝试移动到角落中让鼠标指针消失。） 当超级按钮出现时，沿着边缘向上或向下移动，然后单击“开始”。按键盘上的 Windows 徽标键转至命令和上下文菜单。右键单击以查看命令和上下文菜单。 在项目上右键单击通常会弹出特定于该项目的选项。Win键 +Z使用 Tab 或箭头键突出显示内容，然后按空格键或 Enter。在最近使用的应用之间切换。若要切换到最近使用的应用，请指向左上角。 （尝试将鼠标指针移动到角落中让鼠标指针消失。） 当出现上一个应用时，单击该角落。若要切换到其他应用，请指向左上角，然后稍微向下移动一点。 当出现其他应用时，单击所需的应用。Win键 +Tab贴靠一个应用，以便并排使用两个应用。注意：你的屏幕分辨率必须至少为 1366 x 768 才能贴靠应用。 检查此设置的步骤：通过以下方式打开“屏幕分辨率”：从屏幕的右边缘向中间轻扫，点击“搜索”（如果使用鼠标，则指向屏幕的右上角，然后将指针向下移动，再单击“搜索”），在搜索框中输入“显示”，然后依次点击或单击“设置”和“显示”。桌面被视为一个应用。将指针移动到左上角直至第二个应用出现，然后将该应用拖动到屏幕的左侧或右侧直至该应用后出现一个开口。你也可以指向左上角，然后将指针向下移动以查看最近使用的应用。 单击并拖动要贴靠的应用。保持该应用的大小不变，或调整该应用的大小使其占据屏幕的三分之二或布满整个屏幕。Win键 +句点打开桌面。转到“开始”屏幕，然后单击“桌面”磁贴。Win键 +D放大或缩小在“开始”屏幕上，使用右下角的缩放图标 或 Ctrl+滚轮。Ctrl+加号即可放大Ctrl+减号即可缩小关闭应用指向屏幕的顶部边缘，然后单击应用并将其拖动到屏幕的底部。你还可以通过指向左上角并向下拉来关闭最近使用的应用。 右键单击要关闭的应用， 然后选择“关闭”。Alt+F4Alt+F4指向右上角或右下角以查看超级按钮。 （尝试移动到角落中让鼠标指针消失。） 当超级按钮出现时，沿着边缘向上或向下移动，然后单击“设置”。 单击“电源”，然后选择关机选项。十种关机方法1. 按 Ctrl+Alt+Del。2. 使用 Tab 键移动到“电源”图标。 将显示关机选项列表。3. 使用向上或向下键移动到所需选项。4. 按 Enter。","categories":[{"name":"使用","slug":"use","permalink":"http://quanke.name/categories/use/"}],"tags":[],"keywords":[{"name":"使用","slug":"use","permalink":"http://quanke.name/categories/use/"}]},{"title":" ImageView控件开发滤镜效果","slug":"android/imageview-e6-8e-a7-e4-bb-b6-e5-bc-80-e5-8f-91-e6-bb-a4-e9-95-9c-e6-95-88-e6-9e-9c","date":"2012-11-21T18:31:54.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/32992/","link":"","permalink":"http://quanke.name/posts/32992/","excerpt":"","text":"实现过程说明：使用设置图片对象的ColorFilter属性，把ColorMatrixColorFilter设置灰度通道，传递到ColorFilter属性中注意两点：1 图片滤镜效果，只是在图层上面 加了一层效果，不是对图片的实际修改\\如果对单个图片加滤镜效果后，其他地方使用到这个图片也会变成带滤镜效果。下面是实际实现代码[code lang=”java”]public final float[] BT_SELECTED = new float[] {1,0,0,0,99,0,1,0,0,99,0,0,1,0,99,0,0,0,1,0};public final float[] BT_NOT_SELECTED = new float[] {1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0};;public final static float[] BT_SELECTED1 = new float[] {.338f, 0.339f, 0.332f, 0, 0,.338f, 0.339f, 0.332f, 0, 0,.338f, 0.339f, 0.332f, 0, 0,, 0, 0, 1, 0}; @Overridepublic void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.main); ImageView ib2;ib1 = (ImageView) findViewById(R.id.imageViewt);ib2 = (ImageView) findViewById(R.id.imageView2); ib1.setOnTouchListener(new ImageView.OnTouchListener(){@Overridepublic boolean onTouch(View v, MotionEvent event) {if (event.getAction() == MotionEvent.ACTION_DOWN) { ib1.setImageResource(R.drawable.icon1);ib1.getDrawable().setColorFilter(new ColorMatrixColorFilter(BT_SELECTED)); ib1.setImageDrawable(ib1.getDrawable());} else if (event.getAction() == MotionEvent.ACTION_UP) {ib1.getDrawable().clearColorFilter(); ib1.getDrawable().setColorFilter(new ColorMatrixColorFilter(BT_NOT_SELECTED));ib1.setImageResource(R.drawable.icon2);}return false;}}); }[/code]","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"程序中如何获取Android的Root权限","slug":"other/e7-a8-8b-e5-ba-8f-e4-b8-ad-e5-a6-82-e4-bd-95-e8-8e-b7-e5-8f-96android-e7-9a-84root-e6-9d-83-e9-99-90","date":"2012-11-21T18:09:26.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/5630/","link":"","permalink":"http://quanke.name/posts/5630/","excerpt":"","text":"我们知道Android手机操作系统采用的是Linux内核，Linux中最高的系统权限就是Root，这就类似与Windows中的Administrator系统管理员权限，也就是操作系统的最高权限。由于Root的权限过高，因此手机产商一般都不允许用户直接拥用Root权限，以防止用户修改系统内置的业务跟程序。但是对于用户来说，当然希望能拥有Root权限以将手机修改成自己的一种特色，因为有Root权限则可以任意修改手机的所有文件跟程序，让手机更加个性化。那么我们在Android开发中如何获取Android的Root权限呢？下面是主要的简单代码。[code lang=”java”]Process process = null; try{ process = Runtime.getRuntime().exec(&quot;su&quot;); //这里是主要程序代码ATAAW.COM process.waitFor(); }catch(Exception e){ e.printStackTrace(); }finally { process.destroy(); }[/code]","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"android入门：zxing学习笔记（一）","slug":"android/android-e5-85-a5-e9-97-a8-ef-bc-9azxing-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0-ef-bc-88-e4-b8-80-ef-bc-89","date":"2012-11-15T02:11:11.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/2577/","link":"","permalink":"http://quanke.name/posts/2577/","excerpt":"","text":"对于刚开始学习android开发的童鞋们来说，若有一个简单而又全面的android工程能来剖析，那就是再好不过了，zxing就是不错得例子。 zxing的源码可以到google code上下载，整个源码check out 下来，里面有各个平台的源码，ios的，android的。当然我们需要的就是android代码。 将android的工程导入到eclipse中，导入完成后，eclipse会显示各种错误，这是缺少core文件夹里面的核心库文件所致，在project中创建文件夹core，再将zxing源码中得core文件夹下得代码导入进来，这样就可以了。 如果遇到unable resolved target-X，则是你的avd版本问题，可以在project.propertities修改target值。clean下就ok。 如上的都是zxing android代码分析的准备，下面的则是正式开始。 如上图：为整个android工程的代码，android入门就重这些代码着手。其中主要关注的是android，camera，encode，result文件夹。 程序启动的流程：加载main activity，在此类中创建CaptureActivityHandler对象，该对象启动相机，实现自动聚焦，创建DecodeThread线程，DecodeThread创建Decodehandler，这个对象就获取从相机得到的原始byte数据，开始解码的第一步工作，从获取的byte中解析qr图来，并解析出qr图中的字符，将这块没有分析的字符抛送到CaptureActivityHandler中handle，该类调用main activity的decode函数完成对字符的分析，最后显示在界面上（刷新UI，最好在UI线程里完成）。这样一个解析qr图的过程并完成。 下面具体分析整个过程。重点之处有main activity,camera. 程序启动的第一个activity便是：CaptureActivity,有点类似于c中的main函数，在此是main activity。这个acitvity做的主要的事便是：加载扫描各种条形码，二维码的一个界面，启动一个处理获取一维码二维码信息的线程，完成对于获取的图像信息进行解码，最后再将解码的信息显示在界面上。 完成界面的加载主要在于onCreate，和onResume函数中，这涉及到了一个activity的生命周期，以后再具体分析。首先调用onCreate，再调用onResume，在onResume中会判断这个activity是由什么启动的，可能是其他的app触发了，也可能是用户直接启动的。这样就初始化了三个变量，一是source，便是启动activity的源，一是decodeFormats，指出解码的方式，是qr，还是其他的等等，最后一个是：charactreset，即是对于这些生成qr图的字符的编码方式。若没有对core中得代码修改，用该程序解析GB2312编码的字符则会乱码。乱码的解决后面将提到。 界面的加载中有两个很关键的类。surfaceview 和 ViewFinderView，前面的是用来加载从底层硬件获取的相机取景的图像，后面的是自定义的view，实现了扫描时的界面，不停的刷新，并将识别的一些数据，如定位的点回调显示在界面上。 来自：http://www.cnblogs.com/liuan/archive/2012/01/05/2312714.html","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"迅速开始使用Cloud Foundry的入门文档.","slug":"other/e8-bf-85-e9-80-9f-e5-bc-80-e5-a7-8b-e4-bd-bf-e7-94-a8cloud-foundry-e7-9a-84-e5-85-a5-e9-97-a8-e6-96-87-e6-a1-a3","date":"2012-11-15T00:10:48.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/33755/","link":"","permalink":"http://quanke.name/posts/33755/","excerpt":"","text":"http://cloudfoundry-doc.csdn.net/","categories":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}],"tags":[],"keywords":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}]},{"title":"深度剖析CloudFoundry的架构设计","slug":"other/e6-b7-b1-e5-ba-a6-e5-89-96-e6-9e-90cloudfoundry-e7-9a-84-e6-9e-b6-e6-9e-84-e8-ae-be-e8-ae-a1","date":"2012-11-15T00:07:39.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/3386/","link":"","permalink":"http://quanke.name/posts/3386/","excerpt":"","text":"VMware在今年4月份突然发布了业内第一个开源的PaaS——CloudFoundry。发布至今的这几个月里，笔者一直关注它的演进，并从它的架构设计中获益良多，觉得有必要写出来与大家分享一下。 本文会分为两个部份：第一部份主要介绍CloudFoundry的架构设计，从它所包含的模块介绍起，到各部份的消息流向，各模块如何协调合作；第二部份会在第一部份的基础上，以如何在你的数据中心里面用CloudFoundry部署一个私有PaaS为目标，把第一部分介绍到的架构知识使用起来。 第一部份讲的很多内容，会引用Pat在10月12日的VMwareCloud Forum上面关于CloudFoundry架构的演讲。Pat是CloudFoundry Core的负责人，他的那次演讲很值得一听。如果你当时在场，并且理解他所说的内容，本部份可以选择直接跳过。我除了会把说的内容讲具体点外，不太可能可以讲得比他好。 一、架构及模块 从总体地看，CloudFoundry的架构如下： 这个架构图以及下文所用到的各模块架构图均来自Pat的PPT。从上图能够看到CloudFoundry主要有以下几大组件组成： 1、 Router：顾名思义，Router组件在CloudFoundry中是对所有进来的Request进行路由。进入Router的request主要有两类：首先是来自VMCClient或者STS的，由CloudFoundry使用者发出的，管理型指令。 例如：列出你所有apps的vmcapps，提交一个apps等等。这类request会被路由到AppLife Management组件，又叫CloudController组件去；第二类是外界对你所部署的apps访问的request。这部份requests会被路由到Appexecution，又或者叫做DEAs的组件去。所有进入CloudFoundry系统的requests都会经过Router组件，看到这里可能会有朋友会担心Router成为单点，从而成为整个云的瓶颈。 但是CloudFoundry作为云系统，其设计的核心就是去单点依赖，组件平行扩充，且可替代的以保证扩展性，这是CloudFoundry，甚至所有云计算系统的设计原则，后文会讨论CloudFoundry如何做到这点，目前只要知道，系统可以部署多个Routers共同处理进来的requests，但是Router上层的LoadBalance不在CloudFoundry的实现范围，CloudFoundry只保证所有的request是无状态的，这样就使上层均衡附载选择面非常非常大了，例如可以通过DNS做，也可以部署硬件的LoadBalancer，或者简单点，弄台ngnix作负载均衡器，都是可行的。 Router组件，目前版本是对nginx的一个简单封装。熟悉ngnix的朋友应该知道，它可以一个套接字文件（.sock文件）作为输入输出。所有安装CloudFoundry的Router组件服务器都会安装一个nginx，其ngnix.conf文件有以下配置： 从整体的来看，Router组件的结构如下： 外界httprequest进入CloudFoundry服务器，nginx会首先接到request，nginx通过sock与router.rb进行交互，于是真正处理请求的是Router组件。router.rb里面根据传入的url，用户名密码等，进行逻辑判断，到CloudController组件或者DEA组件取数据并且返通过与niginx连接的.sock文件返回。 router.rb是对nginx进行了逻辑封装。熟悉CloudFoundry的朋友肯定知道，CloudFoundry给每一个app分配了一个url访问，如果直接使用VMware所托管的CloudFoundry.com的话，那你的app的url可能就是xxx.cloudfoundry.com，无论通过命令给你的app扩展了多少个instances，都是从这个url访问的，这里面的url转换路由就是由router.rb实现的。 2、DEA(Droplet Execution Agency): 首先要解析下什么叫做Droplet。Droplet在CloudFoundry的概念里面是指一个把你提交的源代码，以及CloudFoundry配套好的运行环境，再加上一些管理脚本，例如Start/Stop这些小脚本全部压缩好在一起的tar包。还有一个概念，叫做Stagingapp，就是指制作上面描述这个包，然后把它存储好的过程。CloudFoundry会自动保存这个Droplet，直到你start一个app的时候，一台部署了DEA模块的服务器会来拿一个Droplet的copy去运行。所以如果你扩展你的app到10个instances，那这个Droplet就被会复制十份，让10个DEA服务器拿去运行。 下图是DEA模块的架构图： Cloud Controller模块（下面会介绍）会发送start/stop等基本的apps管理请求给DEA，dea.rb接收这些请求，然后从NFS里面找到合适的Droplet。前面说到Droplet其实是一个带有运行脚本的，带运行环境的tar包，DEA只需要把它拿过来解压，并即行里面的start脚本，就可以让这个app跑起来。到此，app算是可以访问，并start起来了，换句话说就是有这台服务器的某一个端口已经在待命，只要有request从这个端口进来，这个app就可以接收并返回正确的信息。 接着dea.rb要做些善后的工作：1、把这个信息告诉Router模块。我们前面说到，所有进入CloudFoundry的requests都是由Router模块处理并转发的，包括用户对app的访问request，一个app起来后，需要告诉router，让它根据loadbalance等原则，把合适的request转进来，使这个app的instance能够干起活；2、一些统计性的工作，例如要把这个用户又新部署了一个app告诉CloudController，以作quota控制等；3、把运行信息告诉HealthManager模块，实时报告该app的instance运行情况。另外DEA还要负责部份对Droplet的查询工作，譬如，如果用户通过CloudController想查询一个app的log信息，那DEA需要从该Droplet里面取到log返回等等。 3、CloudController：CloudController是CloudFoundry的管理模块。主要工作包括： a) 对apps的增删改读； b) 启动、停止应用程序； c) Staging apps（把apps打包成一个droplet）； d) 修改应用程序运行环境，包括instance、mem等等； e) 管理service，包括service与app的绑定等； f) Cloud环境的管理； g) 修改Cloud的用户信息； h) 查看Cloud Foundry，以及每一个app的log信息。 这似乎有点复杂，但简单的说，可以很简单：就是与VMC和STS交互的服务器端。VMC和STS与CloudFoundry通信采用的是restful接口，另一方面CloudController是一个典型的Rubyon Rails项目，从VMC或者STS接到JSON格式的协议，然后写入CloudController Database，并发消息到各模快去控制管理整个云。和其他ROR项目一样，CloudController的所有API可以从conf/routes.rb里看到。开放的Restful接口好处在于第三方应用开发和集成，企业在用CloudFoundry部署私有云的时候，可以通过这些接口来自动化控制管理整个Cloud环境。这部份内容将在第二部份论述。 下图是Cloud Controller的架构图： 图中Health Manager和DEA是外部模块，CCDatabase就是CloudController Database，这个是整个CloudFoundry不能做HP的地方。CloudController Database的并发性不会很多，应用级别的数据库访问是由底下的Service模块处理的，这个数据库存的是Cloud的配置信息。读操作主要来自DEA启动，作为初始化DEA的依据；以及healthmanager模块会从这里读取预期的状态信息，这部份数据会与从DEA得到的实际状态信息进行比对。 NFS是多个CloudController的共享存储，CloudController其中一个重要工作就是StagingApps。Droplets的存储是在集群环境的唯一的。而CloudController是集群运行，换言之，就是每一个控制Request可能由不同的CloudController处理，假设一个简单的用户场景：我们需要部署一个app到CloudFoundry中。我们在敲完那条简单的push命令后，VMC开始工作，在做完一轮的用户鉴权、查看所部署的apps数量是否超过预定数额，问了一堆相关app的问题后，需要发4个指令： 1．发一个POST到”apps”，创建一个app; 2．发一个PUT到”apps/:name/application”，上传app; 3．发一个GET到”apps/:name/”，取得app状态，看看是否已经启动； 4．如果没有启动，发一个PUT到”apps/:name/”，使其启动。 如果第2和第4步由不同的Cloud Controller来处理，而又无法保证他们能找到同一个Droplet，那第4步将会因为找不到对应的Droplet而启动失败。如何保证这一连串指令过来所指向的Droplet都是同一个呢？使用NFS，使CloudController共享存储是最简单的方法。但是这个方法在安全性等方面并不完美。在10月12日的VMwareCloud Forum上，Pat告诉我们下一版本的CloudFoundry这里将会有大调整，但是在那部份代码公开前，我不方便在这评价太多。 4、HealthManager: 做的事情不复杂，简单的说是从各个DEA里面拿到运行信息，然后进行统计分析，报告等。统计数据会与CloudController的设定指标进行比对，并提供Alert等。HealthManager模块目前还不是十分完善，但是CloudManage栈里面，自动化health管理、分析是一个很重要的领域，而这方面可以扩展的地方也很多，结合OrchestrationEngine可以使云自管理、自预警；而与BI方面技术结合，可以统计运营情况，合理分配资源等。这方面CloudFoundry还在发展之中。 5、Services:Cloud Foundry的Service模块从源代码控制上看就知道是一个独立的、可Plugin的模块，以方便第三方把自己的服务整合入CloudFoundry生态系统。在Github上看到service是与CloudFoundry Core项目vcap独立的一个repository，为vcap-service。Service模块其中设计原则是方便第三方服务提供商提供服务。在这方面CloudFoundry做得很成功，从Github上看，已经有以下服务提供：a)MongoDB; b) mysql; c) neo4j; d) PostgreSql; e) RabbitMQ; f) Redis; g)vBlob。基类都是放在base文件夹中。 第三方如果需要自己开发CloudFoundry的服务，需要继承改写它里面的两个基础类：Node和Gateway；而里面一些操作，如：Provision，可以在base的provisioner.rb基础上加入自己的逻辑，同样的还有Service_Error和Service_Message等。关于如何写自己的Service，ELC的博客会推出相应文章详细论述，并不在本文的讨论范围里面，从架构了解上来说，只要知道服务间的关系，知道个服务与base间透过继承关系来横向扩充，而CloudFoundry与apps调用Service是通过base来完成这一简单的架构方法即可。 6、NATS(Message bus): 从CloudFoundry的总架构图看，位于各模块中心位置的是一个叫nats的组件。NATS是由CloudFoundry的架构师Derek开发的一个轻量级的，支持发布、订阅机制的消息系统。Github开源地址是：https://github.com/derekcollison/nats。其核心基于EventMachine开发，代码量不多，可以下载下来慢慢研究。 CloudFoundry是一个多模块的分布式系统，支持模块自发现，错误自检，且模块间低耦合。其核心原理就是基于消息发布订阅机制。每个台服务器上的每个模块会根据自己的消息类别，向MessageBus发布多个消息主题；而同时也向自己需要交互的模块，按照需要的信息内容的消息主题订阅消息。譬如：一个DEA被加入CloudFoundry集群中，它需要向大家吼一下，以表明它已经准备好服务了，它会发布一个主题是”dea.start”的消息： @ hello_message_json中包括DEA的UUID,ip, port, 版本信息等内容。 再例如，CloudController需要启动一个Droplet的instance： a)首先一个DEA在启动的时候，会首先会对自己UUID的消息主题进行订阅。 其他模块需要通过’’dea.#{uuid}.start”这个主题发送消息来使它启动，一旦这个DEA接收到消息，就会触发process_dea_start(msg)这个方法来处理启动所需要的工作。 b)Cloud Controller或者其他模块发送消息，让UUID为xxx的DEA启动。 c)DEA模块接收到消息后，就会触发process_dea_start(msg)方法。msg是由其他模块发送过来的消息内容，包括：droplet_id,instance_index, service, runtime等内容，process_dea_start会取得这些启动DEA必须的信息，然后进行一系列操作，例如从NFS中取得Droplet，解压，修改必要环境配置，运行启动脚本等等。等一切都准备好后，然后需要给Router发个消息，告诉它这个Droplet已经随时准备好报效国家，以后有相应的request记得让它来处理。 d)Router模块在启动时就已经订阅”router.register”消息主题。 收到前面DEA发出的信息后，会触发register_droplet方法，去绑定Droplet。到此启动一个Droplet的instance工作完成。 我们可以看到整个CloudFoundry的核心就是一套消息系统，如果想了解CloudFoundry的来龙去脉，去跟踪它里面复杂的消息机制是非常好的方法。另一方面，CloudFoundry是一套基于消息的分布式系统，面向消息的架构是它节点横向扩展，组件自发现等云特性的基础。 Cloud Foundry的架构简单介绍至此，其实作为第一款开源的PaaS，CloudFoundry架构有很多可以学习借鉴的地方，很多细节上的处理是很精妙的，这些内容如果有可能会在后续文章继续探讨，本文题虽为深入CloudFoundry，其实也只是浅尝即止，把总体架构介绍一下，目标在于使我们有足够的背景知识去用CloudFoundry搭建企业内部的私有PaaS。总结一下，笔者从CloudFoundry的结构中学到的东西： 1、基于消息的多组件架构是实现集群的简单、且有效方法。消息可以使集群节点间解耦，使自注册，自发现这些在大规模数据中心中很重要的功能得到实现； 2、适当的抽象层，模板模式的使用，方便第三方可以方便在CloudFoundry开发扩展功能。CloudFoundry在DEA及Service层都做了抽象层处理，相对应地使开发者可以容易地为CloudFoundry开发Runtime和Service。例如，在CloudFoundry刚推出的时候，只支持Node.js,Java, Ruby，但第三方提供商、开源社区快速跟进，为CloudFoundry添加了PHP,Python的支持。这得益于CloudFoundry精巧的DEA架构设计，如何开发新的Runtime支持，会在后续博文中有所论述. 二、源码导读 笔者一直觉得深入理解一个技术的最好方法就是读它的源码，而CloudFoundry是完全开源的PaaS平台，而因为刚发展起来，代码量不多，主要作者们的代码功力也相当不错，读起来很舒服，很适合研读。而不得不再次表扬一下它完全基于消息机制的架构设计，对组件扩展性，第三方接入等方面做得很好，读者可以从中学到不少思想性的东西。笔者很推荐大家去读一下它的源代码。你可以在Github上找到CloudFoundry的全部代码：https://github.com/cloudfoundry，你会看到几个不同的Repositories，它们分别是： 1、vcap: Cloud Foundry的Core，又或者称作Kernel； 2、vcap-service: Cloud Foundry的Service组件。Cloud Foundry的service是作为插件提供的，这出于它方便第三方开发service而设计的； 3、vmc: VMware Cloud CLI. 是一个Ruby应用，与Cloud Foundry的CLI交互。主要通过分析用户输入的CLI，向CloudFoundry发送Restful请求； 4、vcap-java: 如果你的app是用java开发，且需要与Cloud Foundry交互，例如取得当前serviceserver的ip地址等，你可能需要这个jar，里面对我们Java开发常用框架有所支持，它底层也是对CloudFoundry的Restful请求的包装； 5、vcap-java-client: Cloud Foundry的Restful API的Java封装，与上面的项目不一样，它只是个简单的读取CloudFoundry信息，并放如JavaBean中； 6、vcap-test: Cloud Foundry的test cases; 7、vcap-test-assets: Cloud Foundry一些apps示例。 原文链接：http://qing.weibo.com/2294942122/88ca09aa330004r8.html","categories":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}],"tags":[],"keywords":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}]},{"title":"Paas","slug":"tools/paas","date":"2012-11-14T23:55:06.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/43816/","link":"","permalink":"http://quanke.name/posts/43816/","excerpt":"","text":"PaaS是Platform-as-a-Service的缩写，意思是平台即服务。Paas - 概述 计算机技术 PaaS（Platform-as-a-Service：平台即服务） 全称:(Platform as a service) 中文: 平台即服务 PaaS的优势(1张) 所谓PaaS实际上是指将软件研发的平台（计世资讯定义为业务基础平台）作为一种服务，以SaaS的模式提交给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。在2007年国内外SaaS厂商先后推出自己的PAAS平台。 PAAS之所以能够推进SaaS的发展，主要在于它能够提供企业进行定制化研发的中间件平台，同时涵盖数据库和应用服务器等。PAAS可以提高在Web平台上利用的资源数量。例如，可通过远程Web服务使用数据即服务（Data-as-a-Service：数据即服务），还可以使用可视化的API，甚至像800app的PAAS平台还允许你混合并匹配适合你应用的其他平台。用户或者厂商基于PaaS平台可以快速开发自己所需要的应用和产品。同时，PaaS平台开发的应用能更好地搭建基于SOA架构的企业应用。 此外，PAAS对于SaaS运营商来说，可以帮助他进行产品多元化和产品定制化。例如 Salesforce的PAAS平台让更多的ISV成为其平台的客户，从而开发出基于他们平台的多种SaaS应用，使其成为多元化软件服务供货商（Multi Application Vendor），而不再只是一家CRM随选服务提供商。而国内的SaaS厂商800app通过PAAS平台，改变了仅是CRM供应商的市场定位，实现了 BTO(Built to order:按订单生产)，和在线交付流程。使用800app的PAAS开发平台，用户不再需要任何编程即可开发包括CRM、OA、HR、SCM、进销存管理等任何企业管理软件，而且不需要使用其他软件开发工具并立即在线运行。 面向个人的EC站点(electronic commerce site)的巨头公司 Amazon，把最初为了自己公司的运营用的构筑起来的系统平台，进行出租，用户可以自由选择操作系统和中间软件，以这样的方式提供硬件以及软件平台作为服务，最初被海外以一些冒险事业的企业所使用。从2006年开始 [Amazon EC] [Amazon S3]开始作为服务推向市场。 还有现代软件业霸主同时又是次时代计算的先驱的Google,大家都知道在世界上构筑以及运行了非常多的数据中心。以搜索引擎以及新的广告模式而闻名。他们使用便宜的计算机和强有力的中间件，以及自己的技术装备出了世界上最强大的数据中心，以及超高性能的并行计算群。 2008年4月发表的PaaS服务[Google App Engine]和Amazon 的 EC2,S3,SimpleDB等服务拥有相似的功能。这些稳定的平台上同样搜索引擎，GMail等服务也在运行。同样以ASP~SaaS成功的Salesforce，2007年开始用于提供SaaS的系统基盘对外公开，用Force这个名称开始进入PaaS业务。他所提供的PaaS服务里采用Java类似的语言Apex以及Eclipse开发平台，整合的开发环境也作为服务进行提供(Development as a Service)。Google/Amazon/Salesforce这三个软件巨头非常的重视PaaS这种新的商业模式，Amazon的PaaS服务为了用户可以自由的组合服务提供了更多的自由度，Google的话提供了更多的服务使用户能够方便的使用，去掉了一些繁琐的作业。Google/Salesforce的PaaS不仅是基础硬件的提供开发环境的同样被提供属于真正的平台作为一种服务(PaaS)Paas - APaaS和IPaaS 简单的说，PaaS平台就是指云环境中的应用基础设施服务，也可以说是中间件即服务。PaaS平台在云架构中位于中间层，其上层是SaaS，其下层是IaaS。在传统On-Premise部署方式下，应用基础设施即中间件的种类非常多， 有应用服务器，数据库，ESBs, BPM, Portal, 消息中间件，远程对象调用中间件等等。对于PaaS平台，Gartner把它们分为两类，一类是应用部署和运行平台APaaS（application platform as a service)，另一类是集成平台IPaaS（integration as a service）。 人们经常说的PaaS平台基本上是指APaaS，如Force.com和Google App Engine。 Paas - 公有云PaaS平台和企业级PaaS平台 云计算起源于大型互联网企业。对于互联网企业，成本压力和指数级的业务增长压力使他们关注于物理资源的利用率和应用的可扩展性。在应用服务器这层，通过Cluster Session来实现水平扩展；在数据存储这层，采用基于BASE模型的NOSQL数据存储来实现扩展。目前互联网企业主导面向公众服务的公有云PaaS平台，如Google App Engine和Amazon Beanstalk。对于公有云PaaS平台，PaaS就是云环境下的应用部署平台。（1）基于商业软件的部署方式：Application - Framework/Libs - Websphere/Weblogic + RMBMS（2）基于开源软件的部署方式：Application - Frameworks/Libs - Tomcat/JBoss + RDBMS（3）云环境下的部署方式：Application - Frameworks/Libs - PaaS(Goole App Engine, Amazon) 这种情况下，PaaS实质上就是一个预先装好的Web Container和一组公共服务，如数据存储服务(不一定是关系型数据库)、消息队列、集中式session及cache等等。对于个人用户或者简单应用来说，公有云PaaS平台使得开发人员仅关注应用逻辑开发本身，不用把精力花费在基础实施和应用的扩展和维护上。 所谓企业级PaaS平台，主要包含两类，一是大型企业内部的私有云PaaS平台，另一类是面向ISV厂商的PaaS平台。然而对于企业级PaaS平台，PaaS不仅仅是云环境下的应用部署平台。 抛开安全问题不讲，私有云PaaS平台和公有云PaaS有如下核心区别：（1）复杂的多租户模型：对于公有云PaaS平台，其租户模型是 （用户-&gt; 应用 -&gt; 应用实例），一个用户可以部署多个应用，每个应用可以有多个运行时实例，应用实例共享资源池。对于一个大型企业，一个大部门可能是一个租户，大部门下面的子部门也是一个租户；或者一个SaaS应用系统的一个实例就是一个租户。对于租户的资源使用，大部门租户是共享资源池里面的资源，也可能某些关键租户需要独占一些资源以保证安全。（2）已有应用的兼容：企业的历史应用都是基于关系型数据库的，某些PaaS平台不支持关系型数据存储，即使是简单的已有应用都无法迁移到PaaS平台上。（3）复合应用的构建: 企业On-Premise应用在很长一段时间内都是要存在的，私有云PaaS平台要成为On-Premise和公有云之间的桥梁。私有云PaaS平台除了是应用部署平台外，还需要提供集成和方便构建复合应用的能力，就是Gartner所提的iPaaS能力。 企业级PaaS平台不仅仅是应用部署平台，而且是复杂多租户环境和复杂应用环境下的共享基础设施平台，是On-Premise部署通往公有云部署的必经之路。 CloudTao PaaS平台是国内第一个企业级PaaS平台，其构建原则是：（1）开放、简单、一致、轻量的架构 - 构建平台的核心是标准，aPaaS的核心是应用运行时环境及数据存储服务，标准是Servlet和SQL，但PaaS平台需要的是 这两个标准的轻量级实现。（2）细粒度的资源隔离 - 在多租户的实现方面，介于基于虚拟机的隔离与共享一切资源之间，在资源利用率、安全、可扩展性几个方面中取得平衡。（3）真正的跨平台及分布式架构 - CloudTao只依赖于JVM，无单点故障，可实现水平线性扩展。（4）对历史应用的兼容 - 已有应用无需改动或者极少改动即可迁移至PaaS平台，从而共享PaaS平台资源并可以容易的扩展。 CloudTao PaaS平台的主要技术特性是：（1）多层次的多租户实现 - 多层次的多租户能够满足不同的应用场景，能够满足各种不同的企业/ISV需求。（2）支持不同类型的数据存储 - 支持关系型数据库及NOSQL数据存储。对于关系型数据库，能够实现轻量级多租户关系型数据库系统至传统关系型数据库的平滑迁移。（3）开发SDK - 基于Maven的本地开发SDK，提供自定义插件方便开发人员部署和调试应用。（4）统一监控及计量 - 监控应用的运行情况，JVM运行时信息，系统资源消耗，日志及HTTP请求处理统计等。","categories":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}],"tags":[],"keywords":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}]},{"title":"android 界面适配处理记录","slug":"android/android-e7-95-8c-e9-9d-a2-e9-80-82-e9-85-8d-e5-a4-84-e7-90-86-e8-ae-b0-e5-bd-95","date":"2012-11-14T21:41:16.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/16209/","link":"","permalink":"http://quanke.name/posts/16209/","excerpt":"","text":"android 界面琐碎，各种分辨率，各种destiny 当然,按照官方的处理方法，图片可以分别准备几套分辨率不同的图片放几个drawable 文件夹下，而不同的界面布局也可以写几套xml 分别放于不同的llayout 文件夹下，当图片比较多时，达到几兆或者更大，上面的处理方法会让apk变得很大，显的很冗余。写xml文件时，我们一般采用相对分辨率dip ，dip与像素之间的转化公式不知道的大家可以查下，这里就不说了px = dip*destiny/160 destiny 是每英寸的像素点数这几个参数可以手动计算，也可以通过程序获得，虽然目前几种获取屏幕参数的方法在几种设备上，各种山寨非山寨得出的准确性有待考究。在淘宝的热卖手机中取了几个参数，目前市面常见的手机或者说销量高的手机， 按照上面的公式把像素转化为dip ，由于一般的手机的分辨率 长宽比还是比较接近的，所以测出虽然手机的destiny从210到300不等（题外话：其实300已经接近或超出人眼能识别的极限了）但算出来 x轴即横线dip一般大于320 位于320 到370 之间，纵向640左右，，所以写xml时可以把处理的面积设成 320 *620 左右，再适当的调整 ，而对于图片较多，其实可以选相对适中的分辨率 图片，然后涉及到图片的控件吧相应属性设置如下android:layout_width=”20dip”android:layout_height=”20dip”android:scaleType=”fitCenter”后面的数值可调，看你想要的大小， 这样图片会自动居中填满你指定的区域，一般手机是没问题（其实也就随便找了3部手机测了测）。对于实在前面算出的横向和纵向分辨率大的 ，可以在java层一开始读取xml文件之前判断一下 读取不同的xml文件，至于图片要求不是特别高清的，上面的处理其实程序自动伸缩的 效果就可以了，当然 你可以测试下。当然有特别要求的图片 可以相应的放不同的文件夹（没测过），这样，至少减少图片的数量 xml文件的数量 处理起来比较简单，当然pad没做相应调查，目前也值做了手机的适配。只是今天突然有点忘记，记录一下，不知道的了解下，知道的 一笑而过就好了","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"android 屏幕适配问题","slug":"android/android-e5-b1-8f-e5-b9-95-e9-80-82-e9-85-8d-e9-97-ae-e9-a2-98","date":"2012-11-14T21:29:23.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/56812/","link":"","permalink":"http://quanke.name/posts/56812/","excerpt":"","text":"如何将一个应用程序适配在不同的手机上，虽然这不算是一个技术问题，但是对于刚刚做屏幕的开发人员来说，还真不是一件多么简单的事情。 首先：你需要在AndroidManifest.xml文件的元素如下添加子元素[code lang=”xml”]&lt;supports-screens android:largeScreens=&quot;true&quot; android:normalScreens=&quot;true&quot; android:anyDensity=&quot;true&quot; android:smallScreens=&quot;true&quot;&gt;&lt;/supports-screens&gt;[/code] 名如其意，以上是为我们的屏幕设置多分辨率支持（更准确的说是适配大、中、小三种密度）。android:anyDensity=&quot;true&quot; ，这一句对整个的屏幕都起着十分重要的作用，值为true，我们的应用程序当安装在不同密度的手机上时，程序会分别加载hdpi,mdpi,ldpi文件夹中的资源。 相反，如果值设置为false，即使我们在hdpi,mdpi,ldpi文件夹下拥有同一种资源，那么应用也不会自动地去相应文件夹下寻找资源，这种情况都是出现在高密度，以及低密度的手机上，比如说一部240×320像素的手机，如果设置android:anyDensity=”false”，Android系统会将240 x 320(低密度)转换为 320×480(中密度)，这样的话，应用就会在小密度手机上加载mdpi文件中的资源。 2.细心的人会发现自android2.0开始之后drawable文件被三个文件夹drawable-hdpi,drawable-mdpi,drawable-ldpi三个文件夹所取代，有些编程人员为了让应用程序默认地加载某些图片，他们会特意地去在android2.0之后的应用程序中重新创建drawable文件夹，其实这样做完全没有必要，通过第一段的分析我们得知，android:anyDensity=”false”，则应用会将大小密度转变成中密度，从而去加载mdpi中的资源。这里同样，当android:anyDensity=”false”，则应用会去加载mdpi中的资源。 总结一下： 第一：android:anyDensity=”true”，系统会依据屏幕密度，自动去找对应的文件夹 第二：android:anyDensity=”false”, (1) 如果drawable-hdpi,drawable-mdpi,drawable-ldpi三个文件夹中有同一张图片资源的不同密度表示，那么系统会去加载drawable_mdpi文件夹中的资源 (2) 如果drawable-hpdi中有高密度图片，其它两个文件夹中没有对应图片资源，那么系统会去加载drawable-hdpi中的资源。 (3) 如果drawable-hdpi,drawable-mdpi中有图片资源，drawable-ldpi中没有对应的图片资源，那么系统会加载drawable-mdpi文件夹中的资源 3. 注意上图各种文件夹的不同表示。 drawable-hdpi 该图片即适用于横屏，也适用于竖屏 drawable-land-hdpi,当屏幕为横屏，且为高密度时，加载此文件夹中的资源 drawable-port-hdpi,当屏幕为竖屏，且为高密度时，加载此文件夹中的资源 3. 有时候会根据需要在代码中动态地设置某个值，比如地图，地图的pin和地图的地址提示框的相对偏移量在不同密度的手机上是不同的。这时候可以通过以下方法求出屏幕密度： [code lang=”java”]DisplayMetrics metric = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(metric); int densityDpi = metric.densityDpi; // 屏幕密度DPI（120 / 160 / 240） [/code] 然后可以在代码中为这几种密度分别设置便宜量 但是这种方法最好不要使用，最好的方式是在xml文件中不同密度的手机进行分别设置。 这里地图的偏移量可以在values-hpdi,values-mdpi,values-ldpi三种文件夹中的dimens.xml文件进行设置 值得一提的是： &lt;dimen name=&quot;bitmap_common_topoffset&quot;&gt;40dp&lt;/dimen&gt; &lt;dimen name=&quot;bitmap_common_bottomoffset&quot;&gt;-14dp&lt;/dimen&gt; 这里的负数是完全起作用的，系统会认为它是一个负值 4. 各大手机厂商对于Android操作系统都有或多或少的改动，当然这些改动会对我们应用程序产生某些影响 比如： （1）系统源代码中连接music服务的aidl文件所在包名：com.android.music （2）LG则可能将该aidl文件修改所在的包（例如修改为 com.android.music.player），并且修改其中的文件内容（增加一个方法，或者减少几个方法，或者修改方法名称）那么我们的应用要想在LG的手机上发布，那么我们就必须改变所要连接的aidl文件,必须跟LG厂商修改的完全一致。 5. 国际化问题. 有时候在xml中设置了相应的语言，但是为什么当我们更改语言之后，UI显示仍然不起作用？ 不要怀疑是系统出了问题，这与我们在代码中引用values/string.xml中字符串的方式有关。 错误的方式： 1. 声明全局变量 private static String tempStr; 2. 在onCreate方法中对该变量赋值 tempStr = context.getString(R.string.test); 3. 在更新UI的方法（非onCreate方法）中引用该变量。 textView.setText(tempStr); 原因是由于，当修改本地语言时，onCreate不会再被执行一遍. 变量tempStr 依然会使用页面刚启动时加载的默认英语。 正确的方式： 直接进行第三步：textView.setText(context.getString(R.string.test));","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"AHK 懒人包 – AutoHotKey 汉化版 + 教程","slug":"tools/ahk--autohotkey","date":"2012-11-13T01:48:50.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/1029/","link":"","permalink":"http://quanke.name/posts/1029/","excerpt":"","text":"标题已经告诉你大部分了。我要告诉大家的是，小众软件出品的 AHK 懒人包中有什么好东西。哈哈。 打包了连载于小众软件和煎蛋的全部 AHK 快餐店教程。 快餐店教程的全部脚本，在文中脚本这个文件夹里。 AutoHotKey 汉化版 由 BLooM2 制作。我从官方下载了最新的 AutoHotKey 整合在 AutoHotKey 中文版的文件夹里。 还附上了 ahk 中文论坛翻译的 AutoHotKey 帮助文件，AutoHotkey 1.0.48.05准中文版(已增加搜索和书签功能) 下载(3.4 MB): Go Everbox | Downdao | baidu | 官方网站 | 来自小众软件","categories":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}],"tags":[],"keywords":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}]},{"title":"Android 之ExpandableListView几个特殊的属性","slug":"android/android-e4-b9-8bexpandablelistview-e5-87-a0-e4-b8-aa-e7-89-b9-e6-ae-8a-e7-9a-84-e5-b1-9e-e6-80-a7","date":"2012-11-12T02:17:22.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/65447/","link":"","permalink":"http://quanke.name/posts/65447/","excerpt":"","text":"1. 设置ExpandableListView 默认是展开的:先实例化 exListView然后 exListView.setAdapter(exlvAdapter); //遍历所有group,将所有项设置成默认展开 int groupCount = exListView.getCount(); for (int i=0; i&lt;groupCount; i++) { exListView.expandGroup(i); }; 2. 去掉ExpandableListView 默认的箭头 用到ExpandableListView时有个箭头图标系统自带的在你自定义布局也不能去掉只要设置一个属性即可，如下： settingLists.setGroupIndicator(null); ~~~~~此处就是设置自定义的箭头图标的。置空则没有了。 也可以自定义（但是位置还是在那个地方不推荐）如下：首先，自定义一个expandablelistviewselector.xml文件，具体内容如下：Java代码&lt;?xml version=”1.0” encoding=”utf-8”?&gt; 加一句代码如下：settingLists.setGroupIndicator(this.getResources().getDrawable(R.layout.expandablelistviewselector));大功告成3. 将默认的箭头修改到右边显示: 1首先 ExpandableListView elistview; elistview.setGroupIndicator(null);//将控件默认的左边箭头去掉，2在 自定义的继承自BaseExpandableListAdapter的adapter中有一个方法/** 父类view*/ @Override public View getGroupView(int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) { Log.i(&quot;zhaoxiong&quot;,&quot;parent view&quot;); LinearLayout parentLayout=(LinearLayout) View.inflate(context, R.layout.wowocoupons_parent_item, null); TextView parentTextView=(TextView) parentLayout.findViewById(R.id.parentitem); parentTextView.setText(parentlist.get(groupPosition)); ImageView parentImageViw=(ImageView) parentLayout.findViewById(R.id.arrow); //判断isExpanded就可以控制是按下还是关闭，同时更换图片 if(isExpanded){ parentImageViw.setBackgroundResource(R.drawable.arrow_down); }else{ parentImageViw.setBackgroundResource(R.drawable.arrow_up); } return parentLayout; }","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android EditText得到和失去焦点时，自定义处理内容","slug":"android/android-edittext-e5-be-97-e5-88-b0-e5-92-8c-e5-a4-b1-e5-8e-bb-e7-84-a6-e7-82-b9-e6-97-b6-ef-bc-8c-e8-87-aa-e5-ae-9a-e4-b9-89-e5-a4-84-e7-90-86-e5-86-85-e5-ae-b9","date":"2012-11-12T02:00:34.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/52157/","link":"","permalink":"http://quanke.name/posts/52157/","excerpt":"","text":"当android的Edittext得到/失去焦点时，需要自定义一些处理内容时，需要对EditText对象的Focus进行监听处理。在Activity中，做以下处理：1.取得EditText对象。2.为取得的对象添加setOnFocusChangeListener()，重写里面的方法。如下：[code lang=”java”]EditText loginPwd = (EditText) findViewById(R.id.editText);editText.setOnFocusChangeListener(new android.view.View.OnFocusChangeListener() { @Override public void onFocusChange(View v, boolean hasFocus) { if(hasFocus) {// 此处为得到焦点时的处理内容} else {// 此处为失去焦点时的处理内容} }});[/code]","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"如何让edittext在activity起始的时候不自动获得焦点？","slug":"other/e5-a6-82-e4-bd-95-e8-ae-a9edittext-e5-9c-a8activity-e8-b5-b7-e5-a7-8b-e7-9a-84-e6-97-b6-e5-80-99-e4-b8-8d-e8-87-aa-e5-8a-a8-e8-8e-b7-e5-be-97-e7-84-a6-e7-82-b9-ef-bc-9f","date":"2012-11-11T23:57:30.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/45580/","link":"","permalink":"http://quanke.name/posts/45580/","excerpt":"","text":"在AndroidManifest.xml里的Activity定义里添加进这个属性[code lang=”xml”]android:windowSoftInputMode=&quot;adjustResize|stateHidden&quot;[/code]或者在onCreate 里添加进[code lang=”java”]getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED);[/code]有时候在某些手机上只添加stateHidden也许无效，需要加入下面这段 EditText始终不弹出软件键盘例：EditText edit=(EditText)findViewById(R.id.edit);edit.setInputType(InputType.TYPE_NULL); 让EditText失去焦点，使用EditText的clearFocus方法例如：EditText edit=(EditText)findViewById(R.id.edit);edit.clearFocus();","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"[转]一个当了爹的程序员的自白","slug":"other/e8-bd-ac-e4-b8-80-e4-b8-aa-e5-bd-93-e4-ba-86-e7-88-b9-e7-9a-84-e7-a8-8b-e5-ba-8f-e5-91-98-e7-9a-84-e8-87-aa-e7-99-bd","date":"2012-11-09T21:19:43.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/65152/","link":"","permalink":"http://quanke.name/posts/65152/","excerpt":"","text":"我喜爱我的工作，我喜爱我的事业，我喜爱解决难题，我喜爱开发漂亮的软件。这些仅仅次于我对我的小女儿的喜爱。 前几年年轻些时，我是一个到公司最早，编一天的程序，最后一个离开公司的程序员，回到家后上网，继续编程，直到深夜。开发什么并不重要，我只是想编程。然后一件奇妙的事情发生了。我和老婆有了一个孩子。 当知道珍妮怀孕了后，我欣喜若狂。并不是因为得到这样的一个结果是一个不容易的过程，而是我一直都想要个孩子。我想做一名父亲。不，我想当一名好父亲。我发誓，我向我未出生的孩子发誓，我将会是，最起码，是一个一直在她身边，只属于她的好父亲。 对于这样的诺言，你可能会想“哪你还去不去工作了？程序员这种以咖啡因做动力、经常加班加点、动不动就最后决战的职业是不允许你以一句‘我要回家和孩子一起吃饭‘就能应付的。”的确是这样。对于我，这是一个”什么更重要”的问题，我有一个简单的理由：如果你把工作搞砸了，你总可以再找另外一个工作，但如果你把家庭关系搞砸了，特别是跟孩子的关系，你永远无法弥补，你会一辈子背负这个债务。 所以，我的选择是，每天都要在家里花些时间陪我的女儿，即使是这样做对我的事业有负面的影响。我每天早上6：30-6：45到公司，结结实实的工作9小时，下午4点钟左右离开公司回家。从4：30到7：30的时间是专享的，它属于我的女儿。这样做了之后，最难处理的部分是，和我一起工作的很多人是在西海岸的(从时区习惯上，他们比我们会晚几个小时)，很自然，他们经常会把会议时间安排在太平洋标准时间的下午2点或3点。这直接跟我设定的和我的女儿一起玩耍的时间有冲突，所以，我会尽量要求重新安排这样的会议，或直接不参加。当然，我会尽量照顾到工作，如果有事情是非常的重要，我还是会到场的，不论是什么时间。我是非常坚持我的作息安排，原因就是我上面提到过的思想认识。一旦把女儿放上来床，我就可以和妻子一起自由安排余下的时间，有必要的话也会开发点程序。在晚上8点或9点被打电话去和西海岸的团队开会的事情再也没有发生过。 起初，留下我的兄弟们在公司干活，我却独自回家，这让我内疚很多。尤其是在一次工作互查的过程中有人反馈说，作为一个团队的领导，当团队不得不加班时，领导最好也应该随团队一起加班。但是，如果你看一下我的时间分配，每天超过9小时花在工作上，只有3小时留给我的女儿。如果有人说这不公平，那这最不公平的是对我的女儿。 这样做了之后，我发现，离开键盘一段时间，反而会增加我的工作效率。我回到家，和女儿玩耍，吃完饭，给她洗澡，给她读童话，抱她上床。所有的这些时间里，我的大脑并没有停止，潜意识里仍在整理分析遇到的问题，思索解决的方案。有大量的科学研究表明，当你想解决一个难题时，停下来休息一下是对你解决这个问题有好处的。加之，有些事情是可以提振你的精神的，比如和一个2岁的孩子玩耍。 的确，我的代码的产出量不再向以前那样丰硕，一定程度上是因为这些日子里我更多的把时间花在指导上，但同时也是因为我的代码写的更精简、更好了。 我发现的另外一个好处是，我不再有筋疲力尽的感觉了。赶任务、加班加点给你带来的危害很大。如今，我来到公司，精神饱满、思路清晰，能扎扎实实的工作。但你每天工作20小时的疯狂加班时，实际上只有很少的时间是有效率的(甚至完全没有效率！)疲劳过度后你的大脑是混沌的，除了工作做不好，工作之外的所有事情都会受到影响。更糟糕的是，这种影响还会自我放大。因为你想拼命的完成一个需求不合理或计划评估错误的项目,你必然会弄得精疲力竭，这样又会导致你在下一个计划上完不成任务而加班加点，你进入了一个恶性循环。 即使你没有像我这样好的理由，你也要严格限制你的加班加点。你甚至会发现，当拿出一些时间花在一些有益的业余爱好上后，你的工作反而会做的更好。如果你对我的建议感兴趣，那就买一本37signals公司的那个家伙写的Rework(重来)这本书。里面有很多这方面的东西。","categories":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}],"tags":[],"keywords":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}]},{"title":"真希望我第一次创业时就知道的事","slug":"other/e7-9c-9f-e5-b8-8c-e6-9c-9b-e6-88-91-e7-ac-ac-e4-b8-80-e6-ac-a1-e5-88-9b-e4-b8-9a-e6-97-b6-e5-b0-b1-e7-9f-a5-e9-81-93-e7-9a-84-e4-ba-8b","date":"2012-11-09T17:35:41.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/44941/","link":"","permalink":"http://quanke.name/posts/44941/","excerpt":"","text":"我们常常事后诸葛亮。当你回头看看之前做过的项目或努力，你总能更好地意识到什么事重要、什么事不重要。 在创业上也是一样的。在一项事业上奋斗了一两年或更多的时间后，你总能更好地意识到一些事是值得担心的，而另一些事其实没什么大不了。 既然创业者是最有资格给其他创业者在如何开始创业上提供建议的，我决定去问25名创业者同一个问题：你希望当年第一次创业时就已经了解的事是什么？而下面是就是这个问题的集合。或许这对刚刚开始创业或正在准备创业的你会有价值： Dan Martell Clarity创始人： 在开始时，你很可能不知道怎样把事情做对，这其实没什么关系。 直到我真正着手创业时，我才意识到实际上并不需要在一开始就知道该怎么做——你需要的只是学会快速地把正确答案给找出来。如果你能够专注于学习并获取正确的建议——那你将可以接受任何挑战。一旦你意识到这点，你会感到解放。Neil Patel Crazy Egg联合创始人：我希望我当时能知道怎么做定价测试。当我们第一次发布产品时，我们的定价是基于我们自己想要的定价，而实际上优化价格可以达到最大收入和利润。 我们的顾客群当时要求价格低一些，因为他们的这个需求很旺，我们照做了。尽管这么做增加了整体的注册人数，但我们的整体收入减少了。如果我们能在当时知道定价测试，我们就不会犯这么大的错误。Nick Francis Help Scout的CEO兼联合创始人：我希望我当时能够知道，获得一名顾客、让他为你的产品买单并且像你所希望的觉得产品很棒是一件很难的事。 大部分的创始人都将获得顾客作为预料中的结局，而实际上要达到所预想的顾客数，最短可能都需要两到三年。这个过程的每个环节对公司来说都是巨大的挑战。不会这么快就实现。 在早期顾客获得上的一些小建议： 1）和目标市场中愿意和你聊的每个人都聊一聊。要比他们自己更了解他们的需求。你最有价值的洞察将会来自每天和顾客的聊天。 2）对潜在顾客进行营销是一系列的实验。在你开始之前，先定义好成功和失败分别是怎样。当实验完成，就可以往复进行了。 3）你周围的团队成员和顾问会追究你的业务度量和财政情况。业务的成功和失败取决于这些人。你需要完全地信任他们，因为你没时间去做监视。Allan Branch ，LessAccounting联合创始人：我和我的商业伙伴Steve Bristol在创业的头一年里花了大量的时间在工作上。我们曾经每周工作80小时以上。这样的工作让我们身心疲惫，也让我们意识到，即使我们花了40 x 2的时间，公司也不会因此增速2倍。事实上，我们那额外的40小时比头40小时的效率要低。而且根本就不会有完成工作的时候，你永远都完不成所有测试，所有的功能，完成完美的设计。最后一次在将近凌晨4点的时候，我们合上了笔记本，回家。永远不要忘记，工作是为了让你的个人生活更有收获的一部分。 而且我也不再关心我会不会变得有名，不去想自己是否会变得极其富有或能上封面杂志。我更在意怎么让我们的顾客和员工感到开心。而在我变得出名时，我唯一担心的人就是我的孩子和妻子。即使现在32岁了，我依旧努力让我的父母为我感到骄傲。但我已经卸下了要将公司做成价值5亿美元公司的负担，我也为我成为这家不知名软件公司的创始人搞到高兴。 其他小建议： 1）只招那些你会希望在个人时间里愿意和他相处的人 2）前十位员工会决定整个公司的基调。 3）不要招那些因为工资而和你一块工作的人Leo Widrich Buffer联合创始人：我最希望自己在创业时就能了解的事，是你周围的人会比你所想象得更能影响你的成功。看看你每天日常工作中和谁一起，和那些实干家一起工作会成就你的事业并且让你有更重要的自我提升，而和空谈家一块只会毁掉你。所以要精挑细选地招人，就像Jim Robn说过的：“你，是你最常待在一起的五个人的平均值。”Renee Warren，Onboardly的联合创始人：我希望我当时可以更好的了解我时间的价值。一场10分钟的聊天常常会变成非常漫长的聊天，而且你很容易就答应去这么做。我花了好几年的时间，才学会拒绝那些会分散我注意力的事。拒绝开会、拒绝采访并且拒绝额外的项目（额外的钱）。当我完成了我每天的任务列表后，我的整天、整周、整个月都变了。在我完成工作之后，我才会接受那些机会。 而这些意识来自我的爷爷，他曾经跟我说“如果你不提早10分钟，你就会迟到10分钟。”他这么说的原因有很多，可能意味着出席会议、赶飞机、打电话、去健身等等。 总而言之，我最希望我在创业时就能了解的事就是：时间是你最宝贵的一样东西，请确保你的时间投资是明智的。Poornima Vijayashankar ，BizeeBee联合创始人兼CEO：我知道开发产品需要时间，但我也希望我在当时就能够知道，让用户接受一个产品也需要时间。尽管你可能会有一些执着使用你产品的早期用户，但主流的接受需要花很长的时间，也需要很多的努力。主流接受需要那些不是早期用户的人们，那些不愿意改变的人，去发现你的产品，理解其中的价值主张，并愿意去尝试它，然后才是真正地使用它并买下它，并最后发展到成为一位愿意和别人谈论它的粉丝。这个周期需要好一段时间，因为它需要一个稳定的产品，让用户可以和你的公司和产品发展关系，并最终在关系够好的情况下愿意和别人谈论。 尽管在营销上的努力可以为周期埋下种子，但为了让主流接受成为可能，大部分时间还是需要花在产品没有上市的时候。只付出不获得的时间过程对于创始人来说是艰难的，因为作为创始人你会希望一切在你的控制之内，并且让计划实现。但有时候你需要的就是耐心和等待！Ari Tulla ，BetterDoctor联合创始人兼CEO：尽可能快地建立一个公众可用原型，然后再去迭代它。 我们在BetterDoctor上的计划是在两个月内做出第一代最小可行的原型产品（Minimum viable product, MVP）然后将它推向市场。我们把它做出来了，但因为他的可行性不够，我们只好把它放在封闭测试当中。封闭测试意味着非常少的用户以及非常少的真实反馈。 所以到最后，我们花了超过6个月的时间才最终推出了我们第一个beta版产品（依旧是个MVP）。而现在，也就是一年后，我们推出了针对全国的BetterDoctor搜索服务，并且有了一个稳定的平台。现在我们能在几天内推出新功能，并通过真实的用户做立即测试。 要知道，年是个很长的时间单位，如果有什么方法可以尽快让你的产品传到顾客手上，那你就应该去尝试。Andrew Angus ，Switch Video联合创始人兼CEO：我希望我在当时能够知道这个机会有多大，让我可以更好地计划利用它。现在我的公司老了、更结构化了，这可以让我更好地专注在策略上。如果我可以在一开始的时候就做到往回走一步、发展并投资一个更好的计划，我可能会我避免犯下的一堆错误。不过这些错误也成为了我学习中的一部分，这让我觉得我会继续变得成功（因为我会犯的错少了。）Mike Arsenault ，Rejoiner联合创始人：永远不要猜价格。有很多方法可以检测你的产品定价，但很多第一次创业的人们（包括我自己）总是默认为“价格”就是自己所认为的顾客愿意给的价格。另外，把精力放在你为你的顾客所创造的价值上，而不是你提供产品或服务时需要花的成本。 市面上有很多帮你针对目标市场、建立理想价格结构的整体设计方案。这和找出哪个产品功能是顾客认为最有价值的一样重要。 将支付意愿的数据和你顾客最想要的功能结合起来，你就有一个帮你发现定价结构的落地方案，而这个结构会吸引正确的用户并为你的生意带来最多的利润。Ethan Bloch ，Flowtown联合创始人：不要通过那些没做成过、或没有在你想实现领域上做事的人获取建议。Kapil Kale ，GiftRocket联合创始人：Idea是很棒的，但同时，在发行之前回头想想产品也是非常重要的。问问自己，谁会用这个产品，他们都是怎么听说到它的？ 很多时候，这些问题都会揭示出那些你需要建立在产品当中的关键功能，这些功能会让一位用户因为它很有用而告诉了他的朋友。Bo Lu ，FutureAdvisor联合创始人兼CEO：及时回头想想。 第一次创业的人常常会在他们作为创始人的头一段时间内担心一些没必要担心的事。我今天和一些创业者聊天，问到我最多的问题大概是“怎么合法地建一家公司”，“是不是应该辞掉现在的工作还是等等看有没有奖金”。而经验显示，这些事情根本就不会建成或毁掉公司。所以，我希望第一次创业的人可以在他们作为创始人的关键的头几天里想想他们的顾客。了解什么是顾客需要的，做到理解竞争对手并保持优于竞争对手才是会让你建成或毁掉公司的问题。这么做的最好方法就是及时回头想想。假设四年后的今天你已经拥有了一家成功的公司，问问你自己：“那个曾经让我整夜辗转反侧的苦恼问题到现在还是我的问题吗？”这个问题的答案通常是“no”。Dharmesh Shah，HubSpot的联合创始人兼CTO：选择一个大的、不断增长并且对于你来说是有明显优势的市场是很重要的。还有，要保证自己掌握着自己的命运，而不是过分地依赖其他人。Blake Williams，Keepsy联合创始人：通过让别人看你的计划，寻找出有关你计划的最关键观点。通常来说，新手创业者会爱上一个idea，然后寻求朋友或同事的支持。但毕竟，有谁会希望一个羽翼未丰的想法被反对者扼杀呢？不过，你应该去找的就是这种人。 让他们从头到尾地去毁你的计划和设计。如果你发现自己同意他们的观点并同样存在疑问，那你的计划（或者你）可能就是不能成行的。但如果你可以反复地有信念维护它，那你可能有勇气去克服你将面临的长久、艰难的苦差，这意味着这个计划或许能做得起来。Otto Hilska， Flowdock创始人兼CEO：众所周知，“不成熟的优化是万恶之源”，但我当时没有意识到，在我们花了大量时间和不同的数据库打交道之前，我们会不会有顾客。在开始的时候，你真的可以用一个半生熟的产品去验证你的假设。Rami Essaid ，Distil联合创始人兼CEO我希望在我第一次创业时就知道的事，是如何设置清楚且可以衡量的目标。任何创业公司都有的问题，就是它们有百万个未知数。当你在建立自己公司的时候，你可以试着尽可能多地回答这些问题。而一旦你回答得够多，你就已经知道你想做些什么。这个方法容易让人迷失。而为了确保你不会迷失，你需要设置清楚的目标并且能够衡量你的行为是否成功。如果你看到有些东西不起作用，那当务之急就是尽快地识别并纠正问题或快速改变方向。目标和指标是这么做的唯一方法。Alex Schiff Fetchnotes联合创始人兼CEO：我希望以前有人能教我的事情，就是你应该优化速度而不是成本。创业公司的一切都与速度以及你快速转移的能力有关。我们曾经在获得融资前自力更生过很长的时间，所以我们别无选择地变得超级节俭，但我还是希望我能在之前就了解速度的重要性，因为它会让事情变得不同。如果你花了一个小时的时间去编写程序达到一个月省20块的效果，那它根本就不值得。Jason Traff ，Leaky创始人：从MIT出来，我获得了不少有关创业的好建议，包括了特别保护权的重要性，团队化学反应以及如何做一个好产品。我希望我能在当初了解更多创业生活中的情感变化。通常电影或电视剧里的创业公司，总是一群20多岁的年轻人天天踢足球，夜夜办派对的景象。他们很少在这些高情绪中展示出人们的低落。 我的人生在我开了Leaky后，得到了很多以前从未有过并且频繁激烈的拒绝。在无数的拒绝之后，我学会了：你需要用毅力去看开暂时的情绪高低，并知道没有什么收获或者挫折会是永久性的。否则，这些情绪将无法在第二天早上从床上爬起来。Tri Tran， Munchery联合创始人兼CEO：这当中会有很多的起起落落。当你感到在往下走时，保持平静，要知道事情会变得更好。当你在往上走时，享受那个时刻，但同时也将这种能量存下来应对不好的时候。 我很幸运地在不同的创业公司工作过，知道大概会发生什么。 准备去成立你的第一家创业公司可能是你在人生中做过的最难的事。它并不总会那么迷人。你需要寻求你伴侣的支持，你要有充分信任并能很好协作的联合创始人。但最后，你会想象不到还有什么职业经历会比成立自己的公司更好。Ash Rust ，SendHub联合创始人：专注比你想象得更重要。Gautam Gupta ，NatureBox创始人：创立NatureBox是让我最难忘的经历了。我永远都会为有机会建立它而心存感激。我认为对于创始人来说很重要的，就是要知道成立一家公司的时机。这会带来你情绪上的高叠起伏。管理你的情绪状态会变得很难但很重要。当你触及低谷，记得提醒自己这只是路上的一个颠簸。 你可以放松，将时间花在不该担心的事情上。你会经常受到好消息和坏消息，你还会感到你的生活依赖于你公司的成功，但在这些之后，记得保持你清醒的头脑和执行力。Walter Chen， iDoneThis联合创始人兼CEO：我希望我当初会知道，运营一个创业团队会很像做父母。你要检查他们，你会想知道他们在干什么，你会担心他们在开车的时候Skype语音。而且你还需要经常大喊：“所有人安静！”而有的时候，你必须提醒他们在晚饭之前完成他们的工作。另外一些时候，你会想让他们娱乐放松，所以你带他们去看电影或去玩卡丁车。 作为一位创业公司创始人，你希望帮助你的团队去认清他们在工作上的强项，并支持他们。你希望他们去犯错并从错误中学习，而不是羞愧地逃避。你不做决定，而是问：“你怎么看？”你要对他们的情绪流动敏感，你要知道他们什么时候是气馁或沮丧的。你自己也会感到沮丧，但你的会将这些情绪更有建设性地表达给他们。毕竟，就像所有父母那样，你希望他们开心，并且成功。因为我就是个家长。Rick Perreault， Unbounce联合创始人兼CEO：我希望我当初会知道，准确的度量会有多重要，这样我们就可以更容易地对我们的第一次报告做支持。这两年中，我已经听过很多次“因为app的原因，我们不能很好地做跟踪。”如果我们在之前就决定好哪些关键度量是需要跟踪的，并根据需要做app，我们可能就不用那么痛苦了。Elizabeth Yin ：我成立的第一家公司是一个社交购物应用，那基本上就是个灾难。我们将我们所认为的优秀工具给做了出来，但却没人想用。我们花了大概2万美元并且用了将近一年半的时间。通过这个经验，我意识到最难的部分不是技术，而是知道用户需求。 如果我当时能够换种方式做，我就会在把产品做出来之前先用小样测试市场，我就会创建登录页面捕捉潜在用户的联系方式并已经和他们在谈了。我就会做个假按钮来衡量需求。简单来说，我希望我在当初就能够在做产品之前先测试一下市场。原文来自： DavidHauser 创业者David Hauser的个人博客","categories":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}],"tags":[],"keywords":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}]},{"title":"android语音录制和压缩","slug":"android/android-e8-af-ad-e9-9f-b3-e5-bd-95-e5-88-b6-e5-92-8c-e5-8e-8b-e7-bc-a9","date":"2012-11-07T20:16:09.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/7191/","link":"","permalink":"http://quanke.name/posts/7191/","excerpt":"","text":"因为上一篇博客代码有点太多，就单开了，这两天主要在看android语音录制和压缩转码相关知识，前段时间看见腾讯官方微博宣布，已经开放出即使聊天软件正在等待审批，但这个直接影响电话运营商，能通过的可能性应该不大，但我对这方面的技术很有兴趣，所以就试试看。其中涉及到很多声音方面的处理问题，在android中有两个类可以录制语音：AudioRecord和MediaRecorder，MediaRecorder主要是录制音频并写入文件，而AudioRecord主要是录制音频流，录制的音频流为pcm格式，关于pcm格式可以自行搜索一下，在传输过程中可以转换为amr格式，但没有相关可以类库有点麻烦，另外iphone不支持播放amr格式音频，如果需要跨两个平台可以使用AAC，压缩比也不错，音质也很好，我还没有测试过，网上评议而已。编码方面大家都推荐speex，我看了一下，需要是用System.loadLibrary加载进speex提供的类库。下面记录一下写的一个边录制边播放的一段代码吧 [code lang=”java”] import java.io.IOException; import android.app.Activity;import android.os.Bundle;import android.os.Looper;import android.os.Process;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.widget.Button;import android.widget.Toast; import android.media.AudioFormat;import android.media.AudioManager;import android.media.AudioRecord;import android.media.AudioTrack;import android.media.MediaRecorder; public class VoiceHcentActivity extends Activity { static { System.loadLibrary(&amp;quot;media_jni&amp;quot;); } public int frequency = 8000; private int rBufferSize, pBufferSize; private Button startSpeech; private AudioRecord recorder; private VoiceSpeech vspeech; private AudioTrack player; private boolean stopSpeech = false; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); init(); test(); } public void init(){ try{ startSpeech = (Button)findViewById(R.id.StartSpeech); //设置播放器缓冲区大小 pBufferSize = AudioTrack.getMinBufferSize(frequency, AudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT); //获取播放器对象 player = new AudioTrack(AudioManager.STREAM_MUSIC, frequency, AudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT, pBufferSize, AudioTrack.MODE_STREAM); //设置录音缓冲区大小 rBufferSize = AudioRecord.getMinBufferSize(frequency, AudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT); //获取录音机对象 recorder = new AudioRecord(MediaRecorder.AudioSource.MIC, frequency, AudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT, rBufferSize); }catch (Exception e) { String msg = &amp;quot;ERROR init: &amp;quot;+e.getStackTrace(); VoiceHcentActivity.this.toastMsg(msg); } } /** * 开始录音 */ public void startRecord(){ stopSpeech = false; vspeech = new VoiceSpeech(); vspeech.start(); } /** * 结束录音 */ public void stopRecord() { stopSpeech = true; } /** * 开始播放录音 */ public void startPlay(){ //设置播放器音量 player.setStereoVolume(0.7f, 0.7f); player.play(); } /** * 结束播放录音 */ public void stopPlay(){ player.stop(); } public void test(){ startSpeech.setOnTouchListener(new View.OnTouchListener() { public boolean onTouch(View arg0, MotionEvent arg1) { switch (arg1.getAction()) { case MotionEvent.ACTION_DOWN: //开始说话 startPlay(); startRecord(); toastMsg(&amp;quot;starting record!&amp;quot;); break; case MotionEvent.ACTION_UP: //停止说话 Log.i(&amp;quot;hcent&amp;quot;, &amp;quot;111&amp;quot;); stopPlay(); Log.i(&amp;quot;hcent&amp;quot;, &amp;quot;222&amp;quot;); stopRecord(); toastMsg(&amp;quot;stoped record!&amp;quot;); break; default: break; } return false; } }); } public class VoiceSpeech extends Thread{ @Override public void run() { super.run(); try { byte[] tempBuffer, readBuffer = new byte[rBufferSize]; int bufResult = 0; recorder.startRecording(); while(!stopSpeech){ bufResult = recorder.read(readBuffer, 0, rBufferSize); if(bufResult&amp;gt;0 &amp;amp;&amp;amp; bufResult%2==0){ tempBuffer = new byte[bufResult]; System.arraycopy(readBuffer, 0, tempBuffer, 0, rBufferSize); player.write(tempBuffer, 0, tempBuffer.length); } Log.d(&amp;quot;hcent&amp;quot;, &amp;quot;get read:&amp;quot;+bufResult+&amp;quot;___&amp;quot;+readBuffer.length); } recorder.stop(); Looper.prepare(); VoiceHcentActivity.this.toastMsg(&amp;quot;AudioSpeech have ended!&amp;quot;); Looper.loop(); } catch (Exception e) { String msg = &amp;quot;ERROR AudioRecord: &amp;quot;+e.getStackTrace(); Looper.prepare(); VoiceHcentActivity.this.toastMsg(msg); Looper.loop(); } } } @Override protected void onDestroy(){ player.release(); recorder.release(); super.onDestroy(); Process.killProcess(Process.myPid()); } public void toastMsg(String msg){ Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); Log.e(&amp;quot;hcent&amp;quot;, msg); } }[/code]","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"音频压缩工具——Speex的使用","slug":"other/e9-9f-b3-e9-a2-91-e5-8e-8b-e7-bc-a9-e5-b7-a5-e5-85-b7-e2-80-94-e2-80-94speex-e7-9a-84-e4-bd-bf-e7-94-a8","date":"2012-11-07T20:13:24.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/30169/","link":"","permalink":"http://quanke.name/posts/30169/","excerpt":"","text":"在Android开发中，需要录音并发送到对方设备上。这时问题来了，手机常会是GPRS、3G等方式上网，所以节省流量是非常关键的，使用Speex来压缩音频文件，可以将音频压文件小数倍。 1.去Speex官网下载最新Speex源码。 2.创建一个新的应用（我创建的应用名为Audio），并创建一个jni目录（$project/jni）。 3.把speex源码目录下的libspeex和include目录及其子目录文件全部拷贝到$project/jni目录下 [code lang=”java”]（$project/jni/libspeex and $project/jni/include）。[/code] 4.在jni目录下新增Android.mk文件，编辑内容如下 [code lang=”java”]LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS)&amp;nbsp;LOCAL_MODULE &amp;nbsp; &amp;nbsp;:= libspeexLOCAL_CFLAGS = -DFIXED_POINT -DUSE_KISS_FFT -DEXPORT=&quot;&quot; -UHAVE_CONFIG_HLOCAL_C_INCLUDES := $(LOCAL_PATH)/include&amp;nbsp;LOCAL_SRC_FILES := &amp;nbsp;\\./speex_jni.cpp \\./libspeex/bits.c \\./libspeex/buffer.c \\./libspeex/cb_search.c \\./libspeex/exc_10_16_table.c \\./libspeex/exc_10_32_table.c \\./libspeex/exc_20_32_table.c \\./libspeex/exc_5_256_table.c \\./libspeex/exc_5_64_table.c \\./libspeex/exc_8_128_table.c \\./libspeex/fftwrap.c \\./libspeex/filterbank.c \\./libspeex/filters.c \\./libspeex/gain_table.c \\./libspeex/gain_table_lbr.c \\./libspeex/hexc_10_32_table.c \\./libspeex/hexc_table.c \\./libspeex/high_lsp_tables.c \\./libspeex/jitter.c \\./libspeex/kiss_fft.c \\./libspeex/kiss_fftr.c \\./libspeex/lpc.c \\./libspeex/lsp.c \\./libspeex/lsp_tables_nb.c \\./libspeex/ltp.c \\./libspeex/mdf.c \\./libspeex/modes.c \\./libspeex/modes_wb.c \\./libspeex/nb_celp.c \\./libspeex/preprocess.c \\./libspeex/quant_lsp.c \\./libspeex/resample.c \\./libspeex/sb_celp.c \\./libspeex/scal.c \\./libspeex/smallft.c \\./libspeex/speex.c \\./libspeex/speex_callbacks.c \\./libspeex/speex_header.c \\./libspeex/stereo.c \\./libspeex/vbr.c \\./libspeex/vq.c \\./libspeex/window.c&amp;nbsp;include $(BUILD_SHARED_LIBRARY)[/code] 5.在jni目录下新增Application.mk文件，编辑内容如下 [code lang=”java”]APP_ABI := armeabi armeabi-v7a[/code] 6.在$project/jni/include/speex/目录下新增speex_config_types.h文件，编辑内容如下 [code lang=”java”] #ifndef SPEEX_TYPES_H #define SPEEX_TYPES_Htypedef short spx_int16_t;typedef unsigned short spx_uint16_t;typedef int spx_int32_t;typedef unsigned int spx_uint32_t; #endif[/code] 7.创建JNI包装类speex_jni.cpp，用来调用Speex中的C代码函数，编辑内容如下 [code lang=”c”]#include &lt;jni.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;speex/speex.h&gt; static int codec_open = 0; static int dec_frame_size;static int enc_frame_size; static SpeexBits ebits, dbits;void enc_state;void dec_state; static JavaVM *gJavaVM; extern &quot;C&quot;JNIEXPORT jint JNICALL Java_com_audio_Speex_open (JNIEnv *env, jobject obj, jint compression) { int tmp; if (codec_open++ != 0) return (jint)0; speex_bits_init(&amp;amp;ebits); speex_bits_init(&amp;amp;dbits); enc_state = speex_encoder_init(&amp;amp;speex_nb_mode); dec_state = speex_decoder_init(&amp;amp;speex_nb_mode); tmp = compression; speex_encoder_ctl(enc_state, SPEEX_SET_QUALITY, &amp;amp;tmp); speex_encoder_ctl(enc_state, SPEEX_GET_FRAME_SIZE, &amp;amp;enc_frame_size); speex_decoder_ctl(dec_state, SPEEX_GET_FRAME_SIZE, &amp;amp;dec_frame_size); return (jint)0; } extern &quot;C&quot;JNIEXPORT jint Java_com_audio_Speex_encode (JNIEnv *env, jobject obj, jshortArray lin, jint offset, jbyteArray encoded, jint size) { jshort buffer[enc_frame_size]; jbyte output_buffer[enc_frame_size]; int nsamples = (size-1)/enc_frame_size + 1; int i, tot_bytes = 0; if (!codec_open) return 0; speex_bits_reset(&amp;amp;ebits); for (i = 0; i &amp;lt; nsamples; i++) { env-&amp;gt;GetShortArrayRegion(lin, offset + i*enc_frame_size, enc_frame_size, buffer); speex_encode_int(enc_state, buffer, &amp;amp;ebits); } //env-&amp;gt;GetShortArrayRegion(lin, offset, enc_frame_size, buffer); //speex_encode_int(enc_state, buffer, &amp;amp;ebits); tot_bytes = speex_bits_write(&amp;amp;ebits, (char *)output_buffer, enc_frame_size); env-&amp;gt;SetByteArrayRegion(encoded, 0, tot_bytes, output_buffer); return (jint)tot_bytes; } extern &quot;C&quot;JNIEXPORT jint JNICALL Java_com_audio_Speex_decode (JNIEnv *env, jobject obj, jbyteArray encoded, jshortArray lin, jint size) { jbyte buffer[dec_frame_size]; jshort output_buffer[dec_frame_size]; jsize encoded_length = size; if (!codec_open) return 0; env-&amp;gt;GetByteArrayRegion(encoded, 0, encoded_length, buffer); speex_bits_read_from(&amp;amp;dbits, (char *)buffer, encoded_length); speex_decode_int(dec_state, &amp;amp;dbits, output_buffer); env-&amp;gt;SetShortArrayRegion(lin, 0, dec_frame_size, output_buffer); return (jint)dec_frame_size; } extern &quot;C&quot;JNIEXPORT jint JNICALL Java_com_audio_getFrameSize (JNIEnv *env, jobject obj) { if (!codec_open) return 0; return (jint)enc_frame_size; } extern &quot;C&quot;JNIEXPORT void JNICALL Java_com_audio_Speex_close (JNIEnv *env, jobject obj) { if (--codec_open != 0) return; speex_bits_destroy(&amp;amp;ebits); speex_bits_destroy(&amp;amp;dbits); speex_decoder_destroy(dec_state); speex_encoder_destroy(enc_state); }[/code] 8.在Java层创建Speex工具类，内容如下 [code lang=”java”]package com.audio; class Speex { /* quality * 1 : 4kbps (very noticeable artifacts, usually intelligible) * 2 : 6kbps (very noticeable artifacts, good intelligibility) * 4 : 8kbps (noticeable artifacts sometimes) * 6 : 11kpbs (artifacts usually only noticeable with headphones) * 8 : 15kbps (artifacts not usually noticeable) */ private static final int DEFAULT_COMPRESSION = 8; Speex() { } public void init() { load(); open(DEFAULT_COMPRESSION); } private void load() { try { System.loadLibrary(&amp;quot;speex&amp;quot;); } catch (Throwable e) { e.printStackTrace(); } } public native int open(int compression); public native int getFrameSize(); public native int decode(byte encoded[], short lin[], int size); public native int encode(short lin[], int offset, byte encoded[], int size); public native void close(); }[/code] 9.打开cygwin工具，切换到项目目录（我项目是在F:\\workspace\\Audio），输入$NDK/ndk-build cygwin工具的安装与配置，可以看这篇文章——使用NDK与环境搭建 会在项目中生成libs目录和libspeex.so文件，这就是Speex类中System.loadLibrary(“speex”);代码引用的，系统会根据操作系统由”speex”找到对应的动态库libspeex.so，Windows下是.dll文件，linux下是.so文件。 当前，我的项目结构如下图","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"android 使用NDK与环境搭建","slug":"android/android-e4-bd-bf-e7-94-a8ndk-e4-b8-8e-e7-8e-af-e5-a2-83-e6-90-ad-e5-bb-ba","date":"2012-11-07T20:02:00.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/33762/","link":"","permalink":"http://quanke.name/posts/33762/","excerpt":"","text":"一、NDK介绍 使用NDK，并不会给我们程序提高执行性能，反而会使程序复杂化。因此，尽量避免使用NDK，除非你真的需要使用本地库（通常是C/C++库），不要因为擅长使用C/C++编程而使用NDK。 Android提供了两种使用本地代码的方式1.通过JNI调用本地代码 2.通过NativeActivity类调用本地代码（从2.3版本开始支持） NDK 提供了一系列的工具，帮助开发者快速开发 C （或 C++ ）的动态库，并能自动将 so 和java 应用一起打包成 apk 。这些工具对开发者的帮助是巨大的。NDK 集成了交叉编译器，并提供了相应的 mk 文件隔离 CPU 、平台、 ABI 等差异，开发人员只需要简单修改 mk 文件（指出 “ 哪些文件需要编译 ” 、 “ 编译特性要求 ” 等），就可以创建出 so 。 NDK 可以自动地将 so 和 Java 应用一起打包，极大地减轻了开发人员的打包工作 。 比较简单的说， NDK 是一套交叉编译工具，它可以帮你把你用 C 或 C++ 书写的代码，编译为 .so （类似与 win 下的 .dll ）格式的文件，使你可以在你的 Android 程序当中用 Java 语言（ JNI ）调用这些代码。 二：Windows平台安装cygwin由于 NDK 编译代码时必须要用到 make 和 gcc ，所以你必须先搭建一个 linux 环境， cygwin 是一个在 windows 平台上运行的 unix 模拟环境 , 它对于学习 unix/linux 操作环境，或者从 unix 到 windows 的应用程序移植，非常有用。通过它，你就可以在不安装 linux 的情况下使用 NDK 来编译 C 、 C++ 代码了。下面我们一步一步的安装 cygwin 吧。1.在cygwin主页下载setup.exe 2.双击安装setup.exe 3.选择安装目录 4.选择下载网址，http://mirrors.163.com比较快 5.安装向导提示是第一次安装，这个不用管它，直接点“确定” 6.选择安装包，这里要把Devel包由Default改成Install 7.正在安装，时间有点长，估计要2个小时左右（根据网络而定） &nbsp; 8.测试cygwin是否安装好了运行cygwin，在弹出的命令行窗口输入：cygcheck -c cygwin命令 &nbsp; 三、配置NDK环境变量1.在cygwin的安装目录，找到home\\&lt;PC用户名&gt;.bash_profile文件（我是在C:\\cygwin\\home\\user.bash_profile），有时候安装home目录下是空的，可以自行创建&lt;PC用户名&gt;目录，并将cygwin\\etc\\skel.bash_profile文件拷贝过来。2.打开bash_profile文件，添加如下两行，例如：NDK=/cygdrive/h/android-ndk-r7export NDK NDK这个名字可以随便取，路径格式为/cygdrive/&lt;你的盘符&gt;/&lt;android ndk 目录&gt;注意：用某些编辑器编辑bash_profile文件，会导致问题，如用写字板、VC++6。可以用Uedit、UltraEdit的dos格式编辑 3.测试环境是否配置好了，打开cygwin，输入cd $NDK，出现/cygdrive/h/android-ndk-r7信息表示配置好了。如下图 注意：如果第2步用写字板打开编辑bash_profile文件，输入cd $NDK时会显示no such file or directory，说明配置不成功四、用NDK来编译程序1.现在我们用安装好的NDK来编译一个简单的程序，我们选择ndk自带的例子hello-jni，我的位于H:\\android-ndk-r7\\samples\\hello-jni(根据你具体的安装位置而定)，2.运行cygwin，输入命令cd /cygdrive/h/android-ndk-r7/samples/hello-jni，进入到H:\\android-ndk-r7\\samples\\hello-jni目录。3.输入$NDK/ndk-build，执行成功后，它会自动生成一个libs目录，把编译生成的.so文件放在里面。($NDK是调用我们之前配置好的环境变量，ndk-build是调用ndk的编译程序)4.此时去hello-jni的libs目录下看有没有生成的.so文件，如果有，你的ndk就运行正常了 五、在eclipse中集成c/c++开发环境1.装Eclipse的C/C++环境插件：CDT，这里选择在线安装。首先登录http://www.eclipse.org/cdt/downloads.php，找到对应你Eclipse版本的CDT插件的在线安装地址。2.然后点Help菜单，找到Install New Software菜单3.点击Add按钮，把取的地址填进去，出来插件列表后，选Select All，然后选择下一步即可完成安装4.安装完成后，在eclispe中右击新建一个项目，如果出现了c/c++项目，则表明你的CDT插件安装成功了 &nbsp; 六、配置C/C++的编译器1.打开eclipse，导入ndk自带的hello-jni例子，右键单击项目名称，点击Properties，弹出配置界面，之后再点击Builders，弹出项目的编译工具列表，之后点击New，新添加一个编译器，点击后出现添加界面，选择Program，点击OK2.出现了添加界面，首先给编译配置起个名字，如：C_Builder设置Location为&lt;你cygwin安装路径&gt;\\bin\\bash.exe程序，例如：C:\\cygwin\\bin\\bash.exe设置Working Directory为&lt;你cygwin安装路径&gt;\\bin目录，例如：C:\\cygwin\\bin设置Arguments为 –login -c “cd /cygdrive/F/workspace/hello-jni &amp;&amp; $NDK/ndk-build” 上面的配置中 /cygdrive/F/workspace/hello-jni是你当前要编译的程序的目录，$NDK是之前配置的ndk的环境变量，这两个根据你具体的安装目录进行配置，其他的不用变，Arguments这串参数实际是 给bash.exe命令行程序传参数，进入要编译的程序目录，然后运行ndk-build编译程序 3.接着切换到Refresh选项卡，给Refresh resources upon completion打上钩4.然后切换到Build Options选项卡，勾选上最后三项5.之后点击Specify Resources按钮，选择资源目录，勾选你的项目目录即可6.最后点击Finish，点击OK一路把刚才的配置都保存下来，注意：如果你配置的编译器在其它编译器下边，记得一定要点Up按钮，把它排到第一位，否则C代码的编译晚于Java代码的编译，会造成你的C代码要编译两次才能看到最新的修改 7.编译配置完成，现在来测试一下是否可以自动编译，打开项目jni目录里的hello-jni.c文件把提示Hello from JNI!改成其他的文字：如：Hello，Automatic Compile.，然后再模拟器中运行你的程序，如果模拟器中显示了你最新修改的文字，说明环境搭建完成！","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"声音压缩库 Speex ","slug":"other/e5-a3-b0-e9-9f-b3-e5-8e-8b-e7-bc-a9-e5-ba-93-speex","date":"2012-11-07T19:31:49.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/14090/","link":"","permalink":"http://quanke.name/posts/14090/","excerpt":"","text":"Speex是一套专门用于压缩声音的库,由于其专门针对声音,所以压缩声音的性能非常高.Speex由于其压缩性能,及0.80版后的跨平台的性能,所以在网络声音的传输中有很大的价值.但是需要注意的是speex只能对声音进行压缩,不支持音乐的压缩,如果你需要音乐的压缩你或许需要用vorbis库. 支持包括Linux、BSD、MacOS 以及 Symbian 系统。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android录制声音 录音输输出格式","slug":"android/android-e5-bd-95-e5-88-b6-e5-a3-b0-e9-9f-b3-e5-bd-95-e9-9f-b3-e8-be-93-e8-be-93-e5-87-ba-e6-a0-bc-e5-bc-8f","date":"2012-11-07T19:24:41.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/53934/","link":"","permalink":"http://quanke.name/posts/53934/","excerpt":"","text":"Table 1. Core media format and codec support. &nbsp; TypeFormat / CodecEncoderDecoderDetailsSupported File Type(s) / Container FormatsAudioAAC LC/LTP••Mono/Stereo content in any combination of standard bit rates up to 160 kbps and sampling rates from 8 to 48kHz• 3GPP (.3gp)• MPEG-4 (.mp4, .m4a)• ADTS raw AAC (.aac, decode in Android 3.1+, encode in Android 4.0+, ADIF not supported)• MPEG-TS (.ts, not seekable, Android 3.0+)HE-AACv1 (AAC+)•HE-AACv2 (enhanced AAC+)•AMR-NB••4.75 to 12.2 kbps sampled @ 8kHz 3GPP (.3gp)AMR-WB••9 rates from 6.60 kbit/s to 23.85 kbit/s sampled @ 16kHz 3GPP (.3gp)FLAC•(Android 3.1+)Mono/Stereo (no multichannel). Sample rates up to 48 kHz (but up to 44.1 kHz is recommended on devices with 44.1 kHz output, as the 48 to 44.1 kHz downsampler does not include a low-pass filter). 16-bit recommended; no dither applied for 24-bit. FLAC (.flac) onlyMP3•Mono/Stereo 8-320Kbps constant (CBR) or variable bit-rate (VBR) MP3 (.mp3)MIDI•MIDI Type 0 and 1. DLS Version 1 and 2. XMF and Mobile XMF. Support for ringtone formats RTTTL/RTX, OTA, and iMelody• Type 0 and 1 (.mid, .xmf, .mxmf)• RTTTL/RTX (.rtttl, .rtx)• OTA (.ota)• iMelody (.imy)Vorbis•• Ogg (.ogg)• Matroska (.mkv, Android 4.0+)PCM/WAVE•8- and 16-bit linear PCM (rates up to limit of hardware) WAVE (.wav)ImageJPEG••Base+progressive JPEG (.jpg)GIF•GIF (.gif)PNG••PNG (.png)BMP•BMP (.bmp)WEBP•(Android 4.0+)•(Android 4.0+) WebP (.webp)VideoH.263••• 3GPP (.3gp)• MPEG-4 (.mp4)H.264 AVC•(Android 3.0+)•Baseline Profile (BP)• 3GPP (.3gp)• MPEG-4 (.mp4)• MPEG-TS (.ts, AAC audio only, not seekable, Android 3.0+)MPEG-4 SP•3GPP (.3gp)VP8•(Android 2.3.3+)Streamable only in Android 4.0 and above• WebM (.webm)• Matroska (.mkv, Android 4.0+) Video Encoding RecommendationsTable 2, below, lists examples of video encoding profiles and parameters that the Android media framework supports for playback. In addition to these encoding parameter recommendations, a device’s availablevideo recording profiles can be used as a proxy for media playback capabilities. These profiles can be inspected using the[CamcorderProfile](http://blog.csdn.net/zqiang_55/reference/android/media/CamcorderProfile.html) class, which is available since API level 8. Table 2. Examples of supported video encoding parameters. &nbsp; SD (Low quality) SD (High quality) HD (Not available on all devices) Video codec H.264 Baseline Profile H.264 Baseline Profile H.264 Baseline Profile Video resolution 176 x 144 px 480 x 360 px 1280 x 720 px Video frame rate 12 fps 30 fps 30 fps Video bitrate 56 Kbps 500 Kbps 2 Mbps Audio codec AAC-LC AAC-LC AAC-LC Audio channels 1 (mono) 2 (stereo) 2 (stereo) Audio bitrate 24 Kbps 128 Kbps 192 KbpsFor video content that is streamed over HTTP or RTSP, there are additional requirements:","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android开发中网络请求的压缩 ── GZip的使用","slug":"android/android-e5-bc-80-e5-8f-91-e4-b8-ad-e7-bd-91-e7-bb-9c-e8-af-b7-e6-b1-82-e7-9a-84-e5-8e-8b-e7-bc-a9-e2-94-80-e2-94-80-gzip-e7-9a-84-e4-bd-bf-e7-94-a8","date":"2012-11-07T18:58:23.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/42283/","link":"","permalink":"http://quanke.name/posts/42283/","excerpt":"","text":"gzip是GNUzip的缩写，它是一个GNU自由软件的文件压缩程序。 HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。一般服务器中都安装有这个功能模块的，服务器端不需做改动。 当浏览器支持gzip 格式的时候， 服务器端会传输gzip格式的数据。 从Http 技术细节上讲，就是 http request 头中 有 “Accept-Encoding”, “gzip” ，response 中就有返回头Content-Encoding=gzip 。 我们现在从浏览器上访问玩啥网站都是gzip格式传输的。 但是我们现在Android 客户端，没有用gzip 格式访问。 同样的的道理，我们可以在android 客户端 request 头中加入 “Accept-Encoding”, “gzip” ，来让服务器传送gzip 数据。 具体代码如下。[code lang=”java”] private String getJsonStringFromGZIP(HttpResponse response) { String jsonString = null; try { InputStream is = response.getEntity().getContent(); BufferedInputStream bis = new BufferedInputStream(is); bis.mark(2); // 取前两个字节 byte[] header = new byte[2]; int result = bis.read(header); // reset输入流到开始位置 bis.reset(); // 判断是否是GZIP格式 int headerData = getShort(header); // Gzip 流 的前两个字节是 0x1f8b if (result != -1 &amp;&amp; headerData == 0x1f8b) { LogUtil.d(&quot;HttpTask&quot;, &quot; use GZIPInputStream &quot;); is = new GZIPInputStream(bis); } else { LogUtil.d(&quot;HttpTask&quot;, &quot; not use GZIPInputStream&quot;); is = bis; } InputStreamReader reader = new InputStreamReader(is, &quot;utf-8&quot;); char[] data = new char[100]; int readSize; StringBuffer sb = new StringBuffer(); while ((readSize = reader.read(data)) &gt; 0) { sb.append(data, 0, readSize); } jsonString = sb.toString(); bis.close(); reader.close(); } catch (Exception e) { LogUtil.e(&quot;HttpTask&quot;, e.toString(),e); } LogUtil.d(&amp;quot;HttpTask&amp;quot;, &amp;quot;getJsonStringFromGZIP net output : &amp;quot; + jsonString ); return jsonString; } private int getShort(byte[] data) { return (int)((data[0]&amp;lt;&amp;lt;8) | data[1]&amp;amp;0xFF); } [/code]参考 ，注意实际使用中，我发现gzip 流前两个字节是0x1e8b ，不是0x1f8b .后来检查一下code ，代码处理错误，加上第二个字节的时候需 &amp;0xFF 0x1f8b 可参考标准 http://www.gzip.org/zlib/rfc-gzip.html#file-format","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"安卓自带的主题android:theme","slug":"other/e5-ae-89-e5-8d-93-e8-87-aa-e5-b8-a6-e7-9a-84-e4-b8-bb-e9-a2-98androidtheme","date":"2012-11-07T17:58:44.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/27720/","link":"","permalink":"http://quanke.name/posts/27720/","excerpt":"","text":"[code lang=”xml”] android:theme=&quot;@android:style/Theme.Dialog&quot; 将一个Activity显示为能话框模式 android:theme=&quot;@android:style/Theme.NoTitleBar&quot; 不显示应用程序标题栏 android:theme=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot; 不显示应用程序标题栏，并全屏 android:theme=&quot;Theme.Light&quot; 背景为白色 android:theme=&quot;Theme.Light.NoTitleBar&quot; 白色背景并无标题栏 android:theme=&quot;Theme.Light.NoTitleBar.Fullscreen&quot; 白色背景，无标题栏，全屏 android:theme=&quot;Theme.Black&quot; 背景黑色 android:theme=&quot;Theme.Black.NoTitleBar&quot; 黑色背景并无标题栏 android:theme=&quot;Theme.Black.NoTitleBar.Fullscreen&quot; 黑色背景，无标题栏，全屏 android:theme=&quot;Theme.Wallpaper&quot; 用系统桌面为应用程序背景 android:theme=&quot;Theme.Wallpaper.NoTitleBar&quot; 用系统桌面为应用程序背景，且无标题栏 android:theme=&quot;Theme.Wallpaper.NoTitleBar.Fullscreen&quot; 用系统桌面为应用程序背景，无标题栏，全屏 android:theme=&quot;Translucent&quot; 背景为透明 android:theme=&quot;Theme.Translucent.NoTitleBar&quot; 透明背景并无标题栏 android:theme=&quot;Theme.Translucent.NoTitleBar.Fullscreen&quot; 透明背景并无标题栏，全屏 android:theme=&quot;Theme.Panel&quot; 内容容器 android:theme=&quot;Theme.Light.Panel&quot; 背景为白色的内容容器[/code]","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android：invalidate()和postInvalidate() 的区别及使用","slug":"android/android-ef-bc-9ainvalidate-e5-92-8cpostinvalidate-e7-9a-84-e5-8c-ba-e5-88-ab-e5-8f-8a-e4-bd-bf-e7-94-a8","date":"2012-11-07T17:57:34.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/60638/","link":"","permalink":"http://quanke.name/posts/60638/","excerpt":"","text":"Android提供了Invalidate方法实现界面刷新，但是Invalidate不能直接在线程中调用，因为他是违背了单线程模型：Android UI操作并不是线程安全的，并且这些操作必须在UI线程中调用。invalidate()是用来刷新View的，必须是在UI线程中进行工作。比如在修改某个view的显示时，调用invalidate()才能看到重新绘制的界面。invalidate()的调用是把之前的旧的view从主UI线程队列中pop掉。 一个Android 程序默认情况下也只有一个进程，但一个进程下却可以有许多个线程。在这么多线程当中，把主要是负责控制UI界面的显示、更新和控件交互的线程称为UI线程，由于onCreate()方法是由UI线程执行的，所以也可以把UI线程理解为主线程。其余的线程可以理解为工作者线程。invalidate()得在UI线程中被调动，在工作者线程中可以通过Handler来通知UI线程进行界面更新。 而postInvalidate()在工作者线程中被调用 利用invalidate()刷新界面 实例化一个Handler对象，并重写handleMessage方法调用invalidate()实现界面刷新;而在线程中通过sendMessage发送界面更新消息。[code lang=”java”]// 在onCreate()中开启线程 new Thread(new GameThread()).start();、 // 实例化一个handler Handler myHandler = new Handler() {// 接收到消息后处理public void handleMessage(Message msg) {switch (msg.what) {case Activity01.REFRESH:mGameView.invalidate(); // 刷新界面break;} super.handleMessage(msg);}}; class GameThread implements Runnable {public void run() {while (!Thread.currentThread().isInterrupted()) {Message message = new Message();message.what = Activity01.REFRESH;// 发送消息Activity01.this.myHandler.sendMessage(message);try {Thread.sleep(100);} catch (InterruptedException e) {Thread.currentThread().interrupt();}}}} [/code]使用postInvalidate()刷新界面 使用postInvalidate则比较简单，不需要handler，直接在线程中调用postInvalidate即可。 [code lang=”java”]class GameThread implements Runnable {public void run() {while (!Thread.currentThread().isInterrupted()) {try {Thread.sleep(100);} catch (InterruptedException e) {Thread.currentThread().interrupt();} // 使用postInvalidate可以直接在线程中更新界面mGameView.postInvalidate();}}}[/code]","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android压缩图片的几种方法和实例demo","slug":"android/android-e5-8e-8b-e7-bc-a9-e5-9b-be-e7-89-87-e7-9a-84-e5-87-a0-e7-a7-8d-e6-96-b9-e6-b3-95","date":"2012-11-07T17:49:11.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/37524/","link":"","permalink":"http://quanke.name/posts/37524/","excerpt":"","text":"在移动设备上进行图片相关软件的开发，一定得先压缩图片，毕竟移动设备的内存有限，稍不注意就会导致内存溢出，刚好用到这里，就学习了一下相关的压缩图片，现在总结出来和大家共享。 一般情况下，我们要将图片按照固定大小取缩略图，一般取缩略图的方法是使用 BitmapFactory的decodeFile方法，然后通过传递进去 BitmapFactory.Option类型的参数进行取缩略图，在Option中，属性值inSampleSize表示缩略图大小为原始图片大小的几分之一，即如果这个值为2，则取出的缩略图的宽和高都是原始图片的1/2，图片大小就为原始大小的1/4。 Options中有个属性inJustDecodeBounds，SDK中的英文引用如下：If set totrue, the decoder will return null (no bitmap), but the out… fields will stillbe set, allowing the caller to query the bitmap without having to allocate thememory for its pixels.大致意思就是说如果该值设为true那么将不返回实际的bitmap不给其分配内存空间而里面只包括一些解码边界信息即图片大小信息，那么相应的方法也就出来了，通过设置inJustDecodeBounds为true，获取到outHeight(图片原始高度)和 outWidth(图片的原始宽度)，然后计算一个inSampleSize(缩放值)，然后就可以取图片了，这里要注意的是，inSampleSize 可能小于0，必须做判断。 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; pic[i] = BitmapFactory.decodeFile(path[i], options); //此时返回bm为空 options.inJustDecodeBounds = false; //缩放比 int be = (int)(options.outHeight / (float)215); if (be &lt;= 0) be = 1; options.inSampleSize = be; options.inSampleSize = computeSampleSize(options, -1, 300*350); //重新读入图片，注意这次要把options.inJustDecodeBounds 设为 false哦 pic[i] = BitmapFactory.decodeFile(path[i], options); 这是option的UML图： 这样出来的图片一般不会失真，但是当你压缩的长宽比例相差较大时还会有失真现象。 这个是等比例缩放:bitmap = Bitmap.createScaledBitmap(bitmap, width, height, false);width和height是缩放后的大小，true表示过滤，可消除锯齿感。 newBitmap = Bitmap.createBitmap(oldBitmap, 0, 0, width, height, matrix, true);//用距阵的方式缩放 这个是截取图片某部分:bitmap = Bitmap.createBitmap(bitmap, x, y, width, height);，意思是从（x，y）开始截取width宽和height高大小的图片。 这些就是android系统中压缩图片的几个方法了。 &nbsp; 实例&nbsp;[code lang=”java”]//对图片进行压缩 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; //获取这个图片的宽和高 Bitmap bitmap = BitmapFactory.decodeFile(&amp;quot;/sdcard/dcim/Camera/hello.jpg&amp;quot;,options);//此时返回bm为空 options.inJustDecodeBounds =false; //计算缩放比 int be = (int)(options.outHeight / (float)200); if(be &amp;lt;= 0) be =1; options.inSampleSize =be; //重新读入图片，注意这次要把options.inJustDecodeBounds设为false哦 bitmap = BitmapFactory.decodeFile(&amp;quot;/sdcard/dcim/Camera/hello.jpg&amp;quot;,options); int w = bitmap.getWidth(); int h=bitmap.getHeight(); System.out.println(w+&amp;quot; &amp;quot;+h); myImageView.setImageBitmap(bitmap); //保存入sdCard File file2= new File(&amp;quot;/sdcard/dcim/Camera/test.jpg&amp;quot;); try { FileOutputStream out = new FileOutputStream(file2); if(bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out)){ out.flush(); out.close(); } } catch (Exception e) { // TODO: handle exception } //读取sd卡 File file =new File(&amp;quot;/sdcard/dcim/Camera/test.jpg&amp;quot;); int maxBufferSize = 16 * 1024; int len = 0; ByteArrayOutputStream outStream = new ByteArrayOutputStream(); BufferedInputStream bufferedInputStream; try { bufferedInputStream = new BufferedInputStream(new FileInputStream(file)); int bytesAvailable = bufferedInputStream.available(); int bufferSize = Math.min(bytesAvailable, maxBufferSize); byte[] buffer = new byte[bufferSize]; while ((len = bufferedInputStream.read(buffer)) != -1) { outStream.write(buffer, 0, bufferSize); } data = outStream.toByteArray(); outStream.close(); bufferedInputStream.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } [/code]","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android编程容易犯的错误","slug":"android/android-e7-bc-96-e7-a8-8b-e5-ae-b9-e6-98-93-e7-8a-af-e7-9a-84-e9-94-99-e8-af-af","date":"2012-11-06T18:12:24.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/49833/","link":"","permalink":"http://quanke.name/posts/49833/","excerpt":"","text":"1.设置TextView的文本颜色[code lang=”java”]TextView tv;…tv.setTextColor(R.color.white);[/code]其实这样设置的颜色是 R.color.white的资源ID值所代表的颜色值，而不是资源color下的white颜色值：正确的做法如下： [code lang=”java”]tv.setTextColor(getResources().getColor(R.color.white));[/code]这个出错的概率满高的，就是因为二者都是int类，导致编译器不报错。 2.读取Cursor中的值 [code lang=”java”]Uri uri;Cursor cursor = contentResolver.query(uri, null,null,null,null);if(cursor !=null){ String name = cursor.getString(1);// curosr.close(); cursor =null;}[/code] 上面语句中的，执行到cursor.getString(1)部分就会报异常，异常是: Caused by: android.database.CursorIndexOutOfBoundsException: Index -1 requested, with a size of 4 编译没有问题，只有在运行的时候才会发现。 正确的做法是： [code lang=”java”]Uri uri;Cursor cursor = contentResolver.query(uri, null,null,null,null);if(cursor !=null){ if(cursor.moveToFirst()){ String name = cursor.getString(1);// } curosr.close(); cursor =null;}[/code]或者: [code lang=”java”]Uri uri;Cursor cursor = contentResolver.query(uri, null,null,null,null);if(cursor !=null){ while(cursor.moveToNext()){ String name = cursor.getString(1);// } curosr.close(); cursor =null;}[/code]3.不要使用标有Deprecated的函数或者类,比如不要使用android.telephony.gsm.SmsMessage，而应该用android.telephony.SmsMessage,这样避免采用不同的3G协议时不会出现问题。 4.SQLite中的查询条件，比如一个叫name的字段，其字段类型为TEXT,如果我们要判断其name不等某个值(如zhangsan),写出如下的语句: [code lang=”java”]name &lt;&gt; ‘zhangsan’[/code]但是，这样写的语句，如果碰到name值为空的时候，就有问题，即name为空时 以上的布尔值为false，而不是true. 原因很可能，SQLite中的判断函数采用类似写法: [code lang=”java”]boolean judge(String self, String conditions){ if(null == self) return false; return self.equalsIgnoreCase(conditions);}[/code]其中 self为数据库中name的值，而conditions为上面示例中的 zhangsan。 所以，以上查询条件的正确写法是: [code lang=”java”]name &lt;&gt; ‘zhangsan’ or name is null[/code]除非你也想过滤掉name 为空的记录。 5.如下所示，想要在按钮显示”删 除”（没错删除中间有个空格）,以下的字符串资源是错误的： [code lang=”java”]&lt;string name=&quot;button_delete_text&quot;&gt;删 除&lt;/string&gt;[/code]这样的出来，最终看不到中间的空格，应该是Android SDK编译的时候，会自动过滤掉String中的空格部分，所以应该采用以下的方式: [code lang=”java”]&lt;string name=&quot;button_delete_text&quot;&gt;删\\u0020除&lt;/string&gt;[/code]类似地，其他的特殊符号都可以用\\u00XX来转义，如 ‘ —- \\u0027, &lt; —– \\u003C, &gt; —- \\u003E 。 6. context的问题: 如果在一个非Activity的context里面调用startActivity，那么其intent必须设置： [code lang=”java”]intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);[/code] 否则，会报如下类似的错误： [code lang=”java”]Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag.[/code] 而我们还要提防系统控件中的隐性调用startActivity: [code lang=”java”]TextView tv = new TextView(mContext);tv.setAutoLinkMask(Linkify.ALL);tv.setText(content);[/code]当content内容中有电话号码/邮件/URL时，并且mContext不是非Acitvity的context，而是app的context时[code lang=”java”](XXXActivity.this.getApplicationContext()),[/code]就会出现如下的错误：[code lang=”java”]android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activitycontext requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?E/AndroidRuntime(10382): at android.app.ContextImpl.startActivity(ContextImpl.java:622)E/AndroidRuntime(10382): at android.content.ContextWrapper.startActivity(ContextWrapper.java:258)E/AndroidRuntime(10382): at android.text.style.URLSpan.onClick(URLSpan.java:62)[/code]由于URLSpan.onClick中调用startActivity是由系统控制的，所以我们必须传入activity的contex,才不会出现如上的异常，导致程序退出。 7. 另外一个context的问题：如果你在一个单实例的对象中，有个注册监听器的行为的话，那么传给这个单实例 对象的context，就必须是ApplicationContext了，否则会出现:receiver leak的错误。 8. 控件有时不能充满整个屏幕: [code lang=”java”]LinearLayout panel = new LinearLayout(this);LinearLayout.LayoutParams llp = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.FILL_PARENT);panel.setLayoutParams(llp);root.addView(panel);[/code] 而应该是： [code lang=”java”]LinearLayout panel = new LinearLayout(this);LinearLayout.LayoutParams llp = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.FILL_PARENT);root.addView(panel. llp);[/code]9.按照以下的方式启动service，但是service没有起来[code lang=”java”] Intent service = new Intent(this, FuncService.class); startService(service);[/code]很有可能是忘了在AndroidManifest.xml中注册FuncService[code lang=”xml”]&lt;service android:name=&quot;com.android.example.FuncService&quot;/&gt;[/code] 10.TextView中为什么会在有些行尾出现”…”字符,当然不是所有手机都是有问题，本来笔者刚开始也以为可能是 手机的ROM问题,认真review了代码，发现如下的代码：[code lang=”java”] mIntroView = (TextView) findViewById(R.id.description); mIntroView.setEllipsize(TruncateAt.END);[/code]问题是上面的第2行，之前是因为要限定文本的行数，后来去掉限制，没有去掉以上的代码。 该行代码会导致很多的ROM上：只要一个文本行的文字在一个手机屏幕行显示不下的话，就自动在 行尾截断并在行尾添加”…”,而之前没有问题是因为：全部显示的时候，我调用了如下方法：[code lang=”java”]mIntro.setMaxLines(Integer.MAX_VALUE);[/code] 11.不要太相信工具，比如Eclipse里面的断点遇到多线程什么，经常不起作用/走不到，这时候别太早下结论断点地方出错了， 所以每个工程都应该有日志的开关，通过查看日志来确认，某个路径是否走到或者某个变量的值，。。。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"android monkey测试工具简介与实例","slug":"android/android-monkey-e6-b5-8b-e8-af-95-e5-b7-a5-e5-85-b7-e7-ae-80-e4-bb-8b-e4-b8-8e-e5-ae-9e-e4-be-8b","date":"2012-11-06T17:54:34.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/63825/","link":"","permalink":"http://quanke.name/posts/63825/","excerpt":"","text":"Monkey测试简介当Monkey程序在模拟器或设备运行的时候，如果用户出发了比如点击，触摸，手势或一些系统级别的事件的时候，它就会 产生随机脉冲，所以可以用Monkey用随机重复的方法去负荷测试你开发的软件. 最简单的方法就是用用下面的命令来使用Monkey，这个命令将会启动你的软件并且触发500个事件. $ adb shell monkey -v -p your.package.name 500更多的关于命令Monkey的命令的信息，可以查看UI/ApplicationExerciser Monkey documentation page. com.android.stk com.android.htmlviewer com.android.globalsearch com.android.gpstest com.android.googlesearch wnc.w88.engineermode com.android.calculator2 com.android.inputmethod.latin com.svox.pico com.android.soundrecorder com.android.packageinstaller android.tts com.android.spare_parts com.android.globaltime com.android.sdksetup com.quicinc.bluetooth com.android.email com.qualcomm.qx.neocore com.android.development com.android.term com.android.server.vpn com.android.contacts com.android.camera wnc.w88.factorymode com.android.providers.applicati com.android.providers.settings com.android.voicedialer com.android.phone com.android.providers.contacts com.android.launcher com.android.mms com.android.providers.telephony com.android.providers.userdicti com.android.providers.media com.android.providers.calendar com.android.calendar com.android.providers.drm com.android.providers.downloads com.android.alarmclock com.android.settings com.android.qualcomm com.android.browser com.android.musicMonkey是一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的用户事件流，实现对正在开发的应 用程序进行压力测试。Monkey包括许多选项，它们大致分为四大类：· 基本配置选项，如设置尝试的事件数量。 · 运行约束选项，如设置只对单独的一个包进行测试。 · 事件类型和频率。 · 调试选项。在Monkey运行的时候，它生成事件，并把它们发给系统。同时，Monkey还对测试中的系统进行监测，对下列三种情况进 行特殊处理： · 如果限定了Monkey运行在一个或几个特定的包上，那么它会监测试图转到其它包的操作，并对其进行阻止。 · 如果应用程序崩溃或接收到任何失控异常，Monkey将停止并报错。 · 如果应用程序产生了应用程序不响应(application not responding)的错误，Monkey将会停止并报错。 按照选定的不同级别的反馈信息，在Monkey中还可以看到其执行过程报告和生成的事件。Monkey基本用法 可以通过开发机器上的命令行或脚本来启动Monkey。由于Monkey运行在模拟器/设备环境中，所以必须用其环境中的shell 来进行启动。可以通过在每条命令前加上adb shell来达到目的，也可以进入Shell后直接输入Monkey命令。基本语法如下： $ adb shell monkey [options] 如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包。下面是一个更为典 型的命令行示例，它启动指定的应用程序，并向其发送500个伪随机事件： $ adb shell monkey -p your.package.name -v 500 命令选项参考 下表中列出了Monkey命令行可用的全部选项。 类别选项说明 常规--help列出简单的用法。 -v命令行的每一个-v将增加反馈信息的级别。Level 0(缺省值)除启动提示、测试完成和最终结果之外，提供较少信息。Level 1提供较为详细的测试信息，如逐个发送到Activity的事件。Level 2提供更加详细的设置信息，如测试中被选中的或未被选 中的Activity。 事件-s &lt;seed&gt;伪随机数生成器的seed值。如果用相同的seed值再次运行Monkey，它将生成相同的事件序列。 –throttle &lt;milliseconds&gt;在事件之间插入固定延迟。通过这个选项可以减缓Monkey的执行速度。如果不指定该选项，Monkey将不会被延迟，事件 将尽可能快地被产成。 –pct-touch &lt;percent&gt;调整触摸事件的百分比(触摸事件是一个down-up事件，它发生在屏幕上的某单一位置)。 –pct-motion &lt;percent&gt;调整动作事件的百分比(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成)。 –pct-trackball &lt;percent&gt;调整轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)。 –pct-nav &lt;percent&gt;调整“基本”导航事件的百分比(导航事件由来自方向输入设备的up/down/left/right组成)。 –pct-majornav &lt;percent&gt;调整“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：5-way键盘的中间按键、回退按键、菜单按 键) –pct-syskeys &lt;percent&gt;调整“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、Start Call、End Call及音量控制键)。 –pct-appswitch &lt;percent&gt;调整启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的 一种方法。 –pct-anyevent &lt;percent&gt;调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等。 约束限制-p &lt;allowed-package-name&gt;如果用此参数指定了一个或几个包，Monkey将只允许系统启动这些包里的Activity。如果你的应用程序还需要访问其它包 里的Activity(如选择取一个联系人)，那些包也需要在此同时指定。如果不指定任何包，Monkey将允许系统启动全部包里 的Activity。要指定多个包，需要使用多个 -p选项，每个-p选项只能用于一个包。 -c &lt;main-category&gt;如果用此参数指定了一个或几个类别，Monkey将只允许系统启动被这些类别中的某个类别列出的Activity。如果不指定任 何类别，Monkey将选 择下列类别中列出的Activity： Intent.CATEGORY_LAUNCHER或Intent.CATEGORY_MONKEY。要 指定多个类别，需要使用多个-c选项，每个-c选 项只能用于一个类别。 调试–dbg-no-events设置此选项，Monkey将执行初始启动，进入到一个测试Activity，然后不会再进一步生成事件。为了得到最佳结果，把它 与-v、一个或几个包约 束、以及一个保持Monkey运行30秒或更长时间的非零值联合起来，从而提供一个环境，可以监视 应用程序所调用的包之间的转换。 –hprof设置此选项，将在Monkey事件序列之前和之后立即生成profiling报告。这将会在data/misc中生成大文件(~5Mb)，所以要 小心使用它。 –ignore-crashes通常，当应用程序崩溃或发生任何失控异常时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件， 直到计数完成。 –ignore-timeouts通常，当应用程序发生任何超时错误(如“Application Not Responding”对话框)时，Monkey将停止运行。如果设置此选项 ，Monkey将继续向系统发送事件，直到计数完成。 –ignore-security-exceptions通常，当应用程序发生许可错误(如启动一个需要某些许可的Activity)时，Monkey将停止运行。如果设置了此选项， Monkey将继续向系统发送事件，直到计数完成。 –kill-process-after-error通常，当Monkey由于一个错误而停止时，出错的应用程序将继续处于运行状态。当设置了此选项时，将会通知系统停止发 生错误的进程。注意，正常的(成功的)结束，并没有停止启动的进程，设备只是在结束事件之后，简单地保持在最后的状 态。 –monitor-native-crashes监视并报告Android系统中本地代码的崩溃事件。如果设置了–kill-process-after-error，系统将停止运行。 –wait-dbg停止执行中的Monkey，直到有调试器和它相连接。monkey [-p ALLOWED_PACKAGE [-p ALLOWED_PACKAGE] …][-c MAIN_CATEGORY [-c MAIN_CATEGORY] …][–ignore-crashes] [–ignore-timeouts][–ignore-security-exceptions] [–monitor-native-crashes][–kill-process-after-error] [–hprof][–pct-touch PERCENT] [–pct-motion PERCENT][–pct-trackball PERCENT] [–pct-syskeys PERCENT][–pct-nav PERCENT] [–pct-majornav PERCENT][–pct-appswitch PERCENT] [–pct-flip PERCENT][–pct-anyevent PERCENT][–wait-dbg] [–dbg-no-events] [-f scriptfile][–port port][-s SEED] [-v [-v] …] [–throttle MILLISEC]COUNT讲了这么多，好像很枯燥，很难懂，即使看完了选项也不知道如何使用首先我们应该明白我们不可能使用monkey来制定做一样测试，重复做很多次，因为monkey是伪随机的，就是说虽然有一 定规律可循，但是并不是我们就可以指定动作，但是我们可以通过添加命令选项来将操作限制在一定的范围内。monkey -v -p com.android.camera –throttle 5000 –pct-anyevent 100 500这条命令的解释是：-v显示默认程度的信息；-p com.android.camera是指定测试的程序，// Allowing start of Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.android.camera/.Camera } in package com.android.camera这是开始测试的camera的内容–throttle 5000 设定延时–pct-anyevent 100设定启动activity的百分比为100%如果没有指定，我们可以看到在开始执行的时候8个事件（上面的选项中有介绍）的百分比如下： monkey -v -p com.android.camera –throttle 5000 500monkey -v -p com.android.camera –throttle 5000 500:Monkey: seed=0 count=500:AllowPackage: com.android.camera:IncludeCategory: android.intent.category.LAUNCHER:IncludeCategory: android.intent.category.MONKEY// Event percentages:// 0: 15.0%// 1: 10.0%// 2: 15.0%// 3: 25.0%// 4: 15.0%// 5: 2.0%// 6: 2.0%// 7: 1.0%// 8: 15.0% 指定事件之后 monkey -v -p com.android.camera –throttle 5000 –pct-anyevent 100 500monkey -v -p com.android.camera –throttle 5000 –pct-anyevent 100 500:Monkey: seed=0 count=500:AllowPackage: com.android.camera:IncludeCategory: android.intent.category.LAUNCHER:IncludeCategory: android.intent.category.MONKEY// Event percentages:// 0: 0.0%// 1: 0.0%// 2: 0.0%// 3: 0.0%// 4: 0.0%// 5: 0.0%// 6: 0.0%// 7: 0.0%// 8: 100.0% 最后count就是事件数设定为500 MONKEY 测试实例接下来看一个实例 Monkey 的用法是$ adb shell monkey -p your.package.name -v 500 ，首先，我们要找到应用程序在Emulator中所对应的包名，我一开始是一个个目录找得，前7步完成了这项工作，最终发现应用程序包都在 data/data下，你可以在shell中cd data/data，然后ls查看当前Emulator中的所有应用程序包。 假如我们想对SDK中的APIDemos做压力测试， 1.在Eclipse中新建工程，将 F:\\android-sdk-windows \\platforms\\android-2.0\\samples\\ApiDemos添加到工程中点击运行，此时，他的APK应该加载到了Emulator 上 2.在命令行输入adb shell 3.输入ls查看当前文件夹下的目录，执行结果如下 C:\\Documents and Settings\\Administrator&gt;adb shell lslssqlite_stmt_journalsconfigcachesdcarddetcsystemsyssbinprocinit.rcinit.goldfish.rcinitdefault.propdatarootdev 4.应用程序包都在data下，我们输入cd data进入data文件夹，如下 cd datacd data 5.输入ls查看文件夹下的内容，如下所示： lslsmisclocaldataapp-privateapppropertyanrbackupdontpanicdalvik-cachesystemlost+found 6.还有个data，所有的应用程序就在这个data下了， 进入这个data，然后输入ls如下： cd datacd data lslscom.android.mmscom.android.providers.applicationscom.android.globalsearchcom.android.calculator2com.android.spare_partscom.android.gesture.buildercom.android.musiccom.android.sdksetupcom.android.packageinstallercom.android.fallbackcom.android.providers.settingscom.android.providers.drmcom.android.developmentcom.android.providers.telephonycom.android.inputmethod.pinyincom.android.htmlviewercom.android.settingscom.android.netspeedcom.android.providers.userdictionarycom.android.browsercom.android.contactscom.android.alarmclockcom.android.cameracom.android.providers.contactsjp.co.omronsoft.openwnncom.android.launchercom.android.phonecom.android.soundrecordercom.google.android.providers.enhancedgooglesearchcom.svox.picocom.android.customlocalecom.android.termcom.android.providers.downloadscom.android.providers.mediacom.android.emailandroid.ttscom.android.inputmethod.latincom.android.server.vpncom.example.android.apis 7.最后一个就是我们刚才加载的APIDemo的应用程序包 8.可以直接输入monkey -p com.example.android.apis -v 50，结果如下，也可以退出shell，在命令行输入，adb shell monkey -p com.example.android.apis -v 500 ，运行过程中，Emulator中的应用程序在不断地切换画面，可以看一下，呵呵：） monkey -p com.example.android.apis -v 50monkey -p com.example.android.apis -v 50:Monkey: seed=0 count=50:AllowPackage: com.example.android.apis:IncludeCategory: android.intent.category.LAUNCHER:IncludeCategory: android.intent.category.MONKEY// Event percentages:// 0: 15.0%// 1: 10.0%// 2: 15.0%// 3: 25.0%// 4: 15.0%// 5: 2.0%// 6: 2.0%// 7: 1.0%// 8: 15.0%:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10000000;component=com.example.android.apis/.ApiDemos;end// Allowing start of Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.example.android.apis/.ApiDemos } in package com.example.android.apis:Sending Pointer ACTION_MOVE x=-4.0 y=2.0:Sending Pointer ACTION_UP x=0.0 y=0.0// Allowing start of Intent { cmp=com.example.android.apis/.ApiDemos } in package com.example.android.apis:Sending Pointer ACTION_DOWN x=207.0 y=282.0:Sending Pointer ACTION_UP x=189.0 y=289.0// Allowing start of Intent { cmp=com.example.android.apis/.app.Intents } inpackage com.example.android.apis:Sending Pointer ACTION_DOWN x=95.0 y=259.0:Sending Pointer ACTION_UP x=95.0 y=259.0:Sending Pointer ACTION_DOWN x=295.0 y=223.0:Sending Pointer ACTION_UP x=290.0 y=213.0:Sending Pointer ACTION_MOVE x=-5.0 y=3.0ropped: keys=0 pointers=0 trackballs=0 flips=0 Network stats: elapsed time=3799ms (3799ms mobile, 0ms wifi, 0ms not connected)// Monkey finished","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"android中的spannable String 使用记录","slug":"android/spannablestring-e8-ae-b0-e5-bd-95","date":"2012-11-05T07:02:48.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/15972/","link":"","permalink":"http://quanke.name/posts/15972/","excerpt":"","text":"SpannableStringTextView是用来显示文本的，有时需要给TextView中的个别字设置为超链接，或者设置个别字的颜色、字体等，那就需要用到Spannable对象，可以借助Spannable对象实现以上设置[code lang=”java”]myTextView = (TextView) this.findViewById(R.id.myTextView); //创建一个 SpannableString对象SpannableString sp = new SpannableString(&quot;这句话中有百度超链接,有高亮显示，这样，或者这样，还有斜体.&quot;);//设置超链接sp.setSpan(new URLSpan(&quot;http://www.baidu.com&amp;quot;), 5, 7,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);//设置高亮样式一sp.setSpan(new BackgroundColorSpan(Color.RED), 17 ,19,Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);//设置高亮样式二sp.setSpan(new ForegroundColorSpan(Color.YELLOW),20,24,Spannable.SPAN_EXCLUSIVE_INCLUSIVE);//设置斜体sp.setSpan(new StyleSpan(android.graphics.Typeface.BOLD_ITALIC), 27, 29, Spannable.SPAN_EXCLUSIVE_INCLUSIVE);//SpannableString对象设置给TextViewmyTextView.setText(sp);//设置TextView可点击myTextView.setMovementMethod(LinkMovementMethod.getInstance());[/code]textview显示不同的颜色、样式来表示，需要用到SpannableString对象来处理下面是从网上找的一段代码，已验证过：[code lang=”java”]mTextView = (TextView)findViewById(R.id.test);SpannableString tSS = new SpannableString(“SpannableString学习中”);tSS.setSpan(new BackgroundColorSpan(Color.RED), 0, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); //红色高亮tSS.setSpan(new UnderlineSpan(), 15, 18,Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); //下划线tSS.setSpan(new StyleSpan(android.graphics.Typeface.BOLD_ITALIC), 2, 5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); //斜体mTextView.setText(tSS);[/code]关键方法：[code lang=”java”]public void setSpan (Object what, int start, int end, int flags)[/code]主要是start跟endstart是起始位置,无论中英文，都算一个。从0开始计算起。end是结束位置，所以处理的文字，包含开始位置，但不包含结束位置。 下面解决点击不同文字跳转到不同activity的问题：直接贴代码：[code lang=”java”]import android.app.Activity;import android.os.Bundle;import android.text.SpannableString;import android.text.Spanned;import android.text.method.LinkMovementMethod;import android.text.style.ClickableSpan;import android.view.View;import android.view.View.OnClickListener;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;public class TextViewJump2Activity extends Activity {/* Called when the activity is first created. /private TextView mClickableText;@Overridepublic void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);LinearLayout layout = new LinearLayout(this);mClickableText = new TextView(this);mClickableText.setClickable(true);mClickableText.setTextSize(20); layout.addView(mClickableText);setContentView(layout);mClickableText.setText(getClickableSpan());mClickableText.setMovementMethod(LinkMovementMethod.getInstance());}private SpannableString getClickableSpan() {View.OnClickListener l = new View.OnClickListener() {//如下定义自己的动作public void onClick(View v) {Toast.makeText(TextViewJump2Activity.this, &quot;Click Success&quot;, Toast.LENGTH_SHORT).show();//在这里就可以做跳转到activity或者弹出对话框的操作了}};SpannableString spanableInfo = new SpannableString(&quot;This is a test, Click Here!&quot;);int start = 16;int end = spanableInfo.length();spanableInfo.setSpan(new Clickable(l), start, end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);return spanableInfo;}}class Clickable extends ClickableSpan implements OnClickListener {private final View.OnClickListener mListener;public Clickable(View.OnClickListener l) {mListener = l;}@Overridepublic void onClick(View v) {mListener.onClick(v);}}[/code]转自：http://blog.csdn.net/rockcoding/article/details/7231756","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"RelativeLayout的基本属性用法以及代码实现","slug":"android/relativelayout","date":"2012-11-04T19:13:31.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/50246/","link":"","permalink":"http://quanke.name/posts/50246/","excerpt":"","text":"RelativeLayout，顾名思义，就是以“相对”位置/对齐 为基础的布局方式。android.widget.RelativeLayout 有个 继承自android.view.ViewGroup.LayoutParams 的内嵌类 LayoutParams，使用这个类的实例调用 RelativeLayout.addView 就可以实现“相对布局”。他比LinearLyout更灵活的为控件布置位置. 在新版本中属性的设置可能有变化，具体请看官方api RelativeLayout 的属性：// 相对于给定ID控件 android:layout_above 将该控件的底部置于给定ID的控件之上; android:layout_below 将该控件的底部置于给定ID的控件之下; android:layout_toLeftOf 将该控件的右边缘与给定ID的控件左边缘对齐; android:layout_toRightOf 将该控件的左边缘与给定ID的控件右边缘对齐; android:layout_alignBaseline 将该控件的baseline与给定ID的baseline对齐; android:layout_alignTop 将该控件的顶部边缘与给定ID的顶部边缘对齐; android:layout_alignBottom 将该控件的底部边缘与给定ID的底部边缘对齐; android:layout_alignLeft 将该控件的左边缘与给定ID的左边缘对齐; android:layout_alignRight 将该控件的右边缘与给定ID的右边缘对齐; // 相对于父组件 android:layout_alignParentTop 如果为true,将该控件的顶部与其父控件的顶部对齐; android:layout_alignParentBottom 如果为true,将该控件的底部与其父控件的底部对齐; android:layout_alignParentLeft 如果为true,将该控件的左部与其父控件的左部对齐; android:layout_alignParentRight 如果为true,将该控件的右部与其父控件的右部对齐; // 居中 android:layout_centerHorizontal 如果为true,将该控件的置于水平居中; android:layout_centerVertical 如果为true,将该控件的置于垂直居中; android:layout_centerInParent 如果为true,将该控件的置于父控件的中央; // 指定移动像素 android:layout_marginTop 上偏移的值; android:layout_marginBottom 下偏移的值; android:layout_marginLeft 左偏移的值; android:layout_marginRight 右偏移的值; example: android:layout_below = “@id/*“ android:layout_alignBaseline = “@id/*“ android:layout_alignParentTop = true android:layout_marginLeft = “10px” 以下是代码中的用法： [code lang=”java”]import android.app.Activity;import android.os.Bundle;import android.widget.;import android.view.; public class RLTest extends Activity { private RelativeLayout rl; private Button btn1; private Button btn2; private Button btn3; private Button btn4; private static final int ID_BTN1 = 1; private static final int ID_BTN2 = 2; private static final int ID_BTN3 = 3; private static final int ID_BTN4 = 4; /** Called when the activity is first created. */ @Override public void onCreate(Bundle icicle) { super.onCreate(icicle); rl = new RelativeLayout(this); btn1 = new Button(this); btn1.setText(&amp;quot;----------------------&amp;quot;); btn1.setId(ID_BTN1); RelativeLayout.LayoutParams lp1 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); lp1.addRule(RelativeLayout.ALIGN_WITH_PARENT_TOP); lp1.addRule(RelativeLayout.CENTER_HORIZONTAL, RelativeLayout.TRUE); // btn1 位于父 View 的顶部，在父 View 中水平居中 rl.addView(btn1, lp1 ); btn2 = new Button(this); btn2.setText(&amp;quot;|\\n|\\n|\\n|\\n|\\n|&amp;quot;); btn2.setId(ID_BTN2); RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); lp2.addRule(RelativeLayout.POSITION_BELOW, ID_BTN1); lp2.addRule(RelativeLayout.ALIGN_LEFT, ID_BTN1); // btn2 位于 btn1 的下方、其左边和 btn1 的左边对齐 rl.addView(btn2, lp2); btn3 = new Button(this); btn3.setText(&amp;quot;|\\n|\\n|\\n|\\n|\\n|&amp;quot;); btn3.setId(ID_BTN3); RelativeLayout.LayoutParams lp3 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); lp3.addRule(RelativeLayout.POSITION_BELOW, ID_BTN1); lp3.addRule(RelativeLayout.POSITION_TO_RIGHT, ID_BTN2); lp3.addRule(RelativeLayout.ALIGN_RIGHT, ID_BTN1); // btn3 位于 btn1 的下方、btn2 的右方且其右边和 btn1 的右边对齐（要扩充） rl.addView(btn3,lp3); btn4 = new Button(this); btn4.setText(&amp;quot;--------------------------------------------&amp;quot;); btn4.setId(ID_BTN4); RelativeLayout.LayoutParams lp4 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); lp4.addRule(RelativeLayout.POSITION_BELOW, ID_BTN2); lp4.addRule(RelativeLayout.CENTER_HORIZONTAL, RelativeLayout.TRUE); // btn4 位于 btn2 的下方，在父 Veiw 中水平居中 rl.addView(btn4,lp4); setContentView(rl); } }[/code]","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android下基于XML的Graphics （转）","slug":"android/android-xml-graphics","date":"2012-11-04T19:01:07.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/18810/","link":"","permalink":"http://quanke.name/posts/18810/","excerpt":"","text":"原文地址：http://qq361119908.iteye.com/blog/656281 以前作图一般有两种方式：1、UI把图形设计好我们直接贴。2对于那些简单的图形，如矩形、扇形这样的图形，一般的系统的API会提供这样的接口。但是在Android下，有第三种画图方式，介于二者之间，结合二者的长处。如下的代码：这是一个Progress的style里面的代码，描述的是进度条的未达到的图形。原本以为这是一个图片，后来仔细的跟踪代码，发现居然是xml。像这种shape corners gradient等等这还是第一次碰到。shape 表示是一个图形，corners表示是有半径为5像素的圆角，gradient表示一个渐变。这样作图简单明了，并且可以做出要求很好的图形，并且节省资源。属性 android:shape=”rectangle” 表示 默认的是长方形。 gradient 产生颜色渐变 ,属性 android:angle 表示从哪个角度开始变，貌似只有90的整数倍可以 。 #ff4100ff蓝色 #ff4100ff绿色 &lt;solid android:color=&quot;#ff4100ff&quot;/&gt;实心的 填充里面 &lt;stroke 描边，采用那样的方式将外形轮廓线画出来 android:dashWidth=&quot;3dp&quot; android:dashGap=&quot;2dp&quot; 默认值为0 android:width=&quot;2dp&quot; android:color=&quot;#FF00ff00&quot; 笔的粗细， android:dashWidth=&quot;5dp&quot; android:dashGap=&quot;5dp&quot; 实现“- - -”这样的效果。 dashWidth指的是一条小横线的宽度 android:dashGap 指的是小横线与小横线的间距。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"[转]WebP格式图片的新功能","slug":"other/e8-bd-acwebp-e6-a0-bc-e5-bc-8f-e5-9b-be-e7-89-87-e7-9a-84-e6-96-b0-e5-8a-9f-e8-83-bd","date":"2012-11-03T19:30:43.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/13961/","link":"","permalink":"http://quanke.name/posts/13961/","excerpt":"","text":"自从我们宣布WebP格式图片后，我们一直在努力提高和增强WebP。今天，我们很高兴分享一些关于WebP的新的功能和扩展。 新功能 WebP的压缩算法有了显著的提高，同时完全保持了与以前版本的兼容。在解码方面，亦有所增强。 新的解码方式，可以逐步从网络上下载图片到您的计算机中，这一特性在Chrome 12以上的浏览器中得到应用，用户不必等待下载整个图片。 在编码方面，我们更加注重压缩图片的细节。对于其中的每一个环节，我们调整压缩和过滤图片的不同部分，重新分配，以达到最好的效果。WebP现在能够保留图像的原始许多细节。 更多支持 Chrome浏览器和Opera浏览器现在原生支持WebP图片。Gmail和Picasa网络相册也可以分享、发送和接收WebP图片。WebP格式图片已经应用于Google搜索结果的即时预览功能中，这样可以增加用户访问的速度。 如果你想使用或编辑WebP图片，你可以使用Pixelmator，ImageMagick软件，或Photoshop专门针对WebP的开发插件和Java VP8的解码器。在开源社区，Mac用户可使用MacPorts Mac OS X的软件包，Linux用户可使用Debian，或openSUSE和Gentoo的包，Apache HTTP服务器包亦可使用。Windows用户，可以下载WebP编解码器。在微软Office 2010，Windows媒体中心和照片编辑等软件中，将会支持解码WebP。 好了。这些新功能让你我感到非常的兴奋，一如既往的，谢谢你们的反馈和对开源社区的源码贡献。 via Chromium官方博客 转载文章请注明：文章转载自：Chrome迷 (http://www.chromi.org)本文标题：WebP格式图片的新功能本文地址：http://www.chromi.org/archives/11920","categories":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}],"tags":[],"keywords":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}]},{"title":"android ListView 布局属性","slug":"android/android-listview-e5-b8-83-e5-b1-80-e5-b1-9e-e6-80-a7","date":"2012-11-03T00:19:39.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/20159/","link":"","permalink":"http://quanke.name/posts/20159/","excerpt":"","text":"去除listview缓存颜色，当然也可以改缓存颜色，此时将缓存色设成透明的 （设置滑动时生成的item底色为透明，以此来显示父控件的背景）: listview.setCacheColorHint(0); 或者， android:cacheColorHint=”#00000000” 去除view与view之间的阴影在xml中配置: android:fadingEdge=”none” 去除listview边界线，null可以设成其他drawable中的资源可以设置间隔线样式: listview.setDivider(null); 设置ListView中Item被选中（聚焦）时的底色: android:listSelector=”@android:color/transparent” 去除ListView滑动时的滚动条: android:scrollbars=”none” 其他ListView相关设置： android:scrollbarThumbHorizontal=”” //滚动轴游标 android:scrollbarTrackVertical=”” //滚动轴背景、 对应分辨率 120dpi对象ldpi，160dpi对应mdpi，240dpi对应hdpi","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"编译Android出错：Unable to execute dex: Java heap space ","slug":"other/e7-bc-96-e8-af-91android-e5-87-ba-e9-94-99-ef-bc-9aunable-to-execute-dex-java-heap-space","date":"2012-11-02T22:15:16.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/49391/","link":"","permalink":"http://quanke.name/posts/49391/","excerpt":"","text":"昨天在编译运行(Run As Android Application)同事写的应用(移植)时，提示Unable to execute dex: Java heap space，刚开始以为是Android SDK没装好，于是我写了个Hello Android程序来验证，Hello Android可以运行。 于是，我Google了一下，据说是因为升级了ADT缘故(好像是Android小组的回复)，将最新的ADT换回之前的，或者使用Android小组(?)说的Fix了的版本就可以了(这一点我没有试验)。 其实，继续使用ADT14也是可以的，这需要修改Eclipse的配置文件，也就是网上很多人说的那样，修改Eclipse安装目录下eclipse.ini文件: 1)在文件开头添加 -vmD:\\Program Files\\Java\\jre6\\bin\\javaw.exe 其中，D:\\Program Files\\Java\\jre6是本人机器上JRE的路径，需要根据实际情况修改 2)搜索–launcher.XXMaxPermSize，将其下一行的 256m 改为 512m 其中，红色标出的部分可能不同的Eclipse版本，数字(256)不同。 3)搜索-vmargs -vmargs-Xms40m-Xmx384m 将 -Xms40m-Xmx384m 改为 -Xms512m-Xmx1024m 并在其后加上 -XX:MaxPermSize=256m 同上，可能不同版本的Eclipse，红色标出的部分，数字(40和384)会不同。 然后重启Eclipse，编译出错的工程即可。 出处：http://blog.sina.com.cn/s/blog_69b1501d01013b00.html","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android View如何获取焦点","slug":"android/android-view-e5-a6-82-e4-bd-95-e8-8e-b7-e5-8f-96-e7-84-a6-e7-82-b9","date":"2012-11-02T20:32:54.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/53237/","link":"","permalink":"http://quanke.name/posts/53237/","excerpt":"","text":"Android新启动Activity，dialog或者其他窗体中中包含EditText， 新启动的activity的焦点默认在EditText上，这是android系统会弹出软键盘，挤压activity本来的界面，影响美观。 因此最好在新窗体创建时，最好在onCreate()方法中将焦点放在另一个view上. view使用requestFocus()焦点，但是如果让button或者textView之类控件直接使用requestFocus()方法，则无法获取焦点，焦点会依然在editText上。 只能在使用View的requestFocus()方法之前调用下面2个方法，view才可获取焦点: [code lang=”java”] view.setFocusable(true); view.setFocusableInTouchMode(true); [/code] 然后调用 requestFocus()即可获取焦点。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"android编程中设置文本的中文字体","slug":"android/android-e7-bc-96-e7-a8-8b-e4-b8-ad-e8-ae-be-e7-bd-ae-e6-96-87-e6-9c-ac-e7-9a-84-e4-b8-ad-e6-96-87-e5-ad-97-e4-bd-93","date":"2012-11-02T17:25:18.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/48895/","link":"","permalink":"http://quanke.name/posts/48895/","excerpt":"","text":"请将ttf字体文件放入sdcard的文件夹中（放到程序里面也可以，这是只是演示） [code lang=”java”]text1.setTypeface(Typeface.createFromFile(&quot;/mnt/sdcard/font/SIMLI.ttf&quot;)); [/code] 效果如下图","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Android歌词秀设计思路（1）SafetyTimer","slug":"android/android-e6-ad-8c-e8-af-8d-e7-a7-80-e8-ae-be-e8-ae-a1-e6-80-9d-e8-b7-af-ef-bc-881-ef-bc-89safetytimer","date":"2012-11-01T22:17:42.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/40606/","link":"","permalink":"http://quanke.name/posts/40606/","excerpt":"","text":"原创作品，允许转载，转载时请务必以超链接形式标明文章 原始出处 、作者信息和本声明。否则将追究法律责任。http://craftsman1970.blog.51cto.com/3522772/659906","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"iOS开发者论坛-iPhone开发，iPad开发，iOS开发交流，iOS代码实例，应用分享，业界新闻！","slug":"ios/ios-e5-bc-80-e5-8f-91-e8-80-85-e8-ae-ba-e5-9d-9b-iphone-e5-bc-80-e5-8f-91-ef-bc-8cipad-e5-bc-80-e5-8f-91-ef-bc-8cios-e5-bc-80-e5-8f-91-e4-ba-a4-e6-b5-81-ef-bc-8cios-e4-bb-a3-e7-a0-81-e5-ae-9e-e4-be-8b","date":"2012-10-30T00:05:53.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/23519/","link":"","permalink":"http://quanke.name/posts/23519/","excerpt":"","text":"iOS开发者社区致力于打造iPhone开发 / iPad开发社区，希望更多的开发者能找到交流的地方，在这里能找到很多代码实例，项目案例，开发书籍，教程以及视频教程等内容，保证让开发者能找到想要的东西！ www.codeios.com","categories":[{"name":"ios开发","slug":"ios","permalink":"http://quanke.name/categories/ios/"}],"tags":[],"keywords":[{"name":"ios开发","slug":"ios","permalink":"http://quanke.name/categories/ios/"}]},{"title":"xCode 4.X 免证书真机发布及调试","slug":"other/xcode-4-x-e5-85-8d-e8-af-81-e4-b9-a6-e7-9c-9f-e6-9c-ba-e5-8f-91-e5-b8-83-e5-8f-8a-e8-b0-83-e8-af-95","date":"2012-10-30T00:04:04.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/935/","link":"","permalink":"http://quanke.name/posts/935/","excerpt":"","text":"由于没有购买苹果的开发者证书，所以目前大多数开发环境都是使用以下的方式实现开发与真机测试（本文部分摘自网络） 【2012年3月15日更新】：目前我使用的是Xcode4.3.1 mac os 10.7.3 最简单的办法就是让xcode不检查签名，直接编译发布。 1、 修改SDKSettings.plist文件：进入SDK目录：xcode4.3版本以前是：/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3（可能是5.0/4.2等）.sdk/xcode4.3及以上版本的目录是：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.1.sdk 打开该目录下的SDKSettings.plist文件，把其中所有的包含REQUIRED的项的值改成NO（在实际就是有2项值需要修改：CODE_SIGNING_REQUIRED和ENTITLEMENTS_REQUIRED）。 2、工程的配置修改：对每个工程进行修改，把所有的Code Signing Identity 全部改为 Don’t Code Sign &nbsp; &nbsp; 旧的方法可以参考： &nbsp; 使用环境：越狱过的iPhone 机器 Mac OS 10.6.8 xCode 4.0.1 及Xcode4.0.2 &nbsp; &nbsp; 操作步骤过程： （一）制作证书 1、 打开 Finder－&gt;应用程序－&gt;实用工具 -&gt; 钥匙串访问 2、单击：”钥匙串访问”选择 “证书” 再选择”创建证书”过程如下图： 3、证书名称必须填写为：”iPhone Developer” ，（不能随便填写）然后点击”创建”。(如图） (二)修改xcode配置文件 注意：由于这些配置文件是系统文件，修改系统文件需要管理员权限才可以进行操作，所以保存的时候不能直接保存，会遇到系统提示”你没有修改此文件得权限”，但可以保存一个副本。可以先修改这个副本，然后再复制到原先的目录，系统会提示你是否修改替换，选择”替换”，这时候是需要管理员密码才可以覆盖原来的文件，输入密码后，修改完成。 1.修改SDKsettings.plist文件。 找到 “ /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk “下得 SDKSettings.plist 文件，修改”Default Properties “项下面得 “CODE_SIGNING_REQUIRED “得值为：NO。 2.修改”/Developer/Platforms/iPhoneOS.platform/Info.plist”文件（用文本编辑器或者Xcode打开）： 增加两项： PROVISIONING_PROFILE_ALLOWED = NO PROVISIONING_PROFILE_REQUIRED = NO 效果如下图所示： 然后将所有”XCiPhoneOSCodeSignContext”替换为”XCCodeSignContext”。 3.修改好配置文件后重启xcode，修改项目的属性 1）点击 项目图标，找到”Build Settings” 找到 “Code Sign Identity” 按照下面得方式设置一下就可以 了。 2） 设置工程属性： 3）然后点击 “Run” 我们会看到工程正在编译，然后弹出如图提示（两次）：我们选择 “总是允许” 4）在项目中添加一个Entitlement.plist文件，设置允许调试。 注：若不操作该步可能连接真机调试的时候还会出现一个错误：Error launching remote program: failed to get the task for process xxx 操作步骤：在Xcode4.X 中这样做： a.在工程中按照这个执行创建一个名为：Entitlement.plist 文件In the File Menu, select New File -&gt; iPhone OS -&gt; Code Signing -&gt; Entitlements. Name the file “Entitlements.plist” and click ‘Finish’. b.打开 这个 “Entitlement.plist”文件，将 “Can be debugged”属性值改为 “YES”。 c.将Code Signing Entitlements 那项得值改为刚刚新建得”Entitlements.plist”. 4。提示选择完后：可以看到 我们就可以看到 程序可以出现在 你得iphone上了。 当你运行程序时，可以通过 organizer 看到你得iphone 运行时打印出来得Log。","categories":[{"name":"ios开发","slug":"ios","permalink":"http://quanke.name/categories/ios/"}],"tags":[],"keywords":[{"name":"ios开发","slug":"ios","permalink":"http://quanke.name/categories/ios/"}]},{"title":"自由梦","slug":"other/e8-87-aa-e7-94-b1-e6-a2-a6","date":"2012-10-29T22:44:57.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/21492/","link":"","permalink":"http://quanke.name/posts/21492/","excerpt":"","text":"夜的微光里有着无限的迷茫 萤火虫在黑暗里漫无目的的舞动着 即使恶魔也无法掩饰 那来自自己眼中的两束绿光 绝望的人们感到了暗夜里滋生着希望 封存的太久了 光明将厚厚的壁障膨胀 纵然是铁壁铜墙 那供魔鬼进出的门也会在开合时 仍然有光亮的泄出 整个世界颠倒了 在恐惧颤栗中 人们忍受着寒冷、寂寞、惊悚 时刻让神经紧张着 肉体上的痛苦是不安情绪的释放 精神上的折磨如同在炼狱中生活 内心的阴冷让更多的人 化作了为虎作伥的厉鬼 他们比魔鬼更让人刻骨铭心的恐惧 魔鬼锁起了光明 光明带走了自由 恶魔们活动在阳光下 体面的装扮让他们看上去更象人类 道貌岸然里过着人一样的生活 它们时刻担心着光明的泄露 睡觉时都睁着一只圆眼 他们害怕所有的人 更让他们害怕的是来自同类中的枭雄 只有魔鬼才可以轻意的制服魔鬼 活着的钟馗让鬼们害怕 死去的钟馗才是鬼们真正的克星 觉醒的过程需要经历一段漫长的艰辛 摸索着前进会有更多的鲜血 将这牢狱般的生活浸泡 房顶不破 墙壁不坏 鲜血也会让这牢狱的地面下沉 最后将这黑暗之屋葬送 殉难者中挺起的是 一个个追寻着光明脖颈 那些来自魔鬼阵营中的魔鬼们的鲜血 与抗争者们是一样的殷红 也是同样汇成浸塌这屋子的一份力量 没有不倒塌的房子 只有倒塌了再重建起来 灾难中的人们在麻木中缓慢地觉醒着 当光明降临时的喜悦还没有平静 新的房子又在人们的诧异中重新建了起来 不要相信别人会给你带来什么 号召你起来推翻魔鬼的 更多的时候也是魔鬼 魔鬼和基督的区别就是 基督把自己送上了祭坛 而魔鬼是鼓惑别人为他上祭坛 善良的人们啊 总是被利用 光明迟迟地难以等到 总是在一出现就被遮盖 人们生活在被欺骗中 沉默中不再相信任何的许诺 冷眼注视着一出出闹剧的表演 华丽中无法掩饰丑陋与拙劣 等待着技穷之后将骷髅现出 无声的抗议将深藏着的愤怒堆积 暴发时化作震动天地的怒吼 在这声音里 无论这黑屋是如何的坚固 爆碎声中还世界一个朗朗乾坤 光明会将自由带来 世界因魔鬼再无法变回魔鬼 迎来期盼已久的梦想 长久的等待 长久的等待 等来的是真实的自由","categories":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}],"tags":[],"keywords":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}]},{"title":"认识HTML5的WebSocket ","slug":"other/e8-ae-a4-e8-af-86html5-e7-9a-84websocket","date":"2012-10-29T21:50:00.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/39609/","link":"","permalink":"http://quanke.name/posts/39609/","excerpt":"","text":"在HTML5规范中，我最喜欢的Web技术就是正迅速变得流行的WebSocket API。WebSocket提供了一个受欢迎的技术，以替代我们过去几年一直在用的Ajax技术。这个新的API提供了一个方法，从客户端使用简单的语法有效地推动消息到服务器。让我们看一看HTML5的WebSocket API：它可用于客户端、服务器端。而且有一个优秀的第三方API，名为Socket.IO。 一、什么是WebSocket API? WebSocket API是下一代客户端-服务器的异步通信方法。该通信取代了单个的TCP套接字，使用ws或wss协议，可用于任意的客户端和服务器程序。WebSocket目前由W3C进行标准化。WebSocket已经受到Firefox 4、Chrome 4、Opera 10.70以及Safari 5等浏览器的支持。 WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。WebSocket并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而WebSocket允许跨域通信。 Ajax技术很聪明的一点是没有设计要使用的方式。WebSocket为指定目标创建，用于双向推送消息。 二、WebSocket API的用法 只专注于客户端的API，因为每个服务器端语言有自己的API。下面的代码片段是打开一个连接，为连接创建事件监听器，断开连接，消息时间，发送消息返回到服务器，关闭连接。 [Copy to clipboard] [ - ] CODE: // 创建一个Socket实例 var socket = new WebSocket(‘ws://localhost:8080’); // 打开Socket socket.onopen = function(event) { // 发送一个初始化消息 socket.send(‘I am the client and I\\’m listening!’); // 监听消息 socket.onmessage = function(event) { console.log(‘Client received a message’,event); }; // 监听Socket的关闭 socket.onclose = function(event) { console.log(‘Client notified socket has closed’,event); }; // 关闭Socket…. //socket.close() }; 让我们来看看上面的初始化片段。参数为URL，ws表示WebSocket协议。onopen、onclose和onmessage方法把事件连接到Socket实例上。每个方法都提供了一个事件，以表示Socket的状态。 onmessage事件提供了一个data属性，它可以包含消息的Body部分。消息的Body部分必须是一个字符串，可以进行序列化/反序列化操作，以便传递更多的数据。 WebSocket的语法非常简单，使用WebSockets是难以置信的容易……除非客户端不支持WebSocket。IE浏览器目前不支持WebSocket通信。如果你的客户端不支持WebSocket通信，下面有几个后备方案供你使用： Flash技术 —— Flash可以提供一个简单的替换。 使用Flash最明显的缺点是并非所有客户端都安装了Flash，而且某些客户端，如iPhone/iPad，不支持Flash。 AJAX Long-Polling技术 —— 用AJAX的long-polling来模拟WebSocket在业界已经有一段时间了。它是一个可行的技术，但它不能优化发送的信息。也就是说，它是一个解决方案，但不是最佳的技术方案。 由于目前的IE等浏览器不支持WebSocket，要提供WebSocket的事件处理、返回传输、在服务器端使用一个统一的API，那么该怎么办呢？幸运的是，Guillermo Rauch创建了一个Socket.IO技术。 三、带Socket.IO的WebSocket Socket.IO是Guillermo Rauch创建的WebSocket API，Guillermo Rauch是LearnBoost公司的首席技术官以及LearnBoost实验室的首席科学家。Socket.IO使用检测功能来判断是否建立WebSocket连接，或者是AJAX long-polling连接，或Flash等。可快速创建实时的应用程序。Socket.IO还提供了一个NodeJS API，它看起来非常像客户端API。 建立客户端Socket.IO Socket.IO可以从GitHub下载，可以把socket.io.js文件包含到页面中： [Copy to clipboard] [ - ] CODE: [/code 此时，Socket.IO在此页面上是有效的，是时候创建Socket了： [code][/code] // 创建Socket.IO实例，建立连接 var socket= new io.Socket(‘localhost’,{ port: 8080 }); socket.connect(); // 添加一个连接监听器 socket.on(‘connect’,function() { console.log(‘Client has connected to the server!’); }); // 添加一个连接监听器 socket.on(‘message’,function(data) { console.log(‘Received a message from the server!’,data); }); // 添加一个关闭连接的监听器 socket.on(‘disconnect’,function() { console.log(‘The client has disconnected!’); }); // 通过Socket发送一条消息到服务器 function sendMessageToServer(message) { socket.send(message); } Socket.IO简化了WebSocket API，统一了返回运输的API。传输包括： WebSocket Flash Socket AJAX long-polling AJAX multipart streaming IFrame JSONP polling 你还可以设置任意的Socket.IO构造器的第二个选项，选项包括： port - 待连接的端口 transports - 一个数组，包含不同的传输类型 transportOptions - 传输的参数使用的对象，带附加属性 Socket.IO还提供了由本地WebSocket API提供的普通连接、断开连接、消息事件。Socket还提供了封装每个事件类型的方法。 四、NodeJS和Socket.IO联合开发 Socket.IO提供的服务器端解决方案，允许统一的客户端和服务器端的API。使用Node，你可以创建一个典型的HTTP服务器，然后把服务器的实例传递到Socket.IO。从这里，你创建连接、断开连接、建立消息监听器，跟在客户端一样。 一个简单的服务器端脚本看起来如下： [Copy to clipboard] [ - ] CODE: // 需要HTTP 模块来启动服务器和Socket.IO var http= require(‘http’), io= require(‘socket.io’); // 在8080端口启动服务器 var server= http.createServer(function(req, res){ // 发送HTML的headers和message res.writeHead(200,{ ‘Content-Type’: ‘text/html’ }); res.end(‘ Hello Socket Lover!‘); }); server.listen(8080); // 创建一个Socket.IO实例，把它传递给服务器 var socket= io.listen(server); // 添加一个连接监听器 socket.on(‘connection’, function(client){ // 成功！现在开始监听接收到的消息 client.on(‘message’,function(event){ console.log(‘Received message from client!’,event); }); client.on(‘disconnect’,function(){ clearInterval(interval); console.log(‘Server has disconnected’); }); }); 你可以运行服务器部分，假定已安装了NodeJS，从命令行执行： [Copy to clipboard] [ - ] CODE: node socket-server.js 现在客户端和服务器都能来回推送消息了！在NodeJS脚本内，可以使用简单的JavaScript创建一个定期消息发送器： [Copy to clipboard] [ - ] CODE: // 创建一个定期（每5秒）发送消息到客户端的发送器 var interval= setInterval(function() { client.send(‘This is a message from the server! ‘ + new Date().getTime()); },5000); 服务器端将会每5秒推送消息到客户端！ 五、dojox.Socket和Socket.IO Persevere的创建者Kris Zyp创建了dojox.Socket。dojox.Socket以Dojo库一致的方式封装了WebSocket API，用于在客户端不支持WebSocket时，使用long-polling替代。 下面是怎样在客户端使用dojox.Socket和在服务器端使用Socket.IO的例子： [Copy to clipboard] [ - ] CODE: var args, ws= typeof WebSocket!= ‘undefined’; var socket= dojox.socket(args= { url: ws? ‘/socket.io/websocket’ : ‘/socket.io/xhr-polling’, headers:{ ‘Content-Type’:’application/x-www-urlencoded’ }, transport: function(args, message){ args.content = message; // use URL-encoding to send the message instead of a raw body dojo.xhrPost(args); }; }); var sessionId; socket.on(‘message’, function(){ if (!sessionId){ sessionId= message; args.url += ‘/‘ + sessionId; }else if(message.substr(0, 3) == ‘~h~’){ // a heartbeat } }); dojox.socket.Reconnect还创建了在套接字失去连接时自动重连。期待包含dojox.Socket的Dojo 1.6版本早日发布。 六、实际应用和WebSocket资源 有很多WebSocke的实际应用。WebSocket对于大多数客户机-服务器的异步通信是理想的，在浏览器内聊天是最突出的应用。WebSocket由于其高效率，被大多数公司所使用。 WebSocket资源 Socket.IO站点：http://socket.io/ WebSocket的Wikipedia：http://en.wikipedia.org/wiki/WebSockets WebSockets.org站点：http://www.websockets.org/ Dojo WebSocket站点：http://www.sitepen.com/blog/2010/10/31/dojo-websocket/","categories":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}],"tags":[],"keywords":[{"name":"服务端开发","slug":"service","permalink":"http://quanke.name/categories/service/"}]},{"title":"[转]程序猿 技术不是你的全部","slug":"other/e8-bd-ac-e7-a8-8b-e5-ba-8f-e7-8c-bf-e6-8a-80-e6-9c-af-e4-b8-8d-e6-98-af-e4-bd-a0-e7-9a-84-e5-85-a8-e9-83-a8","date":"2012-10-29T00:14:23.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/3448/","link":"","permalink":"http://quanke.name/posts/3448/","excerpt":"","text":"在学校的时候，曾一度的迷恋技术，认为掌握了技术后就非常牛X，可以到外面做些项目，从中获取一些报酬，自己更是乐此不疲。并且认为看了很多的技术书籍，学了很多的语言，看了许多牛X技术的底层原理，就自认为自己在这方面是专家权威，高智商的人。当然，可能你希望大家叫你大神、大牛、精英、前辈，自己的虚荣心都得到了小小的满足。 千万不要认为技术牛X了就可以从屌丝变身高富帅，不懂技术的人没有前途 总所周知，程序猿是一个高薪的职业。但是，只有你真正的进入这个行业你才清楚，这个看上去还不错的薪水，你却付出了超过薪水价值的代价。创业型与游戏型公司里面的项目小组一般是5~10个人，因为他们需要快速的开发以应对多变的市场波动，所以程序猿的每天工作时长都在12小时以上，身体和精神收到摧残不说。作为程序猿的你很少有时间去陪陪自己的家人、自己的女友。除了自己工作和技术上的朋友，很少有时间去拓宽自己的朋友圈。久而久之，很多程序猿不爱说话，不爱出门，最终成为宅男。每当想出去走走，散散心，体会体会下什么才是生活而不是生存，你会发现你不仅没有时间，连个志同道合的朋友都找不出来。 反而一些整天跑市场、接待客户的人，在其中锻炼出来了自己的口才，拓展了自己的交际圈，相信假以时日他们必定能够成就一番事业。 别误认为懂技术的人智商高，别认为懂技术的人才有发言权 学生时代可能你还会因为自己懂了一门语言，就可以按照自己的想法为自己写写应用，觉得编程是一件挺神奇的事情。工作之后你会发现，人员的分工是很精细的，策划、运维、测试、美术、推广、程序。程序猿所要做的事情，就是使用最好的技术手段去完成策划交给的任务，最快的最好的方法修复测试提交的bug。一些技术上比较困难的问题，很难实现的功能，你也许会与策划争执个半天，并且嗤之以鼻的认为这些叫你干活的人，都不清楚什么是Java什么是C#。懂技术并不表明你就比别人有多厉害，只是分工不同。看似只用接个电话，写写word就能完成的工作，也许作为程序猿的你也真的干不来。 工作一年以上之后，你会发现，你所需要敲代码的时间比较少，Copy、Paste的时间比较多。很少会有时间去研究下当初自己喜欢的计算机组成、Operating System，因为这些公司中的项目用不上，自己仅剩的技术上的梦想没有了。会感觉自己是否如同卓别林电影《摩登时代》中别捆绑在流水线中重复工作的机器人？半个多世纪过去了科技是进步了，但人们机械工作的模式依然原地踏步。 程序猿—&gt;项目经理—&gt;业务管理，这个并不一定是你的发展方向 很多干了多年的程序猿都去转管理去了,并且很多打算做程序员的人都是以管理职业为目标从而进入程序猿行业的。为什么要转管理，因为程序猿都很苦逼，需要巨大的脑力、并且需要不停歇的学习以防别人超越，但是随着年龄的增大一直burn down下去明显是承受不住的，所以大部分人选择做管理。更多的是因为，程序猿在外界看来也就是一个普通的职员，除了薪水还不错之外，得不到外界人的尊重。每当我跟朋友说，我是做游戏开发的时候，他就会问我，您会写外挂吗？你有时间帮我装装系统吗？在中国 程序猿≠科研人员、程序猿≠科学家，你根本得不到外界人们的认同，于是大家渴望能够成为经理。 其实经理并不比程序猿轻松，他需要思考的东西更多，领导能力（leadership）、表达能力（speech）、控制能力（control）一个都不能少，至少我的经理是这样的。 总结： ①正确的权衡自己的工作与生活的时间，你有家人、爱人、朋友，你需要生存，但更需要懂得如果去生活。偶尔去去旅行、陪陪父母，常锻炼锻炼自己的身体。没有他们，你程序写得再牛X也没有用。你是靠程序生存，并不是抱着他过一辈子。 ②需要有 “剑指苍天，舍我其谁” 的万丈豪情 ，更需要 “注视凝神”的去聆听别人的意见和建议。别人的意见往往很重要，能干加巧干的完成自己工作，才是好程序猿，机械式的重复，只会磨灭自己的意志。 ③需要对自己有一个职业规划，知道自己想干什么，自己还缺少什么，接下来的日子里需要学习什么。对不注重员工发展的公司千万别去，因为那里没有希望。 Ps.我的实习总结，不关于技术，更多的是感悟~~。","categories":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}],"tags":[],"keywords":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}]},{"title":"Android应用程序发布渠道商大全","slug":"android/android-e5-ba-94-e7-94-a8-e7-a8-8b-e5-ba-8f-e5-8f-91-e5-b8-83-e6-b8-a0-e9-81-93-e5-95-86-e5-a4-a7-e5-85-a8","date":"2012-10-28T19:58:07.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/56281/","link":"","permalink":"http://quanke.name/posts/56281/","excerpt":"","text":"1.安智市场地址：http://www.goapk.com/login.php安智市场是目前国内应该算装机量最大的市场了，国内品牌大多数的手机都没有携带Google的市场，所以除了google市场外，应该是国内最重要的一个渠道了，审核一般1-2个工作日。 2.安卓市场地址：http://sc.hiapk.com安卓市场的量是国内仅次于安智市场的，所以也是开发者必不可少的一个渠道，审核一般1-2个工作日，但我最近的一次发布审核了近一个礼拜，不知何故。 3.Google市场地址：https://market.android.com/publishandroid的官方市场，应该说还是蛮重要的一个渠道，但是其注册比较麻烦，需要先注册一个Google CheckOut账户并支付25美元，必须要一张支持Visa的信用卡，然后找一个香港或国外的地址来注册，国内的地址和电话是通不过的，本人使用的是中国银行的国航联名Visa信用卡，google的香港一个地址及电话。android市场的好处就是不要审核直接上线，但你最好去了解一下它的协议内容，如果违反了其条款会将你的应用下架并无法再次上架，多次被下架会导致账号被封。如果你是一个多语言版本的应用，那么它是必不可少的一个渠道了，需要注意的是中国的账户是无法进行发布收费应用的，你需要使用其他支持国家的账户及他国收款信用卡，具体收费应用本人没有经验，请相关人士补充。 3.应用汇地址:http://www.appchina.com/market/dev/index.action应用汇的量也还算可以，属于应该考虑的一个渠道，审核一般1-2个工作日。 4.腾讯手机应用平台地址：http://tap.3g.qq.com:8080/腾讯平台的量也算不错的，虽然跟安智和安卓没法比（目前），但其因为有庞大的用户群体及目前砸钱的推广模式，也是一个必要的渠道，其审核包括审核-测试-上架，一般至少需要3-4个工作日。之前本人注册的时候是需要他们主动发邮件给你，然后你回复信息再由其开账户，但刚才访问有注册信息页面了。 5.91手机商城地址：http://market.sj.91.com/Users/Login.aspx91因为开发有91手机助手及不少手机应用，所以这个渠道也是不能忽略的一个渠道，审核一般2-3个工作日吧，但其提交应用页面比较让人蛋疼，你编辑不好还会打回来。 6.智汇云地址：http://developer.huaweidevice.com/智汇云是华为的市场，因为国内华为的手机市场占有量还可以，加上其C8600和C8650两款手机是电信的0元签约套餐机，销售量不容小看，所以智汇云的用户量还是比较可观的。华为的审核会稍微久一些，可能会要5个工作日以上，好像其测试人员会在他们的所有机器上做测试，并找出适合运行机型。 7.N多网地址：http://www.nduoa.com/signinN多量相对来说就会少上不少了，如果你有足够的精力，那这个渠道还是可以用起来的，审核1-2工作日吧。 8.机锋网地址：http://dev.gfan.com/个人以为跟N多差不多，量也不是很大。 9.联想商城地址：http://developer.lenovomm.com/developer/联想商城之所以放在这里，是因为我的应用一直没上线，所以量未知。联想商城需要提交固定的圆底的图标，另外其审核和测试非常仔细和严格，我的因为一个功能在其机器上一直不理想而一直未获通过。需要说明的是，联想的测试会给出一份详尽的报告，告诉你功能缺陷、Crash出现频率等，其内容会仔细说明具体步骤及结果，所以不失为一个很好的免费测试渠道。一般审核周期在3个工作日以上 10.木蚂蚁地址：http://dev.mumayi.com/developers/这个更蛋疼一点，没有提交平台，只有个提交页面，提交应用后无法查询，但木蚂蚁又还稍微有点量(单从他们的下载统计来看，但这些数据有很大的水分里，本人因为其提交方式一直没上去，反而是他们主动收录我的应用的)所有大家自己看着办吧。 11.eoe亿优地址:http://www.eoemarket.com/亿优的量也是少的可怜。但好像不要审核，自己看着办了。 12.其他剩下还有搜狐、网易应用、安智迷、三星App(英文)、MOTO app（英文）、安卓星空、爱米吧等等这些大家可以都去尝试下，另外有些论坛的渠道，如果有精力也可以去看看。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"设置打开新Activity的动画效果","slug":"other/e8-ae-be-e7-bd-ae-e6-89-93-e5-bc-80-e6-96-b0activity-e7-9a-84-e5-8a-a8-e7-94-bb-e6-95-88-e6-9e-9c","date":"2012-10-28T19:41:30.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/46264/","link":"","permalink":"http://quanke.name/posts/46264/","excerpt":"","text":"package com.jay.demo; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class HomeActivity extends Activity { /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.layout1); Button gotoBtn = (Button) findViewById(R.id.gotobtn); gotoBtn.setOnClickListener(listener); } private OnClickListener listener = new OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(HomeActivity.this, SecondActivity.class); startActivityForResult(intent, 0); // HomeActivity.this.finish(); int version = Integer.valueOf(android.os.Build.VERSION.SDK); if(version &gt; 5 ){ overridePendingTransition(R.anim.zoomin, R.anim.zoomout); } // HomeActivity.this.finish(); } }; }","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"[转]Android研究笔记一-Android的价值观","slug":"other/e8-bd-acandroid-e7-a0-94-e7-a9-b6-e7-ac-94-e8-ae-b0-e4-b8-80-android-e7-9a-84-e4-bb-b7-e5-80-bc-e8-a7-82","date":"2012-10-28T19:04:00.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/3905/","link":"","permalink":"http://quanke.name/posts/3905/","excerpt":"","text":"Intent, Activity, Action这些都是用户概念。使用用户概念而不是技术概念给组件命名，是Android之所以是一个伟大的操作系统的根本原因。在Android里面，一切都是面向用户的。 比如Intent意图，显然是一个用户概念。程序员是没有这样的概念的。这种命名方式的存在，逼使得程序员“使用”用户的语言进行编程，而不是功能式的编程。它事实上已经升华为一种服务式的编程，即：我写的东西不是为了实现某个功能，而是为了实现用户的欲望。是一次非常重要的语义升级。因此说，在Android里面，已经不是面向OO。其面向的已经是用户。是真正的面向用户编程。面向用户并不意味着反OO，只是意味着它的层次比OO更高。 这是由移动平台的本质决定的：移动平台相对于桌面系统，它更像是一个用户的附属品而不是一个工作站。因为对于工作站来说，工作是其中心。而定义一个工作有很多种方法，可以从不同的语义层次进行定义。但更贴近用户的移动系统，显然使用纯粹的用户语义是唯一合适的选择。 文章来自：http://my.oschina.net/digerl/blog/85520","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Github for Windows使用图文教程","slug":"tools/github-for-windows-e4-bd-bf-e7-94-a8-e5-9b-be-e6-96-87-e6-95-99-e7-a8-8b","date":"2012-10-27T19:13:36.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/3833/","link":"","permalink":"http://quanke.name/posts/3833/","excerpt":"","text":"Git已经变得非常流行，连Codeplex现在也已经主推Git。Github上更是充斥着各种高质量的开源项目，比如ruby on rails，cocos2d等等。 对于习惯Windows图形界面的程序员来讲，Github的使用是需要点时间和耐心的，然而最近Github发布了Github for Windows 则大大降低了学习成本和使用难度，他甚至比SVN都简单，好吧，你不信，我们来一步一步过一面： 在http://windows.github.com/下载Github for Windows，然后安装就不说了 登陆，安装好后打开GitHub，用你的GitHub账号登陆。需要注意的事，Github for Windows会帮你创建SSH Key，你打开邮件应该会收到邮件帮你创建SSH Key的信息，这也省了不少事： 创建一个仓库。点击上面的 “+Add” 按钮创建一个新的仓库，输入相关信息： 新建的仓库还没有真正地提交到本地仓库，相当于这只是一个new的修改，github简化了一些操作过程，对于任何修改，只需要添加评论就可以提交到本地仓库，然后这个时候才可以提交到远程仓库，所以我们来添加一条评论： 在每次添加一个评论之后，就相当于向本地仓库提交了一本版本，之后，就可以选择一个版本向远处仓库提交了。 这个时候我们就可以Publish一个仓库了，Publish之后按钮就变成in sync文字，表示以后的修改提交就是同步，这个时候你到你的github上看应该就会多一个仓库了： 添加项目，仓库在本地保存在一个文件夹中，Github for windows会监视这个文件夹，任何修改都会在仓库中看到，然后像上面一样添加评论就可以将修改提交到本地仓库，这里我们打开仓库目录，往里面添加一个项目： 将修改提交到本地仓库，回到Github for windows中，已经可以看到刚才添加的项目了，同样，提交注释提交到本地仓库： 最后，点击sync将本地仓库提交到github 7. 参与开源项目协同开发： github现在已经深度支持Windows开发者了，现在每个在github的开源项目前面都有一个“Clone in Windows”的按钮，我们可以Clone任何我们感兴趣的开源项目，然后在地进行修改，参与开源项目的开发。 点击该按钮之后，浏览器会要求打开Github for Windows，并下载项目至本地，新建一个本地仓库： 总结：github for Windows简化了一些概念和操作，并且几乎所有主要操作都通过图形界面来完成，基本上能完成日常写作了。这些主要的简化包括： 将push到远程仓库简化为一个同步按钮 将提交到本地仓库简化为只需要对一些列修改添加评论 更多的，还包括分支的建立和管理，这部分自己去探索吧，总之，github for Windows确实是一个非常好的工具。","categories":[{"name":"git","slug":"git","permalink":"http://quanke.name/categories/git/"}],"tags":[],"keywords":[{"name":"git","slug":"git","permalink":"http://quanke.name/categories/git/"}]},{"title":"[转]程序员加油站，不是人人都懂的学习要点","slug":"other/e8-bd-ac-e7-a8-8b-e5-ba-8f-e5-91-98-e5-8a-a0-e6-b2-b9-e7-ab-99-ef-bc-8c-e4-b8-8d-e6-98-af-e4-ba-ba-e4-ba-ba-e9-83-bd-e6-87-82-e7-9a-84-e5-ad-a6-e4-b9-a0-e8-a6-81-e7-82-b9","date":"2012-10-25T22:49:54.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/34614/","link":"","permalink":"http://quanke.name/posts/34614/","excerpt":"","text":"学习是一种基础性的能力。然而，“吾生也有涯，而知也无涯。”，如果学习不注意方法，则会“以有涯随无涯，殆矣”。 一.学习也是一种能力 看到这个标题，有人会说：“学习，谁不会?”的确，学习就像吃饭睡觉一样，是人的一种本能，人人都有学习的能力。我们在刚出生的时候，什么也不知道，是一张真正的白纸，我们靠学习的本能，学会了走路、说话、穿衣服…后来，我们上学了，老师把书本上的知识一点一点灌输到我们的脑子里，我们掌握的知识越来越多，与此同时，我们学习能力却好像越来越差了，习惯了被别人喂饱，似乎忘记了怎么来喂自己了。 学习本来只是一种本能，算不上什么能力，然而，经过二十多年的不断学习，学习反而成为了一种真正的能力，因为我们慢慢失去了它，它就更显得珍贵。 在学校里我们基本上被动式学习，然而走出了象牙塔之后，不会再有人对你负责，不会有人主动教你，我们需要主动的学习。所谓的学习能力，其实就是自主学习的能力。 几年前，曾有一本风靡管理界的书，叫《第五项修炼》，这本书倡导建立学习型组织，因为从长远来看，一个组织唯一可持续的竞争优秀，就是比竞争对手更快更好的学习能力。 一个公司如此，一个人又何尝不是如此?众所周知现在是一个知识爆炸的时候代，知识更新非常快。据说，一个大学毕业生所学习到的知识，在毕业之后的2年内，有效的不过剩下5%，更何况我们的学校与社会需要严重脱轨。我们赖以立足的，不在于我们现在掌握了多少知识，而是我们有多强的学习能力! 学习不但是一种能力，而且是一种至关重要的能力，而这种能力的核心，就是学习的方法和心态。 二.买书是最划算的投资 古人云：“书中自有黄金屋，书中自的颜如玉。”这说明先贤们早就认识到，买书是最划算的投资了。 当我刚出道的时候，拿着非常微薄的工资，有一次我向主管抱怨道：“现在的书真贵啊，这点工资连饭都吃不起，更别说买书了!”主管对我说：“不要吝惜买书的钱，宁可忍着不吃饭，也不要忍着不买书，因为买书是回报率的最高的投资了。” 主管的话让我非常震动。后来，我看到喜欢的书时，再有没有手软过。我不断的学习，开发能力也不断的提高，工资水平也获得了大幅度的提高。一年后，我一个月工资的涨幅，就足够买两年的书了。你说，还有比这更划算的投资吗? 一本书，哪怕只有一页纸是有用的，它将所产生的潜在价值，也会远远超过书本身的价格。当然，书不在多，能踏踏实实消化掉一本好书，可能比泛泛而读10本普通书，要更有价值得多。 三.多读经典书 十年前，我刚进入IT行业的时候，真是求知渴，每星期都要往购书中心跑，可惜的是，那时给程序员看的书不像现在这么多，高质量的书就更少了。当时我印象中比较经典的书籍就是《Windows程序设计》、《COM本质论》、《Java编程思想》，还有就是谭浩强的《C语言程序设计》。其它充斥书架的，就是类似于《21天精通XXX》、《XXX从入门到精通》、《XX宝典》这样的书籍。 回首往昔，令我比较郁闷的一件事就是在我最有学习动力的时候，看的高质量的书籍太少，就好像是在长身体的时候，天天吃的是没营养的泡面。当然，这跟没有人指导也有很大的关系，独自一个人学习，让我走了很多的弯路。 软件开发方面的书籍，我大致将其分为三类： (1)浅显的入门类书籍。 这类书的标题往往是《XX天精通XXX》、《XXX从入门到精通》、《XX开发实战》等，这类书往往从软件的安装讲起，喜欢翻译帮助文件。有人批评这类书为烂书、毫无价值，这并不公平。至少我本人，也曾从这些书中学到一些东西。即使是21天系列书，也有适合看的人群，只不过，它一般也就只能看21天而已，过后就可以扔到垃圾堆。这类书只适于还没有入门的初学者，从中学到一些入门的招式。这种书在刚起步的时候一般买上一本就可以了。如果你善于使用搜索引擎，这一本书也可以省了。 (2)国内外高手写的实战类书籍。 这类书实战性很强，把技术及原理讲得很透彻。比如《windows环境下32位汇编语言程序设计》、《深入解析MFC》、《Delphi深度探索》、《深入浅出WPF》、《深入剖析Asp.net组件设计》等。以前这类书都是从国外翻译或从台湾引进，现在国内高手越来越多，出自国内作者的也越来越多。这类书如果在你学习的每个方向看个两三本，并且通过实践消化掉，那么毫无疑问，你会成为一个优秀的程序员。 (3)国外大牛写的、揭露本质、有丰富思想的书。 这类书就是所谓的经典书了，例如《代码大全》、《编程珠玑》、《设计模式》、《重构》、《代码整洁之道》等。经典书就像一个有深度、有思想的朋友，他会给你启发、每次阅读都会有新的收获，这类书具有真正的收藏价值。看经典书永远是正确的选择，它绝不会浪费你的时间，因为经典书是无数人沙里淘金、帮你挑选过的结果。 然而，阅读这类书并不是一件容易的事情，读者需要有丰富的开发经验，才能与作者产生共鸣。真正能消化经典书的人其实不多，这就好像饮酒，一个新手无论如何也品不出葡萄美酒的醇香。在酒桌上，人人都把杯中酒一饮而尽，当有人点评“这个酒不错”的时候，我只能无奈的苦笑一番，真的是甘苦自知。 如果一本经典书你看得很辛苦，很有可能就是因为你功力未够，这种情况下不要着急，慢点来，不妨先将其先束之高阁，多看看第二类实战型书籍，过一段时间再回头来看，也许你会有新的惊喜。 四.不要在上班时间看书 一个善于学习的人，首先要善于利用一切时间来学习。不知是伟大的雷锋叔叔还是鲁迅爷爷曾经说过：“时间就像海绵里的水，只要愿挤，总还是有的。”然而，当我们从上班时间中挤时间学习时，就千万要注意了，不要在上班时间看书! 上班时间看书不但是一件很敏感的事情，而且非常吸引眼球，很快就会引起周遭的不爽。首先老板心里不爽，他想：“我给你钱是让你来工作的，不是来学习的!”;其次同事们也不爽：“我们工作都做不完，瞧，这小子真闲哪!”用不了多久，你就会成为被众人排斥的异类。 当然，你可能会说，“我工作已经做完了，经理没有安排，当然可以学习了”，其实不然。你完成了一件事情，不等于所有的事情都完成了。一个优秀的员工，应该是主动要工作，而不是被动的等工作。工作完成以后，你至少还可以： (1)主动汇报给你的经理，请他来检查你的成果，并安排新的任务; (2)如果公司这一段时间确实比较闲，没有什么具体的任务，可以进行代码重构、优化; (3)你还可以主动请缨，承担额外的工作或更艰巨的任务。 (4)如果一定要学习，也只能对着电脑屏幕来学习，纸质书最多只能拿来翻阅一下，而不能一直捧着，以免影响到其他人的情绪。 五、只学习与工作相关的东西 我曾发现不少程序员在学习方面找不到方向，一会学学C#，一会学学Java，看了最新的编程语言排行榜，又觉得该学C++。这样左抓抓，右挠挠，只会让你觉得更痒。 学习最忌三心二意。俗话说：“伤其十指不如断其一指”，每门都学一点，还不如专心学好一个方向。这个道理谁都懂，可是又该学哪个方向呢?难道只能跟着感觉走吗? 不!最实际的方向，应该跟着工作走，工作需要什么，我们就学什么，把工作需要的技能熟练掌握。我们为什么要学习和工作弱相关的东西呢?是为了转行或跳槽吗?可是，如果我们连现在本职工作都不能做好，又怎么能保证到新的岗位、用新学的技能就可以做得更好呢? 学习与工作需要的的东西，有很多好处： 首先，可以集中精力，在某一方面钻研得更加深入。所谓“百招会不如一招绝”，有了绝招，你还怕不能在“武林”立足吗?《天龙八部》中的慕容复武功博学无比，最后还不是被只会一招六脉神剑的段誉打得落花流水? 其次，可以学得更快、更深入，因为学习更具有针对性，而且可以立即在工作中运用，可以马上检验出学习的效果，对存在的问题可以进行深入的研究，因此掌握的知识也会更加的牢固。 第三，学习与工作结合在一起，工作时间也就成了学习时间，这样突破了三个8小的限制。有人说，我们每天所有拥有的时间可以分为三个8小时，工作8小时，睡觉8小时，另外还有8小时自己可以自由支配的时间。工作和睡觉的两个8小时大家都一样，决定人生高度的是另外这个8小时。当我们把学习的焦点放到与工作相关的知识上时，工作时间中的很大一部分，同时也就成了宝贵的学习时间，这真是一举两得的美事啊。 六.织网式的学习 知识的广度和深度都很重要。作为一个程序员，深入把握技术细节，是写出优质代码的保证。但对于一个项目经理而言，知识的广度更显重要。项目中碰到的问题往往是综合性的，只有具有广博的知识，才能快速的对问题进行分析和定位。在程序员通往项目经理的道路上，我们必须有意识的扩大自己的知识面，形成更完善的知识体系。 每个人的知识体系就好比是一张网，我们学习其实就是要织这样一张网。 我曾看过渔网的编织过程，渔网虽大，也是一个结点起步，一个点一个点的编出来的，编织的过程中，始终只有一根主线。 学习又何尝不是这样，知识体系的大网也是由许多小的结点组成，要结这样一张网，只能由一个点起步。牵住一条主线，织出一个个的点，由点带出面，最后才能形成这张大网。 我曾经编写过一个网络信息采集软件，这个软件可以从具有列表页网站中按字段设置采集信息，支持自定义字段、页面多级关联、下载附件、支持多种数据库、可视化定义等特性。刚开始时，觉得这个软件也是一个比较大的功能点而已，后来发现这个不起眼的功能关联着大量的知识点，在开发过程中， 我顺藤摸瓜，各个击破，对很多知识点进行了细致的学习研究，软件开发完成后，个人的知识体系网也进一步得到了补充和完善。 图1 由知识点形成知识网 七.问题是最好的学习机会 日本经营之神松下幸之助曾经说过：“工作就是不断发现问题、分析问题、最终解决问题的一个过程，晋升之门将永远为那些随时解决问题的人敞开着。”可见，工作过程中有问题是正常，没有问题那才是真正的问题。在发生问题能时，能勇于面对问题、解决问题的人，才是公司真正的核心骨干。 现实中，很多人总是千方百计回避问题，当上司安排一项艰巨的任务时，也是想尽办法推托。殊不知，对于个人而言，其实问题是最好的学习机会。往往那些愿意接受困难工作的人，能力会变得越来越强，那就是因为他们在克服困难的过程中取得了巨大的进步。 有一次，一位项目经理对我说：“有一个问题，客户有一台HP服务器要装磁盘阵列，没人会做，怎么办啊?”“可以学啊，没有人愿意去吗?”“我都问了，没人想去。”“哦，正好明天我有时间，我也没装过磁盘阵列，那我明天去学着弄一下。”我说的是真心话。第二天早上，当我准备出发时，项目经理告诉我不用我去了，因为项目组好几个同事都想去“学着弄一下”。 结果服务器很快就装好了，远远没有之前大家想像的那么困难嘛。更重要的是，在解决这个问题的过程中，大家都学会了怎么装磁盘阵列。 碰到困难时，迎难而上吧，千万不要拒绝这个最好的学习机会! 八.经常思考总结 子曰：“学而不思则罔”。只学习不思考，就会迷惑，难以把握事情的本质。这就好比一个学武之人，只习得其形，而未得其神，难以成为真正的高手。 一个程序员从入门，到成为高手的过程中，往往要经过几次顿悟。顿悟会让你跳出知识的丛林，一切豁然开朗，仿佛打通了全身的奇经八脉一般奇妙。记得我有一次，顿悟到了一个很简单的结论：“原来高级编程语言中的类库是封装了Windows API来实现的。”后来碰到一些自带类库无法实现的功能时，我就会想到，其实可以通过调用Windows API来实现。利用这个思路，我解决了一些看起来很难的问题，得到老板的赏识，从而很快获得提升。 顿悟非常可贵，然而它不是随便发生的，而是经过一次次苦苦思索之后、灵光闪现的结果。思考的过程，其实就是将外在的知识内化为自己的知识的过程，而顿悟，则是批量的实现这种内化，将无数个知识点连接在一起，达到融会贯通的境界。 九、克服“高原现象” 爱学习的人都会有这样的经历，学习持续了一段时间之后，往往会有一个瓶颈期，长时间似乎很久没有什么进步，于是内心非常着急。 这种情况实际上这是由人的学习规律决定的一种“高原现象”。据研究，学习者在刚开始进步快，随后有一个明显的或长或短的进步停顿期，后期进步慢，中间的停顿期叫高原期。 图2 技能学习练习曲线在我看来，高原期实质是一个消化期，由于前期的学习积累了太多的知识点，这些知识点在大脑中乱作一团，还没有形成一个知识体系。这时需要一定的时间来消化它，将它融会贯通，经常思考总结可以快速帮你跨过高原期。 在处于高原期的时候，还可以换一个相关的方向来学习，例如编程语言学不下去了，你可以学习一下设计模式，设计模式也学不下去了，再换成数据库。通过学习这些相关的知识，不但补齐了知识体系中的短板，而且各个知识点之间可以互相启发，帮助你实现顿悟，跨过高原期。 十、学习要有好心态 (1)学习要静心 急于求成是学习过程中普遍存在的一种心态。这可以理解，毕竟作为一个程序员，要学的东西实在太多了，而社会又是那样的浮躁，让人觉得一切都是那样的不安全、不确定，似乎只有学得快一点，才能跟上社会的脚步。 可是“欲速则不达”，想快快的学，往往会形成东一榔头、西一棒槌的学习方式，每一个点都没有吃透。心沉不下去，知识也会沉不下去。要想成为真正的高手，只能静下心来，一步一个脚印的攀登。 (2)学习是一个持续一生的过程 人生的过程，就是一个自我完善过程。 孔子曾经说：“吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。”可见孔子也不是天生的圣人，也在不停的学习、进步，从“志于学”到最后“从心所欲，不逾矩”，孔子一共花了55年的时间。 作为一个程序员，更是需要不断更新自己的知识。我们所知道的东西，就像一个白色的圆圈，圈外则是黑暗的未知的世界。当圆圈越大，所接触到的黑暗部分就越多。我们只有不停的学习，打破更多的黑暗，找到更多光明。 (3)保持饥饿，保持愚蠢 看了《乔布斯传》之后，我最喜欢的一句话是“求知若饥，虚心若愚”(Stay Hungry,Stay Foolish)，其实我更喜欢它更原生态的翻译“保持饥饿，保持愚蠢”。我们只有认识到自己还很饥饿和愚蠢，才会像没吃饱一样，由衷的需要学习、爱上学习。 当然，知易行难，知行合一才是学习的最高境界。我也始终是一个学习者，一直在路上。","categories":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}],"tags":[],"keywords":[{"name":"随笔","slug":"essay","permalink":"http://quanke.name/categories/essay/"}]},{"title":"OpenCore介绍","slug":"android/opencore-e4-bb-8b-e7-bb-8d","date":"2012-10-24T06:46:33.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/45509/","link":"","permalink":"http://quanke.name/posts/45509/","excerpt":"","text":"一、OpenCore简介 OpenCore是Android的多媒体核心，采用C++实现，定义了全功能的操作系统移植层（OSCL），各种基本的功能均被封装成类的形式，各层次之间的接口多使用继承等方式。 从宏观上来看，它主要包含了两大方面的内容： PVPlayer：提供媒体播放器的功能，完成各种音频(Audio)、视频(Video)流的回放(Playback)功能。 PVAuthor：提供媒体流记录的功能，完成各种音频(Audio)、视频(Video)流的以及静态图像捕获功能 。 二、OpenCore在Android系统中的位置 首先来一张抽象一点的图（如下）： 从上图我们可以感觉到OpenCore封装了一些接口给应用程序。具体是什么呢？下面以音频/视频播放器为例，看看具体的过程： 其中， VideoView.java 是一个media集成的高层的JAVA类，这个类的文件在/frameworks/base/core/java/android/widget/。它集成了MediaPlayer和SurfaceView的类，可以作为一个UI元素（View）直接放在界面中，用于视频的播放。 MediaPlayer.java和MediaRecorder.java 为基本的处理音频数据的Java类，它里面直接调用很多本地接口。 android_media_MediaPlayer.cpp 和android_media_MediaRecorder.cpp 封装了相应的JNI接口。 三、多媒体播放的过程 视频文件（流）播放过程就像一个状态机。图形如下，其中椭圆形代表MediaPlayer类的状态；线代表状态变化，由源状态指向目标状态，它旁边标注有状态变化的条件，其中单箭头的线表示同步（synchronous）方法调用，双箭头表示异步（asynchronous）方法调用。这幅状态运行图显示了视频播放时的各种状态之间的切换方法，除此之外，为了方便用户处理，在一些状态下，系统会调用回调函数，只要用户提前注册好相应的回调函数即可。状态回调函数注册方法ErrorOnErrorListener.onError()setOnErrorListener(android.media.MediaPlayer.OnErrorListener)PreparedOnPreparedListener.onPrepared()setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener)StartedOnBufferingUpdateListener.onBufferingUpdate()setOnBufferingUpdateListener(OnBufferingUpdateListener)使用seekTo(int)后OnSeekComplete.onSeekComplete()setOnSeekCompleteListener(OnSeekCompleteListener)PlaybackCompletedOnCompletionListener.onCompletion()setOnCompletionListener(OnCompletionListener) 四、OpenCore内部的重要概念 OSCL ：Operating System Compatibility Library (操作系统兼容库)，包含了一些操作系统底层的操作，为了更好地在不同操作系统移植。包含了基本数据类型、配置、字符串工具、IO、错误处理、线程等内容，类似一个基础的C++库。PVMF ：PacketVideo Multimedia Framework(PV多媒体框架)，在框架内实现一个文件解析(parser) 和组成(composer) 、编解码 的NODE ，也可以继承其通用的接口，在用户层实现一些NODE。 五、OpenCore的内部调度过程 PlayerDriver创建后进入OSCL 线程来处理消息，engine 创建完各个node 节点并将其连接起来，剩下的就是node间的通讯问题，各node状态变化会触发oscl对其下一次调度，参与到oscl调度中的模块都必须提供一个Run函数 ，oscl会去call这个函数。 内部流程图如下： 文件的播放过程如下： 判断源文件的格式，根据文件格式创建对应的文件解析节点ParseNode： PVPlayerRecognizerRegistry负责文件格式识别，并将结果返回给PVPlayerEngine； 通过文件解析节点（ParseNode）来完成音视频文件格式的解析，并将文件中的音频、视频数据送到对应的解码节点进行解码； 解码节点（DecNode）通过调用底层的opencoreMAX 通用接口实现媒体数据的解码；对于一个普通的视频文件，存在2个解码节点：音频解码节点 和视频解码节点 ； 六、解码的内部流程： 参考OpenMax 的相关介绍。 七、Android上的视频输出方案 为了使opencore的视频播放支持Android系统，谷歌定义了两套视频输出方案，一种是由硬件 厂商实现硬件加速的视频输出（ libopencorehw.so ），硬件视频输出里面可以调用硬件Overlay模块对输出的视频数据进行硬件混叠，这样输出效率会非常的高；另外一种为谷歌定义的软视频输出，该软视频输出定义为AndroidSurfaceOutput 类，这种方案中系统会调用SurfaceFilnger对输出视频数据进行混叠，该混叠为软件混叠，执行效率比较低。 八、OpenCore的测试方式参考《Build OpenCORE 2.05 on x86 Linux .PDF》和《pvplayer_engine_unit_test_guide.pdf》","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"android使用mina需要注意的问题","slug":"android/android-e4-bd-bf-e7-94-a8mina-e9-9c-80-e8-a6-81-e6-b3-a8-e6-84-8f-e7-9a-84-e9-97-ae-e9-a2-98","date":"2012-10-22T19:45:12.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/12875/","link":"","permalink":"http://quanke.name/posts/12875/","excerpt":"","text":"1.第三方jar包的使用 如果在Java Build Path中使用Add External JARs这种方式，运行时会有找不到类的错误（我的上面有，如果你没出现，恭喜你），上网查了几种方式，我这边运行通过的方式如下： 在项目中建个lib文件夹，把需要的jar包复制进去，在 Java Build Path中使用 Add JARs ，选择项目下的lib包中的jar文件即可，发布apk文件时会自动打包进去。 网上还有一种方式，在 Java Build Path 中使用 Add Library， 选择 User Libaray -&gt; 新建一个User Libaray的方式，这种我没试，有通过的同志们说下。软件开发 本人推荐项目建文件夹的方式。 2. mina包的使用之日志 我使用的是mina2.0.2，如果没有特殊需求，使用mina-core-2.0.2核心包就可以了。 关键点在这里： mina中使用slf4j作为日志框架（不知道slf4j的同志们请google下）， 这个只是一个日志框架，是没有实现的，你需要一个具体的实现，比如说log4j（具体使用方法我就不说了，很简单，实在不知道给我发站内信）。使用mina必须把slf4j的jar包也引入，那么你也要引入一个实现日志的包，在普通客户端开发这个不是问题，但在android中，已经有了一个日志实现，而且配合logcat，其功能是很强大的，那么怎么配合slf4j来使用呢？（ps：slf4j是必须的，mina要用到） 这里就要感谢网络了，我在slf4j的官网居然发现有一个slf4j-android的jar包http://www.slf4j.org/android/ 同志们可以去看看，（强烈推荐去看看）下载这个包，引入到项目中，注意啊，这个包是不能和slf4j-api包共存的，我的解决方式是只使用slf4j-android这个包，其余的日志相关的包都删除，（其实别的日志包也没什么用，我们有android提供的日志类），这样mina就不会报日志类找不到的错误了，而且日志都输出到logcat，调试程序也方便。这方面我们要感谢slf4j，如果没有这个实现，mina使用就麻烦了，我能想到的方式就只有更改mina源代码，重新编译了，当然你也可以自己提供日志实现类。 android的日志类中有一个限制，tag不能超过23个字符（你不知道tag，我也不知道该怎么说了…），slf4j也给解决了，官网上面有介绍。（再建议看下官网） 3. mina包的使用之NioSocketConnectortp-link 在android2.1中好像没有问题，但在android2.2中会有Bad address family的异常，这个异常是由于IPv6引起的，这个bug已经在 http://code.google.com/p/android/issues/detail?id=9431 （同志们看看吧），android2.2不支持IPV6,在使用nio 时会有问题，有建议是使用io，可以解决，但我们如果一定要使用nio呢，解决方法如下： 设置系统属性： System.setProperty(“java.net.preferIPv6Addresses”, “false”); 就这一行解决问题，有同志可能要问，在哪加啊？系统开始的地方加，比如说是service，在onCreate（）中启动mina前加上就行，activity中也一样。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":" Android TTS 的开发 ","slug":"android/android-tts-e7-9a-84-e5-bc-80-e5-8f-91","date":"2012-10-16T22:18:06.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/15957/","link":"","permalink":"http://quanke.name/posts/15957/","excerpt":"","text":"1、首先要tts是否有所需语言的语音数据，如果没有需安装它[code lang=”java”] Intent checkIntent = new Intent(); checkIntent.setAction(TextToSpeech.Engine.ACTION_CHECK_TTS_DATA); startActivityForResult(checkIntent, MY_DATA_CHECK_CODE); private TextToSpeech mTts; protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == MY_DATA_CHECK_CODE) { if (resultCode == TextToSpeech.Engine.CHECK_VOICE_DATA_PASS) { // success, create the TTS instance mTts = new TextToSpeech(this, this); } else { // missing data, install it Intent installIntent = new Intent(); installIntent.setAction( TextToSpeech.Engine.ACTION_INSTALL_TTS_DATA); startActivity(installIntent); } } } [/code] 2、设置地区（语言） [code lang=”java”] mTts.setLanguage(Locale.US);[/code] 3、判断是否支持某地区的语言 [code lang=”java”] mTts.isLanguageAvailable(Locale.FRANCE))[/code] 或[code lang=”java”] mTts.isLanguageAvailable(new Locale(&quot;spa&quot;, &quot;ESP&quot;)))[/code] 或[code lang=”java”] mTts.isLanguageAvailable(new Locale(&amp;quot;spa&amp;quot;)) [/code]如果没有语言数据，会返回TextToSpeech.LANG_MISSING_DATA，否则返回ACTION_CHECK_TTS_DATA 4、处理发音[code lang=”java”] String myText1 = &amp;quot;Did you sleep well?&amp;quot;; String myText2 = &amp;quot;I hope so, because it&apos;s time to wake up.&amp;quot;; mTts.speak(myText1, TextToSpeech.QUEUE_FLUSH, null); mTts.speak(myText2, TextToSpeech.QUEUE_ADD, null); [/code] 5、加参数 [code lang=”java”] HashMap&amp;lt;String, String&amp;gt; myHashAlarm = new HashMap(); myHashAlarm.put(TextToSpeech.Engine.KEY_PARAM_STREAM, String.valueOf(AudioManager.STREAM_ALARM)); mTts.speak(myText1, TextToSpeech.QUEUE_FLUSH, myHashAlarm); mTts.speak(myText2, TextToSpeech.QUEUE_ADD, myHashAlarm); [/code] 6、加完成监听 [code lang=”java”] mTts.setOnUtteranceCompletedListener(this); myHashAlarm.put(TextToSpeech.Engine.KEY_PARAM_STREAM, String.valueOf(AudioManager.STREAM_ALARM)); mTts.speak(myText1, TextToSpeech.QUEUE_FLUSH, myHashAlarm); myHashAlarm.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, &amp;quot;end of wakeup message ID&amp;quot;); // myHashAlarm now contains two optional parameters mTts.speak(myText2, TextToSpeech.QUEUE_ADD, myHashAlarm); public void onUtteranceCompleted(String uttId) { if (uttId == &amp;quot;end of wakeup message ID&amp;quot;) { playAnnoyingMusic(); } } [/code] 7、将发音录入文件 [code lang=”java”] HashMap&amp;lt;String, String&amp;gt; myHashRender = new HashMap(); String wakeUpText = &amp;quot;Are you up yet?&amp;quot;; String destFileName = &amp;quot;/sdcard/myAppCache/wakeUp.wav&amp;quot;; myHashRender.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, wakeUpText); mTts.addSpeech(wakeUpText, destFileName); mTts.speak(wakeUpText, TextToSpeech.QUEUE_ADD, myHashAlarm); [/code] 8、关闭tts[code lang=”java”] mTts.shutdown(); mTts.synthesizeToFile(wakuUpText, myHashRender, destFileName); [/code]","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Go 语言中文社区","slug":"golang/go-e8-af-ad-e8-a8-80-e4-b8-ad-e6-96-87-e7-a4-be-e5-8c-ba","date":"2012-10-15T18:39:19.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/52774/","link":"","permalink":"http://quanke.name/posts/52774/","excerpt":"","text":"Go 中文社区Go官方网站 http://golang.org/Go中文官网 http://golang-china.org/中文论坛(测试中…) http://bbs.golang-china.org/中文用户讨论组(邮件) https://groups.google.com/group/golang-china/中文翻译(SVN) http://code.google.com/p/golang-china/GitHub与Google Code同步(GIT) http://github.com/border/golang-chinaQQ群: 102319854（申请加入请到中文论坛留言） Go中文文档翻译计划 Install Go 初稿完成Go Tutorial 初稿完成Effective Go 初稿25%翻译的详细信息参考 翻译计划 http://code.google.com/p/golang-china/wiki/TranslationProject","categories":[{"name":"Go语言","slug":"golang","permalink":"http://quanke.name/categories/golang/"}],"tags":[],"keywords":[{"name":"Go语言","slug":"golang","permalink":"http://quanke.name/categories/golang/"}]},{"title":"开源书籍《Go Web 编程》","slug":"other/e5-bc-80-e6-ba-90-e4-b9-a6-e7-b1-8d-e3-80-8ago-web-e7-bc-96-e7-a8-8b-e3-80-8b","date":"2012-09-30T20:05:20.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/12549/","link":"","permalink":"http://quanke.name/posts/12549/","excerpt":"","text":"《Go Web 编程》以下是作者原话，与cndemoz.com无关 因为自己对Web开发比较感兴趣，所以最近抽空在写一本开源的书籍《Go Web编程》《Build Web Application with Golang》。写这本书不表示我能力很强，而是我愿意分享，和大家一起分享Go写Web应用的一些东西。 对于从PHP/Python/Ruby转过来的同学了解Go怎么写Web应用开发的 对于从C/C++转过来的同学了解Web到底是怎么运行起来的我一直认为知识是用来分享的，让更多的人分享自己拥有的一切知识这个才是人生最大的快乐。 这本书目前我放在Github上，我现在基本每天晚上抽空会写一些，时间有限、能力有限，所以希望更多的朋友参与到这个开源项目中来。 撰写方法文件命名每个章节建立一个md文件，如第11章的第3节，则建立11.3.md。 代码文件代码文件置于src目录之下。每小节代码按目录存放。如第11章的第3节的代码保存于src/11.3/目录下。在正文中按需要添加代码。 格式规范正文请参看已有章节的规范，要注意的是，每个章节在底部都需要有一个links节，包含“目录”，“上一节”和“下一节”的链接。 代码代码要go fmt后提交。注释文件注明其所属章节。 如何编译build.go依赖markdown的一个解析包，所以第一步先 go get github.com/russross/blackfriday 这样读者就可以把相应的Markdown文件编译成html文件，执行go build build.go，执行生成的文件，就会在底目录下生成相应的html文件 如何编译目前可以把相应的Markdown编译成html文件，执行go build build.go，执行生成的文件，就会在底目录下生成相应的html文件。 致谢首先要感谢Golang-China的QQ群102319854，里面的每一个人都很热心，同时要特别感谢几个人 四月份平民 (review代码) Hong Ruiqi (review代码) BianJiang (编写go开发工具Vim和Emacs的设置) Oling Cat(review代码) Wenlei Wu(提供一些图片展示) 授权许可除特别声明外，本书中的内容使用CC BY-SA 3.0 License（创作共用 署名-相同方式共享3.0许可协议）授权，代码遵循BSD 3-Clause License（3项条款的BSD许可协议）。 开始阅读开始阅读","categories":[{"name":"Go语言","slug":"golang","permalink":"http://quanke.name/categories/golang/"}],"tags":[],"keywords":[{"name":"Go语言","slug":"golang","permalink":"http://quanke.name/categories/golang/"}]},{"title":"ubuntu GIT 安装与使用","slug":"linux/ubuntu-git-e5-ae-89-e8-a3-85-e4-b8-8e-e4-bd-bf-e7-94-a8","date":"2012-09-30T19:56:12.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/65055/","link":"","permalink":"http://quanke.name/posts/65055/","excerpt":"","text":"1.安装程序 sudo apt-get install git sudo apt-get install git-core2.那通过命令更新版本库git clone git://git.kernel.org/pub/scm/git/git.git3.创建一个新版本库mkdir gittutorch cd gitturtorch git-init-db这样，一个空的版本库就创建好了，并在当前目录中创建一个叫 .git 的子目录。你可以用 ls -a 查看一下，并请注意其中的三项内容： 一个叫 HEAD 的文件，我们现在来查看一下它的内容： $ cat .git/HEAD现在 HEAD 的内容应该是这样： ref: refs/heads/master我们可以看到，HEAD 文件中的内容其实只是包含了一个索引信息，并且，这个索引将总是指向你的项目中的当前开发分支。一个叫 objects 的子目录，它包含了你的项目中的所有对象，我们不必直接地了解到这些对象内容，我们应该关心是存放在这些对象中的项目的数据。一个叫 refs 的子目录，它用来保存指向对象的索引。具体地说，子目录 refs 包含着两个子目录叫 heads 和 tags，就像他们的名字所表达的意味一样：他们存放了不同的开发分支的头的索引, 或者是你用来标定版本的标签的索引。请注意：master 是默认的分支，这也是为什么 .git/HEAD 创建的时候就指向 master 的原因，尽管目前它其实并不存在。 git 将假设你会在 master 上开始并展开你以后的工作，除非你自己创建你自己的分支。另外，这只是一个约定俗成的习惯而已，实际上你可以将你的工作分支叫任何名字，而不必在版本库中一定要有一个叫 master 的分支，尽管很多 git 工具都认为 master 分支是存在的。现在已经创建好了一个 git 版本库，但是它是空的，还不能做任何事情，下一步就是怎么向版本库植入数据了。第四步：植入内容跟踪信息：git-add：为了简明起见，我们创建两个文件作为练习： $ echo “Hello world” &gt; hello $ echo “Silly example” &gt; example我们再用 git-add 命令将这两个文件加入到版本库文件索引当中： $ git-add hello examplegit-add 实际上是个脚本命令，它是对 git 内核命令 git-update-index 的调用。因此上面的命令和下面的命令其实是等价的： $ git-update-index –add hello example如果你要将某个文件从 git 的目录跟踪系统中清除出去，同样可以用 git-update-index 命令。例如： $ git-update-index –force-remove foo.cgit-add 可以将某个目录下的所有内容全都纳入内容跟踪之下，例如： git-add ./path/to/your/wanted 。但是在这样做之前，应该注意先将一些我们不希望跟踪的文件清理掉，例如，gcc 编译出来的 .o 文件，vim 的交换文件 ..swp 之类。应该建立一个清晰的概念就是，git-add 和 git-update-index 只是刷新了 git 的跟踪信息，hello 和 example 这两个文件中的内容并没有提交到 git 的内容跟踪范畴之内。第五步：提交内容到版本库：git-commit既然我们刷新了 Git 的跟踪信息，现在我们看看版本库的状态： $ git-status我们能看到 git 的状态提示：# Initial commit## Updated but not checked in:(will commit)# new file: examplenew file: hello#提示信息告诉我们版本库中加入了两个新的文件，并且 git 提示我们提交这些文件，我们可以通过 git-commit 命令来提交： $ git-commit -m “Initial commit of gittutor reposistory”第六步：查看当前的工作：git-diffgit-diff 命令将比较当前的工作目录和版本库数据库中的差异。现在我们编辑一些文件来体验一下 git 的跟踪功能。 $ echo “It’s a new day for git” &gt;&gt; hello我们再来比较一下，当前的工作目录和版本库中的数据的差别。 $ git-diff差异将以典型的 patch 方式表示出来：diff –git a/hello b/helloindex 802992c..8fdaa4e 100644— a/hello+++ b/hello@@ -1 +1,2 @@Hello world+It’s a new day for git此时，我们可以再次使用组合命令 git-update-index 和 git-commit 将我们的工作提交到版本库中。 $ git-update-index hello $ git-commit -m “new day for git”实际上，如果要提交的文件都是已经纳入 git 版本库的文件，那么不必为这些文件都应用 git-update-index 命令之后再进行提交，下面的命令更简捷并且和上面的命令是等价的。 $ git-commit -a -m “new day for git”一些命令：初始化git数据库 $ git-init-db添加文件 $ git-add hello.c查看修改、提交记录 $ git-log创建分支 $ git-branch roredu查看分支 $ git-branch masterroredu切换工作分支 $ git-checkout roreduSwitched to branch “roredu” $ git-branchmaster roredu提交到当前工作分支并书写标记。 $ git-commit -a创建xux分支对于master的补丁文件。 $ git-format-patch master roredu配置开发者自己的签名和email。 $ git-config –global user.name “roredu” $ git-config –global user.email “roredu@gmail.com”修改文件名 $ git-mv roredu.c helight.c删除文件 $ git-rm roredu.c协同工作，下载项目：git-clone ssh@wtb:192.168.0.21/home/wtb/NetBeansProjects/project1这里wtb是用户名， 192.168.0.21是项目所在机器的IP 后面跟着的是项目目录和名称","categories":[{"name":"git","slug":"git","permalink":"http://quanke.name/categories/git/"}],"tags":[],"keywords":[{"name":"git","slug":"git","permalink":"http://quanke.name/categories/git/"}]},{"title":"Windows下Git的安装和配置","slug":"other/windows-e4-b8-8bgit-e7-9a-84-e5-ae-89-e8-a3-85-e5-92-8c-e9-85-8d-e7-bd-ae","date":"2012-09-30T19:08:38.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/29409/","link":"","permalink":"http://quanke.name/posts/29409/","excerpt":"","text":"Git是Linux的创始人Linus Torvalds在2006年开发的，Linus自嘲说是一个“傻瓜内容跟踪器”。在Windows下使用Git，可以使用 Cygwin + Git，也可以使用 Msys + Git。 Cygwin太庞大了，我更倾向于使用小巧的Msys。 使用Msys + Git的话，也有两个选择：msys-cn + git，或者 msysgit。 # 安装msys-cn + gitMsys-cn是Msys的中文化项目，托管在Google Code上，里面提供了一个软件包管理器mpkg，同时提供了一系列实用工具，其中就包括git。 msys-cn的主页：http://code.google.com/p/msys-cn 下载msys-cn： http://msys-cn.googlecode.com/files/MSYS-Update.7z 下载完毕解压缩，运行msys.bat进入命令行界面。运行下面的命令来在线安装git：$ mpkg –install git如果网速太慢，可以下载git.mpkg文件后再安装。下载地址：http://msys-cn.googlecode.com/files/git.mpkg$ mpkg –add git如果一切顺利，现在就可以运行git命令了。# 安装msysgitmsysgit是直接将git整合到msys里的一个项目，也是托管在Google Code上： http://code.google.com/p/msysgit 下载最新版本的安装程序，安装即可。注意安装时最好选择默认的设置，这样保证不和系统的cmd命令冲突。 安装完毕在开始菜单里会有Git菜单，里面有Git Bash和Git GUI。点击Git Bash进入msysgit命令行环境。 msysgit中文输入输出可能会出现以下几方面的问题： ls输出乱码在用户主目录下新建一个bash配置文件.bashrc来保存配置信息：$ echo “alias ls=’ls –show-control-chars –color=auto’” &gt;&gt; ~/.bashrc 命令行中不能输入中文：修改 /etc/inputrc：set output-meta onset convert-meta off git st输出中文显示为UNICODE编码：$ git config –system core.quotepath false git log 输出显示为乱码：在~/.bashrc中增加less命令的编码设置：$ echo export LESSCHARSET=utf-8 &gt;&gt; ~/.bashrc以上的根目录指msysgit的安装目录，默认安装目录是C:Program FilesGit。默认用户主目录是我的文档。 msysgit默认集成open ssh客户端。要访问github上的项目，需要使用ssh-keygen来生成本地公私钥对，添加公钥到github上，就可以在本地提交了。 msysgit还带一个简单的图形界面，可以用来方便地浏览项目的历史，但用它来做日常的提交就不太合适了。你可能想到了TortoiseSVN，类似这样的图形界面才好用。幸好Tortoise也有Git版本：TortoiseGit。# 安装TortoiseGitTortoiseGit 也是托管在Google Code上的开源项目：http://code.google.com/p/tortoisegit TortoiseGit只是Git的前端，要使用它，首先要安装msysgit。这个前面已提到了。 下载最新版的TortoiseGit安装： http://tortoisegit.googlecode.com/files/TortoiseGit-1.6.2.0-32bit.msi 安装完毕以后需要设置TortoiseGit和MsysGit关联。在开始菜单里找到TortoiseGit-&gt;Settings，General选项里输入Git的路径即可。 和msysgit不同，TortoiseGit使用内置的puttygen来生成公私钥对，私钥的扩展名为ppk。要想用TortoiseGit管理GitHub上的项目，则需要将puttygen生成的公钥添加到github上去。 tortoisegit密钥配置参见 http://rongjih.blog.163.com/blog/static/335744612010619111042465/不过可以修改使用msysgit的ssh，在设置-&gt;Network里，修改SSH Client 为msysgit的ssh.exe路径： c:\\ Program Files\\Git\\bin\\ssh.exe即可。","categories":[{"name":"git","slug":"git","permalink":"http://quanke.name/categories/git/"}],"tags":[],"keywords":[{"name":"git","slug":"git","permalink":"http://quanke.name/categories/git/"}]},{"title":"如何成为优秀的软件模型设计者?","slug":"other/e5-a6-82-e4-bd-95-e6-88-90-e4-b8-ba-e4-bc-98-e7-a7-80-e7-9a-84-e8-bd-af-e4-bb-b6-e6-a8-a1-e5-9e-8b-e8-ae-be-e8-ae-a1-e8-80-85","date":"2012-09-25T19:43:14.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/38796/","link":"","permalink":"http://quanke.name/posts/38796/","excerpt":"","text":"模型设计是软件架构师所需具备的基本技能之一，本文是一篇不错的关于如何成为优秀模型设计者的文章，希望对大家有所帮助！ ——Sunny 我们期待自己成为一个优秀的软件模型设计者，但是，要怎样做，又从哪里开始呢？ 将下列原则应用到你的软件工程中，你会获得立杆见影的成果。 1. 人远比技术重要 你开发软件是为了供别人使用，没有人使用的软件只是没有意义的数据的集合而已。许多在软件方面很有成就的行家在他们事业的初期却表现平平，因为他们那时侯将主要精力都集中在技术上。显然，构件（components），EJB（Enterprise Java Beans）和代理（agent）是很有趣的东西。但是对于用户来说，如果你设计的软件很难使用或者不能满足他们的需求，后台用再好的技术也于事无补。多花点时间到软件需求和设计一个使用户能很容易理解的界面上。 2. 理解你要实现的东西 好的软件设计人员把大多数时间花费在建立系统模型上，偶尔写一些源代码，但那只不过是为了验证设计过程中所遇到的问题。这将使他们的设计方案更加可行。 3. 谦虚是必须的品格 你不可能知道一切，你甚至要很努力才能获得足够用的知识。软件开发是一项复杂而艰巨的工作，因为软件开发所用到的工具和技术是在不断更新的。而且，一个人也不可能了解软件开发的所有过程。在日常生活中你每天接触到的新鲜事物可能不会太多。但是对于从事软件开发的人来说，每天可以学习很多新东西（如果愿意的话）。 4. 需求就是需求 如果你没有任何需求，你就不要动手开发任何软件。成功的软件取决于时间（在用户要求的时间内完成）、预算和是否满足用户的需求。如果你不能确切知道用户需要的是什么，或者软件的需求定义，那么你的工程注定会失败。 5. 需求其实很少改变，改变的是你对需求的理解 Object ToolSmiths公司的Doug Smith常喜欢说：“分析是一门科学，设计是一门艺术”。他的意思是说在众多的“正确”分析模型中只存在一个最“正确”分析模型可以完全满足解决某个具体问题的需要（我理解的意思是需求分析需要一丝不苟、精确的完成,而设计的时候反而可以发挥创造力和想象力 - 译者注）。 如果需求经常改动，很可能是你没有作好需求分析，并不是需求真的改变了。 你可以抱怨用户不能告诉你他们想得到什么，但是不要忘记，收集需求信息是你工作。 你可以说是新来的开发人员把事情搞得一团糟，但是，你应该确定在工程的第一天就告诉他们应该做什么和怎样去做。 如果你觉得公司不让你与用户充分接触，那只能说明公司的管理层并不是真正支持你的项目。 你可以抱怨公司有关软件工程的管理制度不合理，但你必须了解大多同行公司是怎么做的。 你可以借口说你们的竞争对手的成功是因为他们有了一个新的理念，但是为什么你没先想到呢？ 需求真正改变的情况很少，但是没有做好需求分析工作的理由却很多。 6. 经常阅读 在这个每日都在发生变化的产业中，你不可能在已取得的成就上陶醉太久。 每个月至少读2、3本专业杂志或者1本专业书籍。保持不落伍需要付出很多的时间和金钱，但会使你成为一个很有实力的竞争者。 7. 降低软件模块间的耦合度 高耦合度的系统是很难维护的。一处的修改引起另一处甚至更多处的变动。 你可以通过以下方法降低程序的耦合度：隐藏实现细节，强制构件接口定义，不使用公用数据结构，不让应用程序直接操作数据库（我的经验法则是：当应用程序员在写SQL代码的时候，你的程序的耦合度就已经很高了）。 耦合度低的软件可以很容易被重用、维护和扩充。 8. 提高软件的内聚性 如果一个软件的模块只实现一个功能，那么该模块具有高内聚性。高内聚性的软件更容易维护和改进。 判断一个模块是否有高的内聚性，看一看你是否能够用一个简单的句子描述它的功能就行了。如果你用了一段话或者你需要使用类似“和”、“或”等连词，则说明你需要将该模块细化。 只有高内聚性的模块才可能被重用。 9. 考虑软件的移植性 移植是软件开发中一项具体而又实际的工作，不要相信某些软件工具的广告宣传（比如java 的宣传口号write once run many ? 译者注）。 即使仅仅对软件进行常规升级，也要把这看得和向另一个操作系统或数据库移植一样重要。 记得从16位Windows移植到32位windows的“乐趣”吗 ？当你使用了某个操作系统的特性，如它的进程间通信(IPC)策略，或用某数据库专有语言写了存储过程。你的软件和那个特定的产品结合度就已经很高了。 好的软件设计者把那些特有的实现细节打包隐藏起来，所以，当那些特性该变的时候，你的仅仅需要更新那个包就可以了。 10. 接受变化 这是一句老话了：唯一不变的只有变化。 你应该将所有系统将可能发生的变化以及潜在需求记录下来,以便将来能够实现（参见“Architecting for Change”，Thinking Objectively, May 1999） 通过在建模期间考虑这些假设的情况，你就有可能开发出足够强壮且容易维护的软件。设计强壮的软件是你最基本的目标。 11. 不要低估对软件规模的需求 Internet 带给我们的最大的教训是你必须在软件开发的最初阶段就考虑软件规模的可扩充性。 今天只有100人的部门使用的应用程序，明天可能会被有好几万人的组织使用，下月，通过因特网可能会有几百万人使用它。 在软件设计的初期，根据在用例模型中定义的必须支持的基本事务处理，确定软件的基本功能。然后，在建造系统的时候再逐步加入比较常用的功能。 在设计的开始考虑软件的规模需求，避免在用户群突然增大的情况下，重写软件。 12. 性能仅仅是很多设计因素之一 关注软件设计中的一个重要因素–性能，这好象也是用户最关心的事情。一个性能不佳的软件将不可避免被重写。 但是你的设计还必须具有可靠性，可用性，便携性和可扩展性。你应该在工程开始就应该定义并区分好这些因素，以便在工作中恰当使用。性能可以是，也可以不是优先级最高的因素，我的观点是，给每个设计因素应有的考虑。 13. 管理接口 “UML User Guide”（Grady Booch，Ivar Jacobson和Jim Rumbaugh ,Addison Wesley, 1999）中指出，你应该在开发阶段的早期就定义软件模块之间的接口。 这有助于你的开发人员全面理解软件的设计结构并取得一致意见，让各模块开发小组相对独立的工作。一旦模块的接口确定之后，模块怎样实现就不是很重要了。 从根本上说，如果你不能够定义你的模块“从外部看上去会是什么样子”，你肯定也不清楚模块内要实现什么。 14. 走近路需要更长的时间 在软件开发中没有捷径可以走。 缩短你的在需求分析上花的时间，结果只能是开发出来的软件不能满足用户的需求，必须被重写。 在软件建模上每节省一周，在将来的编码阶段可能会多花几周时间，因为你在全面思考之前就动手写程序。 你为了节省一天的测试时间而漏掉了一个bug，在将来的维护阶段，可能需要花几周甚至几个月的时间去修复。与其如此，还不如重新安排一下项目计划。 避免走捷径，只做一次但要做对（do it once by doing it right）。 15. 别信赖任何人 产品和服务销售公司不是你的朋友，你的大部分员工和高层管理人员也不是。 大部分产品供应商希望把你牢牢绑在他们的产品上，可能是操作系统，数据库或者某个开发工具。 大部分的顾问和承包商只关心你的钱并不是你的工程（停止向他们付款，看一看他们会在周围呆多长时间）。 大部分程序员认为他们自己比其他人更优秀，他们可能抛弃你设计的模型而用自己认为更好的。 只有良好的沟通才能解决这些问题。 要明确的是，不要只依靠一家产品或服务提供商，即使你的公司（或组织）已经在建模、文档和过程等方面向那个公司投入了很多钱。 16. 证明你的设计在实践中可行 在设计的时候应当先建立一个技术原型， 或者称为“端到端”原型。以证明你的设计是能够工作的。 你应该在开发工作的早期做这些事情，因为，如果软件的设计方案是不可行的，在编码实现阶段无论采取什么措施都于事无补。技术原型将证明你的设计的可行性，从而，你的设计将更容易获得支持。 17. 应用已知的模式 目前，我们有大量现成的分析和设计模式以及问题的解决方案可以使用。 一般来说，好的模型设计和开发人员，都会避免重新设计已经成熟的并被广泛应用的东西。 http://www.ambysoft.com/processPatternsPage.html 收藏了许多开发模式的信息。 18. 研究每个模型的长处和弱点 目前有很多种类的模型可以使用。用例捕获的是系统行为需求，数据模型则描述支持一个系统运行所需要的数据构成。你可能会试图在用例中加入实际数据描述，但是，这对开发者不是非常有用。同样，数据模型对描述软件需求来说是无用的。每个模型在你建模过程中有其相应的位置，但是，你需要明白在什么地方，什么时候使用它们。 19. 在现有任务中应用多个模型 当你收集需求的时候，考虑使用用例模型，用户界面模型和领域级的类模型。 当你设计软件的时候，应该考虑制作类模型，顺序图、状态图、协作图和最终的软件实际物理模型。 程序设计人员应该慢慢意识到，仅仅使用一个模型而实现的软件要么不能够很好地满足用户的需求，要么很难扩展。 20. 教育你的听众 你花了很大力气建立一个很成熟的系统模型，而你的听众却不能理解它们，甚至更糟－连为什么要先建立模型都不知道。那么你的工作是毫无意义的。 教给你开发人员基本的建模知识；否则，他们会只看看你画的漂亮图表，然后继续编写不规范的程序。 另外， 你还需要告诉你的用户一些需求建模的基础知识。给他们解释你的用例(uses case)和用户界面模型，以使他们能够明白你要表达地东西。当每个人都能使用一个通用的设计语言的时候（比如UML-译者注），你的团队才能实现真正的合作。 21. 用工具的傻瓜还是傻瓜 你给我CAD/CAM工具，请我设计一座桥。但是，如果那座桥建成的话，我肯定不想当第一个从桥上过的人，因为我对建筑一窍不通。 使用一个很优秀的CASE工具并不能使你成为一个建模专家，只能使你成为一个优秀CASE工具的使用者。成为一个优秀的建模专家需要多年的积累，不会是一周针对某个价值几千美元工具的培训。一个优秀的CASE工具是很重要，但你必须学习使用它，并能够使用它设计它支持的模型。 22. 理解完整的过程 好的设计人员应该理解整个软件过程，尽管他们可能不是精通全部实现细节。 软件开发是一个很复杂的过程，还记得《object-oriented software process》第36页的内容吗？除了编程、建模、测试等你擅长工作外，还有很多工作要做。 好的设计者需要考虑全局。必须从长远考虑如何使软件满足用户需要，如何提供维护和技术支持等。 23. 常做测试，早做测试 如果测试对你的软件来说是无所谓的，那么你的软件多半也没什么必要被开发出来。 建立一个技术原型供技术评审使用，以检验你的软件模型。 在软件生命周期中，越晚发现的错误越难修改，修改成本越昂贵。尽可能早的做测试是很值得的。 24. 把你的工作归档 不值得归档的工作往往也不值得做。归档你的设想，以及根据设想做出的决定；归档软件模型中很重要但不很明显的部分。 给每个模型一些概要描述以使别人很快明白模型所表达的内容。 25. 技术会变，基本原理不会 如果有人说“使用某种开发语言、某个工具或某某技术，我们就不需要再做需求分析，建模，编码或测试”。不要相信，这只说明他还缺乏经验。抛开技术和人的因素，实际上软件开发的基本原理自20世纪70年代以来就没有改变过。你必须还定义需求，建模，编码，测试，配置，面对风险，发布产品，管理工作人员等等。 软件建模技术是需要多年的实际工作才能完全掌握的。好在你可以从我的建议开始，完善你们自己的软件开发经验。 从鸡汤开始，加入自己的蔬菜。然后，开始享受你自己的丰盛晚餐吧。 【转自：http://dev.yesky.com/SoftChannel/72342389024358400/20050115/1901524.shtml】","categories":[{"name":"软件工程","slug":"se","permalink":"http://quanke.name/categories/se/"}],"tags":[],"keywords":[{"name":"软件工程","slug":"se","permalink":"http://quanke.name/categories/se/"}]},{"title":"android Animation 动画效果介绍","slug":"android/android-animation","date":"2012-09-04T06:38:33.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/58864/","link":"","permalink":"http://quanke.name/posts/58864/","excerpt":"","text":"Android的animation由四种类型组成XML中 alpha 渐变透明度动画效果scale 渐变尺寸伸缩动画效果translate 画面转换位置移动动画效果rotate 画面转移旋转动画效果 JavaCode中AlphaAnimation 渐变透明度动画效果ScaleAnimation 渐变尺寸伸缩动画效果TranslateAnimation 画面转换位置移动动画效果RotateAnimation 画面转移旋转动画效果 Android动画模式 Animation主要有两种动画模式： 一种是tweened animation(渐变动画)XML中 JavaCodealpha AlphaAnimationscale ScaleAnimation 一种是frame by frame(画面转换动画)XML中 JavaCodetranslate TranslateAnimationrotate RotateAnimation 如何在XML文件中定义动画 ① 打开Eclipse，新建Android工程② 在res目录中新建anim文件夹③ 在anim目录中新建一个myanim.xml(注意文件名小写)④ 加入XML的动画代码 [code lang=”xml”]&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &lt;alpha/&gt; &lt;scale/&gt; &lt;translate/&gt; &lt;rotate/&gt; &lt;/set&gt;[/code]Android动画解析–XML [code lang=”xml”]&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&amp;quot; &gt; &lt;alpha android:fromAlpha=&quot;0.1&quot; &lt;!–fromAlpha(浮点型值) 属性为动画起始时透明度, 0.0表示完全透明 –&gt; android:toAlpha=&quot;1.0&quot; &lt;!– toAlpha(浮点型值) 属性为动画结束时透明度, 1.0表示完全不透明. fromAlpha 和 toAlpha 的取值在0.0-1.0之间的float数据类型的数字 –&gt; android:duration=&quot;3000&quot;&lt;!– duration(长整型值) 属性为动画持续时间,时间以毫秒为单位–&gt; /&gt; &lt;/set&gt;[/code] [code lang=”xml”]&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &lt;scale android:interpolator= &quot;@android:anim/accelerate_decelerate_interpolator&quot; android:fromXScale=&quot;0.0&quot; android:toXScale=&quot;1.4&quot; android:fromYScale=&quot;0.0&quot; android:toYScale=&quot;1.4&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:fillAfter=&quot;false&quot; android:duration=&quot;700&quot; /&gt; &lt;/set&gt; &lt;!– 尺寸伸缩动画效果 scale 属性：interpolator 指定一个动画的插入器 在我试验过程中，使用android.res.anim中的资源时候发现 有三种动画插入器: accelerate_decelerate_interpolator 加速-减速 动画插入器 accelerate_interpolator 加速-动画插入器 decelerate_interpolator 减速- 动画插入器 其他的属于特定的动画效果 浮点型值： fromXScale 属性为动画起始时 X坐标上的伸缩尺寸 toXScale 属性为动画结束时 X坐标上的伸缩尺寸 fromYScale 属性为动画起始时Y坐标上的伸缩尺寸 toYScale 属性为动画结束时Y坐标上的伸缩尺寸 说明: 以上四种属性值 0.0表示收缩到没有 1.0表示正常无伸缩 值小于1.0表示收缩 值大于1.0表示放大 pivotX 属性为动画相对于物件的X坐标的开始位置 pivotY 属性为动画相对于物件的Y坐标的开始位置 说明: 以上两个属性值 从0%-100%中取值 50%为物件的X或Y方向坐标上的中点位置 长整型值： duration 属性为动画持续时间 说明: 时间以毫秒为单位 布尔型值: fillAfter 属性 当设置为true ，该动画转化在动画结束后被应用 –&gt;[/code] [code lang=”xml”]&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &lt;translate android:fromXDelta=&quot;30&quot; android:toXDelta=&quot;-80&quot; android:fromYDelta=&quot;30&quot; android:toYDelta=&quot;300&quot; android:duration=&quot;2000&quot; /&gt; &lt;!– translate 位置转移动画效果 整型值: fromXDelta 属性为动画起始时 X坐标上的位置 toXDelta 属性为动画结束时 X坐标上的位置 fromYDelta 属性为动画起始时 Y坐标上的位置 toYDelta 属性为动画结束时 Y坐标上的位置 注意: 没有指定fromXType toXType fromYType toYType 时候， 默认是以自己为相对参照物 长整型值： duration 属性为动画持续时间 说明: 时间以毫秒为单位 –&gt; &lt;/set&gt;[/code] [code lang=”xml”]&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt; &lt;rotate android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; android:fromDegrees=&quot;0&quot; android:toDegrees=&quot;+350&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:duration=&quot;3000&quot; /&gt; &lt;!– rotate 旋转动画效果 属性：interpolator 指定一个动画的插入器 在我试验过程中，使用android.res.anim中的资源时候发现 有三种动画插入器: accelerate_decelerate_interpolator 加速-减速 动画插入器 accelerate_interpolator 加速-动画插入器 decelerate_interpolator 减速- 动画插入器 其他的属于特定的动画效果 浮点数型值: fromDegrees 属性为动画起始时物件的角度 toDegrees 属性为动画结束时物件旋转的角度 可以大于360度 说明: 当角度为负数——表示逆时针旋转 当角度为正数——表示顺时针旋转 (负数from——to正数:顺时针旋转) (负数from——to负数:逆时针旋转) (正数from——to正数:顺时针旋转) (正数from——to负数:逆时针旋转) pivotX 属性为动画相对于物件的X坐标的开始位置 pivotY 属性为动画相对于物件的Y坐标的开始位置 说明: 以上两个属性值 从0%-100%中取值 50%为物件的X或Y方向坐标上的中点位置 长整型值： duration 属性为动画持续时间 说明: 时间以毫秒为单位 –&gt; &lt;/set&gt;[/code]如何使用XML中的动画效果[code lang=”java”]public static Animation loadAnimation (Context context, int id) //第一个参数Context为程序的上下文 //第二个参数id为动画XML文件的引用 //例子： myAnimation= AnimationUtils.loadAnimation(this,R.anim.my_action); //使用AnimationUtils类的静态方法loadAnimation()来加载XML中的动画XML文件[/code] 如何在Java代码中定义动画[code lang=”java”]//在代码中定义 动画实例对象 private Animation myAnimation_Alpha; private Animation myAnimation_Scale; private Animation myAnimation_Translate; private Animation myAnimation_Rotate; //根据各自的构造方法来初始化一个实例对象 myAnimation_Alpha=new AlphaAnimation(0.1f, 1.0f); myAnimation_Scale =new ScaleAnimation(0.0f, 1.4f, 0.0f, 1.4f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); myAnimation_Translate=new TranslateAnimation(30.0f, -80.0f, 30.0f, 300.0f); myAnimation_Rotate=new RotateAnimation(0.0f, +350.0f, Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF, 0.5f);[/code]Android动画解析–JavaCode AlphaAnimation ① AlphaAnimation类对象定义[code lang=”java”]private AlphaAnimation myAnimation_Alpha;[/code]② AlphaAnimation类对象构造[code lang=”java”]AlphaAnimation(float fromAlpha, float toAlpha) //第一个参数fromAlpha为 动画开始时候透明度 //第二个参数toAlpha为 动画结束时候透明度 myAnimation_Alpha=new AlphaAnimation(0.1f, 1.0f); //说明: // 0.0表示完全透明 // 1.0表示完全不透明[/code] ③ 设置动画持续时间[code lang=”java”]myAnimation_Alpha.setDuration(5000); //设置时间持续时间为 5000毫秒[/code]ScaleAnimation ① ScaleAnimation类对象定义[code lang=”java”]private AlphaAnimation myAnimation_Alpha;[/code]② ScaleAnimation类对象构造[code lang=”java”]ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) //第一个参数fromX为动画起始时 X坐标上的伸缩尺寸 //第二个参数toX为动画结束时 X坐标上的伸缩尺寸 //第三个参数fromY为动画起始时Y坐标上的伸缩尺寸 //第四个参数toY为动画结束时Y坐标上的伸缩尺寸 /说明: 以上四种属性值 0.0表示收缩到没有 1.0表示正常无伸缩 值小于1.0表示收缩 值大于1.0表示放大 / //第五个参数pivotXType为动画在X轴相对于物件位置类型 //第六个参数pivotXValue为动画相对于物件的X坐标的开始位置 //第七个参数pivotXType为动画在Y轴相对于物件位置类型 //第八个参数pivotYValue为动画相对于物件的Y坐标的开始位置 myAnimation_Scale =new ScaleAnimation(0.0f, 1.4f, 0.0f, 1.4f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);[/code]③ 设置动画持续时间[code lang=”java”]myAnimation_Scale.setDuration(700); //设置时间持续时间为 700毫秒[/code]TranslateAnimation ① TranslateAnimation类对象定义[code lang=”java”]private AlphaAnimation myAnimation_Alpha;[/code]② TranslateAnimation类对象构造[code lang=”java”]TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) //第一个参数fromXDelta为动画起始时 X坐标上的移动位置 //第二个参数toXDelta为动画结束时 X坐标上的移动位置 //第三个参数fromYDelta为动画起始时Y坐标上的移动位置 //第四个参数toYDelta为动画结束时Y坐标上的移动位置[/code]③ 设置动画持续时间[code lang=”java”]myAnimation_Translate.setDuration(2000); //设置时间持续时间为 2000毫秒[/code]RotateAnimation ① RotateAnimation类对象定义[code lang=”java”]private AlphaAnimation myAnimation_Alpha;[/code]② RotateAnimation类对象构造[code lang=”java”]RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) //第一个参数fromDegrees为动画起始时的旋转角度 //第二个参数toDegrees为动画旋转到的角度 //第三个参数pivotXType为动画在X轴相对于物件位置类型 //第四个参数pivotXValue为动画相对于物件的X坐标的开始位置 //第五个参数pivotXType为动画在Y轴相对于物件位置类型 //第六个参数pivotYValue为动画相对于物件的Y坐标的开始位置 myAnimation_Rotate=new RotateAnimation(0.0f, +350.0f, Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF, 0.5f);[/code]③ 设置动画持续时间[code lang=”java”]myAnimation_Rotate.setDuration(3000); //设置时间持续时间为 3000毫秒[/code]如何使用Java代码中的动画效果 使用从View父类继承过来的方法startAnimation()来为View或是子类View等等添加一个动画效果[code lang=”java”]public void startAnimation (Animation animation)[/code]","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"使用android新版本（adt20）开发工具出现NoClassDefFoundError解决方案","slug":"other/e4-bd-bf-e7-94-a8android-e6-96-b0-e7-89-88-e6-9c-ac-ef-bc-88adt20-ef-bc-89-e5-bc-80-e5-8f-91-e5-b7-a5-e5-85-b7-e5-87-ba-e7-8e-b0noclassdeffounderror-e8-a7-a3-e5-86-b3-e6-96-b9-e6-a1-88","date":"2012-08-28T19:24:04.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/25638/","link":"","permalink":"http://quanke.name/posts/25638/","excerpt":"出现问题： 在使用新版本开发有时候会莫名其妙的来一个“没有发现类异常” java.lang.NoClassDefFoundError: *检查了老久还是不知道怎么回事。 查出问题： 开始我是: 右击jar文件-&gt;Build Path -&gt;Add Build Path，就是这一步出现的问题 解决问题：","text":"出现问题： 在使用新版本开发有时候会莫名其妙的来一个“没有发现类异常” java.lang.NoClassDefFoundError: *检查了老久还是不知道怎么回事。 查出问题： 开始我是: 右击jar文件-&gt;Build Path -&gt;Add Build Path，就是这一步出现的问题 解决问题：在adt20的版本里不要手动添加jar包，只需要在项目的根目录下新建一个libs的目录，把需要加入的jar包放到libs目录下即可。 如果还有其他原因导致NoClassDefFoundError，欢迎留言","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"Linux(Ubuntu)下配置Android环境变量","slug":"linux/linuxubuntu-e4-b8-8b-e9-85-8d-e7-bd-aeandroid-e7-8e-af-e5-a2-83-e5-8f-98-e9-87-8f","date":"2012-08-27T23:04:46.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/12999/","link":"","permalink":"http://quanke.name/posts/12999/","excerpt":"","text":"前提条件： eclipse，adt都装好了，可以开发android应用程序，但是不能在命令行操作，不能直接执行adb，android等命令 开始配置： 按住Ctrl+Alt+T打开命令行， 然后输入 sudo gedit /etc/profile打开配置文件，加入android的配置信息，最后的样子是 #Set jdk1.7.0_04 Environment export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_04 export ANDROID_HOME=/home/gaialine/android-sdks export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools 然后保存，一定要记得重启电脑才能生效。 **注意：** 配置完成后要重启电脑 配置PATH的时候不要吧，已经有的配置删除，要加一个“：”再写自己的配置信息 在配置android的PATH的时候有两个目录，${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools**小结：** 其实这里面就包含了，java的环境变量的配置，android环境变量的配置和java的一样，都是在/etc/profile里配置。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"linux配置java环境变量","slug":"linux/linux-e9-85-8d-e7-bd-aejava-e7-8e-af-e5-a2-83-e5-8f-98-e9-87-8f","date":"2012-08-27T19:09:51.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/58426/","link":"","permalink":"http://quanke.name/posts/58426/","excerpt":"","text":"一. 解压安装jdk在shell终端下进入jdk-6u14-linux-i586.bin文件所在目录，执行命令 ./jdk-6u14-linux-i586.bin 这时会出现一段协议，连继敲回车，当询问是否同意的时候，输入yes，回车。之后会在当前目录下生成一个jdk1.6.0_14目录，你可以将它复制到 任何一个目录下。 二. 需要配置的环境变量1. PATH环境变量。作用是指定命令搜索路径，在shell下面执行命令时，它会到PATH变量所指定的路径中查找看是否能找到相应的命令程序。我们需要把 jdk安装目录下的bin目录增加到现有的PATH变量中，bin目录中包含经常要用到的可执行文件如javac/java/javadoc等待，设置好 PATH变量后，就可以在任何目录下执行javac/java等工具了。2. CLASSPATH环境变量。作用是指定类搜索路径，要使用已经编写好的类，前提当然是能够找到它们了，JVM就是通过CLASSPTH来寻找类的。我们 需要把jdk安装目录下的lib子目录中的dt.jar和tools.jar设置到CLASSPATH中，当然，当前目录“.”也必须加入到该变量中。3. JAVA_HOME环境变量。它指向jdk的安装目录，Eclipse/NetBeans/Tomcat等软件就是通过搜索JAVA_HOME变量来找到并使用安装好的jdk。 三. 三种配置环境变量的方法 1. 修改/etc/profile文件如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。·用文本编辑器打开/etc/profile·在profile文件末尾加入：export JAVA_HOME=/usr/share/jdk1.6.0_14export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar·重新登录·注解a. 你要将 /usr/share/jdk1.6.0_14改为你的jdk安装目录b. linux下用冒号“:”来分隔路径c. $PATH / $CLASSPATH / $JAVA_HOME 是用来引用原来的环境变量的值在设置环境变量时特别要注意不能把原来的值给覆盖掉了，这是一种常见的错误。d. CLASSPATH中当前目录“.”不能丢,把当前目录丢掉也是常见的错误。e. export是把这三个变量导出为全局变量。f. 大小写必须严格区分。 2. 修改.bash_profile文件 这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bash_profile文件就可以了。·用文本编辑器打开用户目录下的.bash_profile文件·在.bash_profile文件末尾加入： export JAVA_HOME=/usr/share/jdk1.6.0_14export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ·重新登录 3. 直接在shell下设置变量不赞成使用这种方法，因为换个shell，你的设置就无效了，因此这种方法仅仅是临时使用，以后要使用的时候又要重新设置，比较麻烦。只需在shell终端执行下列命令：export JAVA_HOME=/usr/share/jdk1.6.0_14export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 四. 测试jdk1. 用文本编辑器新建一个Test.java文件，在其中输入以下代码并保存：[code lang=”java”]public class test { public static void main(String args[]) { System.out.println(&quot;A new jdk test !&quot;); }}[/code]2. 编译：在shell终端执行命令 javac Test.java3. 运行：在shell终端执行命令 java Test当shell下出现“A new jdk test !”字样则jdk运行正常。 五. 卸载jdk·找到jdk安装目录的_uninst子目录·在shell终端执行命令./uninstall.sh即可卸载jdk。","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]},{"title":"android应用从零开始到发布","slug":"android/android-e5-ba-94-e7-94-a8-e4-bb-8e-e9-9b-b6-e5-bc-80-e5-a7-8b-e5-88-b0-e5-8f-91-e5-b8-83","date":"2012-08-27T06:35:37.000Z","updated":"2018-01-31T15:38:57.000Z","comments":true,"path":"posts/61425/","link":"","permalink":"http://quanke.name/posts/61425/","excerpt":"android应用从零开始到发布 android应用从零开始到发布要经历几个过程： 1．搭建android开发环境。 2．开发应用（中间很多步省略）。 3．发布。","text":"android应用从零开始到发布 android应用从零开始到发布要经历几个过程： 1．搭建android开发环境。 2．开发应用（中间很多步省略）。 3．发布。1步我们这里不谈，可以到我的博客里面找找，2步的话这里也说不清楚，我们主要谈谈第三步，怎么发布我们的应用。 假设程序开发好了，只等发布了，你还要做几件事： 1．准备好程序的截图： 截图可以使用豌豆夹，或者直接使用eclipse截图，在androd市场只能上传两张图片，所以一定要选择两张有代表性的，可以吸引用户的图片，android市场只接受320480和480854像素的图片。 2．写好程序简介： android市场最多只许325个字符，所以在写简介的时候要字字斟酌，最好在后面加上你应用的网址，有更加详细的介绍。 3．做数字签名导出程序： 做数字签名是这篇文章主要介绍的，在Android系统中，所有安装到系统的应用程序都必有一个数字证书，此数字证书用于标识应用程序的作者和在应用程序之间建立信任关系,如果一个permission的protectionLevel为signature，那么就只有那些跟该permission所在的程序拥有同一个数字证书的应用程序才能取得该权限。Android使用Java的数字证书相关的机制来给apk加盖数字证书，要理解android的数字证书，需要先了解以下数字证书的概念和java的数字证书机制。Android系统要求每一个安装进系统的应用程序都是经过数字证书签名的，数字证书的私钥则保存在程序开发者的手中。Android将数字证书用来标识应用程序的作者和在应用程序之间建立信任关系，不是用来决定最终用户可以安装哪些应用程序。这个数字证书并不需要权威的数字证书签名机构认证，它只是用来让应用程序包自我认证的。 同一个开发者的多个程序尽可能使用同一个数字证书，这可以带来以下好处。 (1)有利于程序升级，当新版程序和旧版程序的数字证书相同时，Android系统才会认为这两个程序是同一个程序的不同版本。如果新版程序和旧版程序的数字证书不相同，则Android系统认为他们是不同的程序，并产生冲突，会要求新程序更改包名。 (2)有利于程序的模块化设计和开发。Android系统允许拥有同一个数字签名的程序运行在一个 进程中，Android程序会将他们视为同一个程序。所以开发者可以将自己的程序分模块开发，而用户只需要在需要的时候下载适当的模块。 (3)可以通过权限(permission)的方式在多个程序间共享数据和代码。Android提供了基于数字证书的权限赋予机制，应用程序可以和其他的程序共享概功能或者数据给那那些与自己拥有相同数字证书的程序。如果某个权限(permission)的protectionLevel是signature，则这个权限就只能授予那些跟该权限所在的包拥有同一个数字证书的程序。 在签名时，需要考虑数字证书的有效期： (1)数字证书的有效期要包含程序的预计生命周期，一旦数字证书失效，持有改数字证书的程序将不能正常升级。 (2)如果多个程序使用同一个数字证书，则该数字证书的有效期要包含所有程序的预计生命周期。 (3)Android Market强制要求所有应用程序数字证书的有效期要持续到2033年10月22日以后。 Android数字证书包含以下几个要点： (1)所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序 (2)Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证 (3)如果要正式发布一个Android ，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。 (4)数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。 (5)Android使用标准的java工具 Keytool and Jarsigner 来生成数字证书，并给应用程序包签名。 (6）使用zipalign优化程序。 Android系统不会安装运行任何一款未经数字签名的apk程序，无论是在模拟器上还是在实际的物理设备上。Android的开发工具(ADT插件和Ant)都可以协助开发者给apk程序签名，它们都有两种模式：调试模式(debug mode)和发布模式(release mode)。 在调试模式下，android的开发工具会在每次编译时使用调试用的数字证书给程序签名，开发者无须关心。 当要发布程序时，开发者就需要使用自己的数字证书给apk包签名，可以有两种方法。 (1)在命令行下使用JDK中的和Keytool(用于生成数字证书)和Jarsigner(用于使用数字证书签名)来给apk包签名。 (2)使用ADT Export Wizard进行签名(如果没有数字证书可能需要生成数字证书)。 使用Keytool和Jarsigner给程序签名 我们主要是使用第二中，第一种麻烦，第二种只要你在eclipse里装好了android的开发环境，就可以使用啦！ 一、鼠标右击项目-&gt;Android Tools-&gt;Export Signed Application Package 二、选择下一步 三、填写保存地址，密码，重复密码，选择下一步 四、填写别名，密码，重复密码，有效期，组织单位，单位（我也不知道怎么区分，我的英语烂），城市，省份，国家代码 五、选择保存的地方，单击完成； Ok了，apk出来了，签名也好了，下面可以正式发布啦！ 4．正式发布 真正的发布就是很简单了，看看就可以！我也不多说，如果有问题，留言！","categories":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}],"tags":[],"keywords":[{"name":"android开发","slug":"android","permalink":"http://quanke.name/categories/android/"}]}]}